{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VulnScanAI Documentation","text":"<p>Welcome to the official documentation for VulnScanAI \u2014 a comprehensive and modular vulnerability assessment platform. This documentation is intended to help developers and stakeholders understand the structure, capabilities, and implementation details of VulnScanAI.</p> <p>Whether you're integrating a new scanner, debugging issues, or extending features, this guide provides in-depth information on the application's architecture, configuration, and functionality.</p>"},{"location":"#project-structure","title":"\ud83d\udcc1 Project Structure","text":"<p>VulnScanAI is structured into modular directories, each with a defined responsibility:</p> <ul> <li>App Directory: Core logic, configurations, and the central orchestrator of VulnScanAI.</li> <li>Scanners Directory: Contains all integrated vulnerability scanners like Nmap, Nikto, ZAP, SQLMap, MobSF, Prowler, and CloudSploit.</li> <li>Views Directory: Defines Flask view functions and route logic for UI and scan operations.</li> <li>Templates Directory: Jinja2 HTML templates for all frontend pages including Home, Login, Report Analysis, and more.</li> </ul>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li> <p>\ud83d\udd0d Multi-Tool Vulnerability Scanning   Integrates tools like Nmap, ZAP, SQLMap, MobSF, Prowler, and more for holistic security assessments.</p> </li> <li> <p>\ud83e\udde0 AI-Powered Report Analysis   Leverages GenAI (Gemini) to provide contextual insights on scan results.</p> </li> <li> <p>\ud83d\udcca PDF Report Generation   Automatically compiles scan results into downloadable, readable PDF reports.</p> </li> <li> <p>\ud83d\udd10 Authentication &amp; Access Management   Supports login, signup, subscription tiers (Free, Pro, Premium).</p> </li> <li> <p>\ud83d\udcb5 Payment Integration   PayPal integration for managing user subscriptions and pricing plans.</p> </li> <li> <p>\u2601\ufe0f Cloud Audits   Includes support for AWS, GCP, and Azure misconfiguration scans via Prowler and CloudSploit.</p> </li> </ul>"},{"location":"#explore-the-documentation","title":"\ud83d\udcda Explore the Documentation","text":"<p>Navigate through the sidebar or the Table of Contents to explore:</p> <ul> <li>Detailed walkthroughs of each scanner</li> <li>Application routes and views</li> <li>Frontend templates and customization</li> <li>Configuration, forms, models, and extensions</li> </ul>"},{"location":"01_app/","title":"Directory: <code>app</code>","text":"<p>Purpose: This directory forms the core of the VulnScanAI Flask web application. It houses essential components like configuration, data models, user interface templates, vulnerability scanners, and route handling logic, enabling the application's functionality.</p> <p>Overview:</p> <p>The <code>app</code> directory is structured to promote modularity and maintainability. Key aspects include:</p> <ul> <li>Configuration Management: Centralized settings for different environments (development, production).</li> <li>Data Modeling: Database models representing users, subscriptions, and scan results.</li> <li>User Interface Rendering: HTML templates for presenting information to the user.</li> <li>Vulnerability Scanning Integrations: Modules for interacting with external security scanning tools.</li> <li>Route Handling: Logic for managing user requests and application behavior.</li> </ul> <p>Subdirectories:</p> <ul> <li> <p><code>reports/</code>:</p> <ul> <li>Purpose: Stores generated reports from various vulnerability scanners.</li> <li>Content: Typically contains PDF or HTML files.</li> <li>(See dedicated documentation for the <code>reports</code> directory)</li> </ul> </li> <li> <p><code>scanners/</code>:</p> <ul> <li>Purpose: Contains the integration code for different vulnerability scanning tools. Each scanner has its own module to encapsulate its specific logic.</li> <li>Example Scanners: Nmap, Nikto, ZAP, MobSF, SQLMap, SSLScan, Prowler (AWS &amp; GCP), CloudSploit (Azure).</li> <li>(See dedicated documentation for the <code>scanners</code> directory)</li> </ul> </li> <li> <p><code>static/</code>:</p> <ul> <li>Purpose: Stores static assets served directly to the client's browser.</li> <li>Content: CSS stylesheets, JavaScript files, images (including the company logo), and potentially other static files like pre-generated PDFs.</li> </ul> </li> <li> <p><code>templates/</code>:</p> <ul> <li>Purpose: Contains HTML templates used to render the application's user interface.</li> <li>Technology: Utilizes the Jinja2 templating engine for dynamic content generation.</li> </ul> </li> <li> <p><code>uploads/</code>:</p> <ul> <li>Purpose: Stores files uploaded by users, especially PDF files for Generative AI Analysis or other processing.</li> <li>Note: Requires careful handling to ensure security and prevent malicious uploads.</li> </ul> </li> <li> <p><code>views/</code>:</p> <ul> <li>Purpose: Contains view functions that handle incoming web requests and generate responses. These functions are the glue between the user interface, data models, and application logic.</li> <li>Route Handling: Defines routes (URLs) and associated logic using Flask's routing mechanisms.</li> </ul> </li> </ul> <p>Files:</p> <ul> <li> <p><code>config.py</code>:</p> <ul> <li>Description: Centralized configuration settings for the Flask application.</li> <li>Functionality:<ul> <li>Loads configuration variables from environment variables using <code>os.environ.get()</code>.</li> <li>Defines settings like <code>SECRET_KEY</code>, <code>SQLALCHEMY_DATABASE_URI</code>, <code>MAIL_*</code> (for email), <code>RECAPTCHA_*</code> (for reCAPTCHA), <code>GEMINI_API_KEY</code>, <code>MOBSF_API_*</code>, <code>PERMANENT_SESSION_LIFETIME</code>, and <code>PAYPAL_*</code>.</li> </ul> </li> <li>Dependencies: <code>os</code>, <code>dotenv</code></li> </ul> </li> <li> <p><code>extensions.py</code>:</p> <ul> <li>Description: Initializes and configures Flask extensions to promote code reuse and separation of concerns.</li> <li>Functionality:<ul> <li>Creates instances of <code>SQLAlchemy()</code> (for database interactions) and <code>Mail()</code> (for sending emails).</li> <li>Provides a central point to access database and mail functionalities throughout the application.</li> </ul> </li> <li>Dependencies: <code>flask_sqlalchemy</code>, <code>flask_mail</code></li> </ul> </li> <li> <p><code>forms.py</code>:</p> <ul> <li>Description: Defines forms for user input validation and processing, leveraging Flask-WTF.</li> <li>Functionality:<ul> <li>Defines form classes (<code>RegistrationForm</code>, <code>LoginForm</code>, etc.) with WTForms fields and validators.</li> <li>Includes custom validators (e.g., <code>password_strength</code>) for specific requirements.</li> <li>Handles CSRF protection.</li> </ul> </li> <li>Dependencies: <code>flask_wtf</code>, <code>wtforms</code>, <code>wtforms.validators</code></li> </ul> </li> <li> <p><code>__init__.py</code>:</p> <ul> <li>Description: Makes the <code>app</code> directory a Python package and initializes the Flask application. It bootstraps the application environment.</li> <li>Functionality:<ul> <li>Creates the Flask application instance (<code>app = Flask(__name__)</code>).</li> <li>Loads configuration from <code>config.py</code>.</li> <li>Initializes Flask extensions using <code>db.init_app(app)</code> and <code>mail.init_app(app)</code>.</li> <li>Configures Flask-Login (<code>login_manager</code>).</li> <li>Registers blueprints for views.</li> <li>Implements Content Security Policy (CSP) for enhanced security.</li> <li>Uses <code>ProxyFix</code> middleware for proper proxy handling.</li> </ul> </li> <li>Dependencies: <code>flask</code>, <code>flask_login</code>, <code>werkzeug</code>, <code>os</code>, <code>base64</code>, <code>.config</code>, <code>.extensions</code>, <code>.views</code></li> </ul> </li> <li> <p><code>models.py</code>:</p> <ul> <li>Description: Defines the data models (database tables) used by the application.</li> <li>Functionality:<ul> <li>Defines classes that inherit from <code>db.Model</code> to represent tables in the database.</li> <li>Models include <code>User</code>, <code>Subscription</code>, <code>Payment</code>, <code>LoginDetail</code>, and <code>Access</code>.</li> <li>Manages relationships between models (e.g., user-subscription, user-payments).</li> </ul> </li> <li>Dependencies: <code>flask_sqlalchemy</code>, <code>flask_login</code>, <code>datetime</code></li> </ul> </li> </ul>"},{"location":"02_scanners/","title":"Directory: <code>app/scanners</code>","text":"<p>Purpose: This directory contains the code for integrating with different vulnerability scanning tools. Each file in this directory represents a scanner integration. The scanners are designed to be modular and easily extensible. They provide functions to run the scans and return reports (usually PDFs).</p> <p>Files:</p> <ul> <li> <p><code>nmap_scanner.py</code>:</p> <ul> <li>Description: Integrates with the Nmap port scanner to perform network reconnaissance and identify open ports and services. Generates reports in PDF format.</li> <li>Key Functionality: Executes Nmap with various scan types, parses the output, and generates a PDF report with a custom header/logo.</li> <li>Dependencies: <code>subprocess</code>, <code>os</code>, <code>reportlab</code>, <code>flask</code></li> </ul> </li> <li> <p><code>nikto_scanner.py</code>:</p> <ul> <li>Description: Integrates with the Nikto web server scanner to identify potential vulnerabilities in web servers. Generates reports in PDF format.</li> <li>Key Functionality: Executes Nikto, removes scan summary from HTML output, and converts to PDF with a custom header/logo. Supports authenticated scans.</li> <li>Dependencies: <code>os</code>, <code>subprocess</code>, <code>pdfkit</code>, <code>bs4</code>, <code>fitz</code>, <code>flask</code></li> </ul> </li> <li> <p><code>zap_scanner.py</code>:</p> <ul> <li>Description: Integrates with the OWASP ZAP proxy to perform dynamic application security testing (DAST) and generate reports in PDF format.</li> <li>Key Functionality: Starts ZAP, configures it, runs a scan against a target URL (supports authenticated scans), and retrieves the report, converting it to PDF with a custom header/logo.</li> <li>Dependencies: <code>os</code>, <code>subprocess</code>, <code>datetime</code>, <code>pdfkit</code>, <code>tempfile</code>, <code>time</code>, <code>fitz</code>, <code>flask</code></li> </ul> </li> <li> <p><code>mobsf_scanner.py</code>:</p> <ul> <li>Description: Integrates with the Mobile Security Framework (MoBSF) to analyze mobile application binaries (APKs and IPAs) and generate reports.</li> <li>Key Functionality: Uploads app binaries to the MobSF API, initiates scans, and fetches the PDF report, adding a custom logo/header.</li> <li>Dependencies: <code>requests</code>, <code>os</code>, <code>fitz</code>, <code>flask</code></li> </ul> </li> <li> <p><code>sqlmap_scanner.py</code>:</p> <ul> <li>Description: Integrates with the sqlmap SQL injection tool to identify and exploit SQL injection vulnerabilities, generating reports in PDF format.</li> <li>Key Functionality: Executes sqlmap against a target URL, and generates a PDF report with a custom header/logo.</li> <li>Dependencies: <code>subprocess</code>, <code>os</code>, <code>glob</code>, <code>reportlab</code>, <code>flask</code></li> </ul> </li> <li> <p><code>ssl_scanner.py</code>:</p> <ul> <li>Description: Performs SSL/TLS security checks on a target host, generating reports in PDF format.</li> <li>Key Functionality: Executes <code>sslscan</code> and generates a PDF report with a custom header/logo.</li> <li>Dependencies: <code>subprocess</code>, <code>os</code>, <code>reportlab</code>, <code>flask</code></li> </ul> </li> <li> <p><code>cloudsploit_scanner_azure.py</code>:</p> <ul> <li>Description: Integrates with CloudSploit to perform security audits on Azure cloud environments, generating reports in PDF format.</li> <li>Key Functionality: Executes CloudSploit scans, converts CSV output to HTML, then to PDF, and adds a logo. Manages Azure credentials using a temporary file.</li> <li>Dependencies: <code>subprocess</code>, <code>os</code>, <code>csv</code>, <code>json</code>, <code>pdfkit</code>, <code>fitz</code>, <code>flask</code></li> </ul> </li> <li> <p><code>prowler_scanner_gcp.py</code>:</p> <ul> <li>Description: Integrates with Prowler to perform security assessments in GCP environments, generating reports in PDF format.</li> <li>Key Functionality: Executes Prowler using a service account key file, processes the HTML output to remove sensitive info, and converts it to PDF with a custom header/logo.</li> <li>Dependencies: <code>subprocess</code>, <code>os</code>, <code>tempfile</code>, <code>json</code>, <code>bs4</code>, <code>pdfkit</code>, <code>fitz</code>, <code>flask</code></li> </ul> </li> <li> <p><code>prowler_scanner_aws.py</code>:</p> <ul> <li>Description: Integrates with Prowler to perform security assessments in AWS environments, generating reports in PDF format.</li> <li>Key Functionality: Executes Prowler with provided AWS credentials, processes the HTML output to remove sensitive info, and converts it to PDF with a custom header/logo.</li> <li>Dependencies: <code>subprocess</code>, <code>os</code>, <code>bs4</code>, <code>pdfkit</code>, <code>fitz</code>, <code>flask</code></li> </ul> </li> <li> <p><code>__init__.py</code>:</p> <ul> <li>Description: Makes the <code>scanners</code> directory a Python package.</li> <li>Key Functionality: (Currently empty - likely would contain import statements to make the scanner modules easily accessible.)</li> <li>Dependencies: None</li> </ul> </li> </ul>"},{"location":"03_nmap_scanner/","title":"Nmap Scanner","text":"<p>This document details the functionality of the file <code>nmap_scanner.py</code>, which automates network scanning using Nmap. The script provides several functions to execute different types of Nmap scans, generate PDF reports from the scan results, and incorporates user identification within the reports.</p>"},{"location":"03_nmap_scanner/#overview","title":"Overview","text":"<p>The script performs the following steps:</p> <ol> <li>Defines Scan Types: Provides functions for various Nmap scan types, such as port scans, TCP SYN scans, aggressive scans, OS detection, and fragmented packet scans.</li> <li>Executes Nmap:  Runs the Nmap command with specified options and target.</li> <li>Generates PDF Report: Creates a formatted PDF report using <code>reportlab</code>, including the scan type, target, scan results, and a company logo. The reports are user-specific.</li> <li>Returns Report Filename:  Returns the filename of the generated PDF report.</li> </ol>"},{"location":"03_nmap_scanner/#functions","title":"Functions","text":""},{"location":"03_nmap_scanner/#1-get_report_directoryscan_type","title":"1. <code>get_report_directory(scan_type)</code>","text":"<ul> <li> <p>Purpose: Determines and creates the directory where Nmap reports will be stored based on the scan type.</p> </li> <li> <p>Functionality:</p> <ul> <li>Defines the base directory path as <code>reports/nmap</code> within the Flask application's root directory.</li> <li>Creates a sub-directory based on the scan type.  The scan type is converted to lowercase and spaces are replaced with underscores (e.g., \"Port Scan\" becomes <code>port_scan</code>).</li> <li>Uses <code>os.makedirs(specific_report_dir, exist_ok=True)</code> to create the directory if it doesn't exist. <code>exist_ok=True</code> prevents errors if the directory already exists.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_report_directory(scan_type):\n    \"\"\"Returns the specific directory for scan reports based on the scan type.\"\"\"\n    report_dir_base = os.path.join(current_app.root_path, 'reports', 'nmap')\n    specific_report_dir = os.path.join(report_dir_base, f'{scan_type.lower().replace(\" \", \"_\")}_results')\n    os.makedirs(specific_report_dir, exist_ok=True)\n    return specific_report_dir\n</code></pre> </li> </ul>"},{"location":"03_nmap_scanner/#2-run_nmapcommand_list","title":"2. <code>run_nmap(command_list)</code>","text":"<ul> <li> <p>Purpose:  A helper function to execute Nmap commands using <code>subprocess</code>.</p> </li> <li> <p>Functionality:</p> <ul> <li>Takes a list of strings representing the Nmap command and its arguments.</li> <li>Executes the command using <code>subprocess.run</code> with <code>capture_output=True</code>, <code>text=True</code>, and <code>check=True</code>. <code>check=True</code> raises a <code>CalledProcessError</code> if the Nmap command returns a non-zero exit code (indicating an error).</li> <li>Returns the standard output of the Nmap command.</li> <li>Includes error handling for <code>CalledProcessError</code> and <code>FileNotFoundError</code>. If Nmap is not found, a specific error message is returned.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import subprocess\n\ndef run_nmap(command_list):\n    \"\"\"Helper function to execute Nmap commands.\"\"\"\n    try:\n        result = subprocess.run(command_list, capture_output=True, text=True, check=True)\n        return result.stdout\n    except subprocess.CalledProcessError as e:\n        return f\"Error running Nmap: {e}\\n{e.stderr}\"\n    except FileNotFoundError:\n        return \"Error: Nmap not found. Please ensure Nmap is installed and in your system's PATH.\"\n</code></pre> </li> </ul>"},{"location":"03_nmap_scanner/#3-generate_nmap_report_pdfscan_type-target-report_text-optionsnone","title":"3. <code>generate_nmap_report_pdf(scan_type, target, report_text, options=None)</code>","text":"<ul> <li> <p>Purpose: Generates a PDF report from the Nmap scan results using the <code>reportlab</code> library.</p> </li> <li> <p>Functionality:</p> <ul> <li>Generates a unique filename for the PDF report based on the user ID, scan type, and timestamp.</li> <li>Initializes a <code>SimpleDocTemplate</code> for creating the PDF.</li> <li>Defines custom styles for the title, body text, and other elements of the report using <code>ParagraphStyle</code> and <code>getSampleStyleSheet</code>. A modern font (<code>Helvetica</code>) is used.</li> <li>Creates a <code>story</code> list to hold the content of the PDF.</li> <li>Adds a company logo at the beginning and the end. It checks to ensure logo exists before attempting to add it.</li> <li>Adds a title to the report.</li> <li>Includes a report information table containing the scan initiator (username), timestamp, and target.</li> <li>Formats the Nmap output, splitting it into lines and adding each line as a paragraph to the story.</li> <li>Builds the PDF document using <code>doc.build(story)</code>.</li> <li>Returns the filename of the generated PDF report.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\nfrom flask_login import current_user\nfrom datetime import datetime\nfrom reportlab.pdfgen import canvas\nfrom reportlab.lib.pagesizes import letter\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image\nfrom reportlab.lib.units import inch\nfrom reportlab.lib.enums import TA_CENTER, TA_LEFT\n\nAPP_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nCOMPANY_LOGO = os.path.join(APP_ROOT, 'static', 'images', 'company_logo.PNG')  # Replace with the actual filename\n\ndef generate_nmap_report_pdf(scan_type, target, report_text, options=None):\n    \"\"\"Generates an improved PDF report from Nmap output with logo at the end, using username.\"\"\"\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    report_dir = get_report_directory(scan_type)\n    pdf_filename = os.path.join(report_dir, f\"{current_user.id}_nmap_{scan_type.lower().replace(' ', '_')}_{timestamp}.pdf\")\n\n    doc = SimpleDocTemplate(pdf_filename, pagesize=letter)\n    styles = getSampleStyleSheet()\n\n    # Modern font style\n    modern_style = ParagraphStyle(\n        name='Modern',\n        parent=styles['Normal'],\n        fontName='Helvetica',  # You can change to a more specific modern font if available\n        fontSize=14,\n        leading=16,\n        alignment=TA_LEFT,\n    )\n\n    title_style = ParagraphStyle(\n        name='Title',\n        parent=modern_style,\n        fontSize=18,\n        leading=22,\n        alignment=TA_CENTER,\n        fontName='Helvetica-Bold',\n    )\n\n    story = []\n\n    # --- Header ---\n    if os.path.exists(COMPANY_LOGO):\n        logo_header = Image(COMPANY_LOGO, width=1 * inch, height=1 * inch)\n        story.append(logo_header)\n        print(\"logo added in header\")\n    story.append(Spacer(1, 0.2 * inch))\n\n    # --- Title ---\n    title_text = f\"Nmap {scan_type.replace('_', ' ').title()} Report\"\n    story.append(Paragraph(title_text, title_style))\n    story.append(Spacer(1, 0.3 * inch))\n\n    # --- Report Information ---\n    report_info_data = [\n        [\"Scan Initiated By:\", f\"{current_user.username if current_user.is_authenticated else 'N/A'}\"],\n        [\"Timestamp:\", datetime.now().strftime('%Y-%m-%d %H:%M:%S')],\n        [\"Target:\", target],\n    ]\n    from reportlab.platypus import Table, TableStyle\n    report_info_table = Table(report_info_data, colWidths=[2 * inch, 5 * inch])\n    report_info_table.setStyle(TableStyle([\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTSIZE', (0, 0), (-1, -1), 12),\n        ('BOTTOMPADDING', (0, 0), (-1, 0), 6),\n    ]))\n    story.append(report_info_table)\n    story.append(Spacer(1, 0.3 * inch))\n\n    # --- Report Content ---\n    report_lines = report_text.splitlines()\n    for line in report_lines:\n        p = Paragraph(line, modern_style)\n        story.append(p)\n        story.append(Spacer(1, 0.1 * inch)) # Add a little space between lines\n\n    story.append(Spacer(1, 0.5 * inch))\n\n    # --- Logo at the End ---\n    if os.path.exists(COMPANY_LOGO):\n        logo_footer = Image(COMPANY_LOGO, width=1 * inch, height=1 * inch, hAlign='CENTER')\n        story.append(logo_footer)\n\n    doc.build(story)\n    return pdf_filename\n</code></pre> </li> </ul>"},{"location":"03_nmap_scanner/#4-run_port_scantarget-optionsnone-user_idnone","title":"4. <code>run_port_scan(target, options=None, user_id=None)</code>","text":"<ul> <li> <p>Purpose:  Executes a basic Nmap port scan.</p> </li> <li> <p>Functionality:</p> <ul> <li>Constructs the Nmap command with the specified target and any additional options.</li> <li>Calls <code>run_nmap()</code> to execute the command.</li> <li>If the Nmap command is successful (no \"Error\" in the output), calls <code>generate_nmap_report_pdf()</code> to create the PDF report.</li> <li>Returns the filename of the PDF report if successful; otherwise, returns <code>None</code>.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>def run_port_scan(target, options=None, user_id=None):\n    command = ['nmap']\n    if options:\n        command.extend(options.split())\n    command.append(target)\n    report = run_nmap(command)\n    if \"Error\" not in report:\n        return generate_nmap_report_pdf(\"Port Scan\", target, report, options)\n    return None\n</code></pre> </li> </ul>"},{"location":"03_nmap_scanner/#5-run_tcp_syn_scantarget-portsnone-optionsnone-user_idnone","title":"5. <code>run_tcp_syn_scan(target, ports=None, options=None, user_id=None)</code>","text":"<ul> <li> <p>Purpose: Executes an Nmap TCP SYN scan (<code>-sS</code>).</p> </li> <li> <p>Functionality:</p> <ul> <li>Constructs the Nmap command with the <code>-sS</code> flag, specified ports (if any), and any additional options.</li> <li>Calls <code>run_nmap()</code> to execute the command.</li> <li>If the Nmap command is successful (no \"Error\" in the output), calls <code>generate_nmap_report_pdf()</code> to create the PDF report.</li> <li>Returns the filename of the PDF report if successful; otherwise, returns <code>None</code>.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>def run_tcp_syn_scan(target, ports=None, options=None, user_id=None):\n    command = ['nmap', '-sS']\n    if ports:\n        command.extend(['-p', ports])\n    if options:\n        command.extend(options.split())\n    command.append(target)\n    report = run_nmap(command)\n    if \"Error\" not in report:\n        return generate_nmap_report_pdf(\"TCP SYN Scan\", target, report, f\"-sS {'-p ' + ports if ports else ''} {' '.join(options.split()) if options else ''}\")\n    return None\n</code></pre> </li> </ul>"},{"location":"03_nmap_scanner/#6-run_aggressive_scantarget-optionsnone-user_idnone","title":"6. <code>run_aggressive_scan(target, options=None, user_id=None)</code>","text":"<ul> <li> <p>Purpose: Executes an Nmap aggressive scan (<code>-A</code>).</p> </li> <li> <p>Functionality:</p> <ul> <li>Constructs the Nmap command with the <code>-A</code> flag and any additional options.</li> <li>Calls <code>run_nmap()</code> to execute the command.</li> <li>If the Nmap command is successful (no \"Error\" in the output), calls <code>generate_nmap_report_pdf()</code> to create the PDF report.</li> <li>Returns the filename of the PDF report if successful; otherwise, returns <code>None</code>.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>def run_aggressive_scan(target, options=None, user_id=None):\n    command = ['nmap', '-A']\n    if options:\n        command.extend(options.split())\n    command.append(target)\n    report = run_nmap(command)\n    if \"Error\" not in report:\n        return generate_nmap_report_pdf(\"Aggressive Scan\", target, report, f\"-A {' '.join(options.split()) if options else ''}\")\n    return None\n</code></pre> </li> </ul>"},{"location":"03_nmap_scanner/#7-run_os_detectiontarget-optionsnone-user_idnone","title":"7. <code>run_os_detection(target, options=None, user_id=None)</code>","text":"<ul> <li> <p>Purpose: Executes an Nmap OS detection scan (<code>-O</code>).</p> </li> <li> <p>Functionality:</p> <ul> <li>Constructs the Nmap command with the <code>-O</code> flag and any additional options.</li> <li>Calls <code>run_nmap()</code> to execute the command.</li> <li>If the Nmap command is successful (no \"Error\" in the output), calls <code>generate_nmap_report_pdf()</code> to create the PDF report.</li> <li>Returns the filename of the PDF report if successful; otherwise, returns <code>None</code>.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>def run_os_detection(target, options=None, user_id=None):\n    command = ['nmap', '-O']\n    if options:\n        command.extend(options.split())\n    command.append(target)\n    report = run_nmap(command)\n    if \"Error\" not in report:\n        return generate_nmap_report_pdf(\"OS Detection\", target, report, f\"-O {' '.join(options.split()) if options else ''}\")\n    return None\n</code></pre> </li> </ul>"},{"location":"03_nmap_scanner/#8-run_fragmented_packet_scantarget-optionsnone-user_idnone","title":"8. <code>run_fragmented_packet_scan(target, options=None, user_id=None)</code>","text":"<ul> <li> <p>Purpose: Executes an Nmap fragmented packet scan (<code>-f</code>).</p> </li> <li> <p>Functionality:</p> <ul> <li>Constructs the Nmap command with the <code>-f</code> flag (fragmentation) and <code>-T5</code> (aggressively fast timing template) and any additional options.</li> <li>Calls <code>run_nmap()</code> to execute the command.</li> <li>If the Nmap command is successful (no \"Error\" in the output), calls <code>generate_nmap_report_pdf()</code> to create the PDF report.</li> <li>Returns the filename of the PDF report if successful; otherwise, returns <code>None</code>.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>def run_fragmented_packet_scan(target, options=None, user_id=None):\n    command = ['nmap', '-f', '-T5']\n    if options:\n        command.extend(options.split())\n    command.append(target)\n    report = run_nmap(command)\n    if \"Error\" not in report:\n        return generate_nmap_report_pdf(\"Fragmented Packet Scan\", target, report, f\"-f {' '.join(options.split()) if options else ''}\")\n    return None\n</code></pre> </li> </ul>"},{"location":"03_nmap_scanner/#dependencies","title":"Dependencies","text":"<ul> <li>Nmap:  A network scanning tool. Must be installed and in the system's PATH.</li> <li>Python Libraries:<ul> <li><code>subprocess</code>: For running external commands (Nmap).</li> <li><code>os</code>: For file system operations.</li> <li><code>flask</code>: For accessing the application's root path and configuration.</li> <li><code>flask_login</code>: For accessing the current user's information.</li> <li><code>datetime</code>: For generating unique report filenames.</li> <li><code>reportlab</code>: For generating PDF reports (<code>pip install reportlab</code>).</li> </ul> </li> </ul>"},{"location":"03_nmap_scanner/#configuration","title":"Configuration","text":"<ul> <li><code>APP_ROOT</code>:  Dynamically determines the application's root directory using <code>os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</code>.</li> <li><code>COMPANY_LOGO</code>: Defines the path to the company logo image. Ensure the path is correct, and the logo image exists at the specified location. The logo path is relative to <code>APP_ROOT</code>.</li> </ul>"},{"location":"03_nmap_scanner/#error-handling","title":"Error Handling","text":"<p>The script includes error handling in the following areas:</p> <ul> <li>Nmap Execution:  Handles <code>subprocess.CalledProcessError</code> if the Nmap command fails and <code>FileNotFoundError</code> if Nmap is not found.</li> <li>Report Generation: The Nmap report generation will not proceed if the nmap scan return any error.</li> <li>The pdf reports are generated and saved correctly by creating relevant directory.</li> </ul>"},{"location":"03_nmap_scanner/#security-considerations","title":"Security Considerations","text":"<ul> <li>Nmap Execution:  Nmap scans can be intrusive and may be detected by intrusion detection systems (IDS).  Ensure you have permission to scan the target.</li> <li>Input Validation:  The target and options passed to Nmap should be validated to prevent command injection vulnerabilities.  While the provided code doesn't explicitly show validation, it's a critical security practice. Avoid directly incorporating untrusted input into the Nmap command string.</li> <li>Information Disclosure: Nmap scans can reveal sensitive information about the target system. Handle the scan results and reports securely. Limit access to the generated reports to authorized personnel.</li> </ul>"},{"location":"04_nikto_scanner/","title":"Nikto Scanner","text":"<p>This document details the functionality of the file <code>nikto_scanner.py</code>, which automates web vulnerability scanning using Nikto. The script provides functions to execute both unauthenticated and authenticated Nikto scans, process the generated HTML reports, convert them to PDF format, and include a company logo within the reports.</p>"},{"location":"04_nikto_scanner/#overview","title":"Overview","text":"<p>The script performs the following steps:</p> <ol> <li>Defines Report Directories: Establishes directories for storing both unauthenticated and authenticated Nikto reports.</li> <li>Executes Nikto Scans: Runs Nikto scans against specified target URLs, with options for providing authentication credentials.</li> <li>Processes HTML Report: Removes the \"Scan Summary\" section from the generated HTML report for cleaner output.</li> <li>Converts to PDF: Converts the processed HTML report to a PDF format, adding a company logo and title page using <code>pdfkit</code> and <code>PyMuPDF</code>.</li> <li>Returns Report Filename: Returns the filename of the generated PDF report.</li> </ol>"},{"location":"04_nikto_scanner/#functions","title":"Functions","text":""},{"location":"04_nikto_scanner/#1-get_nikto_report_base_directory","title":"1. <code>get_nikto_report_base_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the base directory where all Nikto reports will be stored.</p> </li> <li> <p>Functionality:</p> <ul> <li>Defines the base directory path as <code>reports/nikto</code> within the Flask application's root directory.</li> <li>Uses <code>os.makedirs(report_dir_base, exist_ok=True)</code> to create the directory if it doesn't exist. <code>exist_ok=True</code> prevents errors if the directory already exists.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_nikto_report_base_directory():\n    report_dir_base = os.path.join(current_app.root_path, 'reports', 'nikto')\n    os.makedirs(report_dir_base, exist_ok=True)\n    return report_dir_base\n</code></pre> </li> </ul>"},{"location":"04_nikto_scanner/#2-get_nikto_results_directory","title":"2. <code>get_nikto_results_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the directory for storing unauthenticated Nikto scan results.</p> </li> <li> <p>Functionality:</p> <ul> <li>Creates a sub-directory named <code>nikto_results</code> within the base Nikto report directory.</li> <li>Uses <code>os.makedirs()</code> to ensure the directory exists.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_nikto_results_directory():\n    results_dir = os.path.join(get_nikto_report_base_directory(), 'nikto_results')\n    os.makedirs(results_dir, exist_ok=True)\n    return results_dir\n</code></pre> </li> </ul>"},{"location":"04_nikto_scanner/#3-get_authenticated_nikto_results_directory","title":"3. <code>get_authenticated_nikto_results_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the directory for storing authenticated Nikto scan results.</p> </li> <li> <p>Functionality:</p> <ul> <li>Creates a sub-directory named <code>authenticated_nikto_results</code> within the base Nikto report directory.</li> <li>Uses <code>os.makedirs()</code> to ensure the directory exists.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_authenticated_nikto_results_directory():\n    results_dir = os.path.join(get_nikto_report_base_directory(), 'authenticated_nikto_results')\n    os.makedirs(results_dir, exist_ok=True)\n    return results_dir\n</code></pre> </li> </ul>"},{"location":"04_nikto_scanner/#4-remove_nikto_summaryhtml_content","title":"4. <code>remove_nikto_summary(html_content)</code>","text":"<ul> <li> <p>Purpose: Removes the \"Scan Summary\" section from the Nikto HTML report.</p> </li> <li> <p>Functionality:</p> <ul> <li>Parses the HTML content using <code>BeautifulSoup</code>.</li> <li>Finds the <code>table</code> elements with the class <code>headerTable</code> that contains the text \"Scan Summary\" in its <code>td</code> element.</li> <li>Finds the <code>table</code> element with the class <code>dataTable</code> that contains the summary data and that succeeds the header table.</li> <li>Removes both the \"Scan Summary\" header table and the corresponding data table from the HTML.</li> <li>Returns the modified HTML content as a string.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>from bs4 import BeautifulSoup\n\ndef remove_nikto_summary(html_content):\n    \"\"\"Removes the Nikto scan summary section from the HTML.\"\"\"\n    soup = BeautifulSoup(html_content, 'html.parser')\n\n    # Find all tables with class 'headerTable'\n    header_tables = soup.find_all('table', {'class': 'headerTable'})\n\n    # Iterate on them until we find the match for the scan Summary, then break from loop\n    scan_summary_header_table = None\n    for header_table in header_tables:\n        header_text = header_table.find('td')  # Find the &lt;td&gt; element\n        if header_text and header_text.text.strip() == \"Scan Summary\":\n            scan_summary_header_table = header_table  # Assign the match!\n            break  # stop here, don't continue to iterate over the tables\n\n    if scan_summary_header_table:\n        # Find the data table that succeeds it\n        scan_summary_data_table = scan_summary_header_table.find_next('table', {'class': 'dataTable'})\n\n        # Remove the Tag\n        scan_summary_header_table.decompose()  # remove header table\n\n        if scan_summary_data_table:  # check data table to see if anything inside before removign the table\n            scan_summary_data_table.decompose()  # Remove the summary table\n\n    return str(soup)  # Return the modified HTML as a string\n</code></pre> </li> </ul>"},{"location":"04_nikto_scanner/#5-convert_html_to_pdfhtml_content-pdf_path-logo_path-report_typenikto-scan-report","title":"5. <code>convert_html_to_pdf(html_content, pdf_path, logo_path, report_type=\"Nikto Scan Report\")</code>","text":"<ul> <li> <p>Purpose: Converts HTML content to PDF, adds a company logo and title using <code>pdfkit</code> for the initial conversion and <code>PyMuPDF</code> for post-processing.</p> </li> <li> <p>Functionality:</p> <ul> <li>HTML to PDF Conversion (pdfkit):<ul> <li>Uses <code>pdfkit.from_string()</code> to convert the HTML content to a PDF file at <code>pdf_path</code>.</li> <li>Configures <code>pdfkit</code> with <code>wkhtmltopdf</code> executable path (obtained from <code>current_app.config</code> or defaults to <code>/usr/local/bin/wkhtmltopdf</code>).</li> <li>Sets PDF options like page size, margins, and encoding.</li> </ul> </li> <li>Post-Processing (PyMuPDF):<ul> <li>Opens the generated PDF using <code>fitz.open()</code>.</li> <li>Loads the company logo from <code>logo_path</code> using <code>fitz.Pixmap()</code>. The <code>logo_path</code> is joined with <code>current_app.root_path</code> to create an absolute path.</li> <li>If the logo file exists, it calculates the logo's dimensions and position to center it on the first and last page.</li> <li>Adds a new blank page at the beginning and the end of the PDF.</li> <li>Inserts the logo and the report title onto the added first and last page.</li> <li>Saves the modified PDF with incremental updates (<code>pdf_doc.saveIncr()</code>). This preserves the original PDF content while adding the new elements.</li> </ul> </li> <li>Error Handling: Uses <code>try...except</code> blocks to catch exceptions related to both <code>pdfkit</code> and <code>PyMuPDF</code> processes, ensuring proper error handling and reporting.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import fitz\nimport pdfkit\nimport os\nfrom flask import current_app\n\ndef convert_html_to_pdf(html_content, pdf_path, logo_path, report_type=\"Nikto Scan Report\"):  # Added report_type argument\n    \"\"\"Convert HTML content to PDF using pdfkit, then add logo with PyMuPDF.\"\"\"\n    try:\n        config = pdfkit.configuration(wkhtmltopdf=current_app.config.get('WKHTMLTOPDF_EXECUTABLE',\n                                                                           '/usr/local/bin/wkhtmltopdf'))  # Get WKHTMLTOPDF path from config\n        options = {\n            'page-size': 'A4',\n            'margin-top': '10mm',\n            'margin-right': '10mm',\n            'margin-bottom': '10mm',\n            'margin-left': '10mm',\n            'encoding': \"UTF-8\",  # Crucial for special characters!\n        }\n        pdfkit.from_string(html_content, pdf_path, configuration=config,\n                           options=options)  # Convert from string\n        print(f\"Successfully created PDF: {pdf_path}\")\n\n        # Add logo using PyMuPDF\n        try:\n            pdf_doc = fitz.open(pdf_path)\n            logo_path = os.path.join(current_app.root_path, logo_path)  # Absolute Path from Relative Path\n            if os.path.exists(logo_path):\n                logo = fitz.Pixmap(logo_path)\n                logo_width_pt = 200  # Adjust as needed\n                aspect_ratio = logo.width / logo.height\n                logo_height_pt = logo_width_pt / aspect_ratio\n\n                # Create a new page as the first page\n                new_page = pdf_doc.new_page(width=pdf_doc[0].rect.width, height=pdf_doc[0].rect.height,\n                                             pno=0)  # Insert as the *first* page\n                page_width = new_page.rect.width\n                page_height = new_page.rect.height\n\n                # Calculate total height of logo and title with gap\n                title_text = report_type  # Use the dynamic report type\n                font_size = 24\n                text_height = font_size  # Approximate text height\n\n                total_height = logo_height_pt + 30 + text_height  # Logo + gap + title\n\n                # Calculate starting Y position for vertical centering\n                start_y = (page_height - total_height) / 2\n\n                # Calculate logo position (centered horizontally, vertically aligned)\n                logo_x = (page_width - logo_width_pt) / 2\n                logo_y = start_y  # Distance from the top\n\n                logo_rect = fitz.Rect(logo_x, logo_y, logo_x + logo_width_pt, logo_y + logo_height_pt)\n                new_page.insert_image(logo_rect, pixmap=logo)\n\n                # Add a title (optional)\n\n                text_width = fitz.get_text_length(title_text, fontname=\"helvetica-bold\",\n                                                   fontsize=font_size)  # Use the get_text_length for exact positioning\n                text_x = (page_width - text_width) / 2\n                text_y = logo_y + logo_height_pt + 30  # Below the logo\n                new_page.insert_text((text_x, text_y), title_text, fontname=\"helvetica-bold\", fontsize=font_size,\n                                      color=(0, 0, 0))  # Black text\n\n                # Add the same page to the end of the document\n                last_page = pdf_doc.new_page(width=pdf_doc[0].rect.width, height=pdf_doc[0].rect.height)  # Create new page with the same height and width with original file\n                logo_x = (page_width - logo_width_pt) / 2\n                logo_y = start_y  # Distance from the top\n\n                logo_rect = fitz.Rect(logo_x, logo_y, logo_x + logo_width_pt, logo_y + logo_height_pt)\n                last_page.insert_image(logo_rect, pixmap=logo)  # insert the logo to the last page\n\n                text_x = (page_width - text_width) / 2\n                text_y = logo_y + logo_height_pt + 30  # Below the logo\n                last_page.insert_text((text_x, text_y), title_text, fontname=\"helvetica-bold\", fontsize=font_size,\n                                      color=(0, 0, 0))  # Black text #insert the text to the last page\n\n                pdf_doc.saveIncr()\n                print(f\"Successfully added new page and logo to PDF: {pdf_path}\")\n            else:\n                print(f\"Warning: Logo not found at {logo_path}\")\n\n        except Exception as e:\n            print(f\"Error adding new page and logo to PDF: {str(e)}\")\n            return None\n\n        return os.path.basename(pdf_path)\n\n    except Exception as e:\n        print(f\"Error converting HTML to PDF: {str(e)}\")\n        return None\n</code></pre> </li> </ul>"},{"location":"04_nikto_scanner/#6-run_nikto_scantarget_url-user_idnone","title":"6. <code>run_nikto_scan(target_url, user_id=None)</code>","text":"<ul> <li> <p>Purpose: Executes an unauthenticated Nikto scan against a specified target URL.</p> </li> <li> <p>Functionality:</p> <ul> <li>Defines the path to the Nikto executable.</li> <li>Constructs the Nikto command with the target URL and output options.</li> <li>Executes the Nikto command using <code>subprocess.Popen</code>.</li> <li>Captures the standard output and standard error streams.</li> <li>If the scan is successful (HTML report is generated), it reads the HTML content, removes the Nikto summary, and converts the modified HTML to a PDF report using <code>convert_html_to_pdf()</code>.</li> <li>If PDF conversion is successful, the original HTML file is removed.</li> <li>Returns the filename of the generated PDF report, or an error message if the scan or conversion fails.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nimport subprocess\nfrom datetime import datetime\nfrom flask import current_app\nfrom bs4 import BeautifulSoup  # Import BeautifulSoup\nimport pdfkit\nimport fitz\n\ndef run_nikto_scan(target_url, user_id=None):\n    NIKTO_EXECUTABLE = current_app.config.get('NIKTO_EXECUTABLE', '/usr/bin/nikto')  # Adjust path as needed\n    COMPANY_LOGO_PATH = 'static/images/company_logo.PNG'  # Change to your actual logo path - RELATIVE URL\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    results_dir = get_nikto_results_directory()\n    html_report_filename = os.path.join(results_dir, f\"{user_id}_nikto_{timestamp}.html\")\n    pdf_report_filename = os.path.join(results_dir, f\"{user_id}_nikto_{timestamp}.pdf\")\n\n    command = [\n        NIKTO_EXECUTABLE,\n        '-h', target_url,\n        '-output', html_report_filename,\n        '-Format', 'html',\n        '-timeout', '5',\n        '-maxtime', '60',\n        '-Tuning', '123bde'\n    ]\n\n    try:\n        print(f\"Running Nikto command: {' '.join(command)}\")\n        process = subprocess.Popen(command, shell=False, stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)  # Using subprocess.PIPE\n        stdout, stderr = process.communicate()\n        stdout_str = stdout.decode('utf-8')  # Decode bytes to string\n        stderr_str = stderr.decode('utf-8')\n\n        print(f\"Nikto Output:\\n{stdout_str}\")\n        if stderr_str:\n            print(f\"Nikto Errors:\\n{stderr_str}\")\n\n        if os.path.exists(html_report_filename):\n            with open(html_report_filename, 'r', encoding='utf-8') as f:\n                html_content = f.read()\n\n            modified_html_content = remove_nikto_summary(html_content)\n\n            pdf_filename = convert_html_to_pdf(modified_html_content, pdf_report_filename, COMPANY_LOGO_PATH,\n                                               report_type=\"Nikto Scan Report\")\n\n            if pdf_filename:\n                os.remove(html_report_filename)\n                return pdf_filename\n            else:\n                return \"Error: Failed to convert Nikto HTML report to PDF.\"\n    else:\n        return f\"Error: Nikto scan failed with return code {process.returncode}. See output for details.\"\n\n    except FileNotFoundError:\n        return f\"Error: Nikto executable not found at {NIKTO_EXECUTABLE}. Please check your configuration.\"\n    except subprocess.TimeoutExpired:\n        return \"Error: Nikto scan timed out.\"\n    except Exception as e:\n        return f\"Error: An unexpected error occurred during Nikto scan: {e}\"\n</code></pre> </li> </ul>"},{"location":"04_nikto_scanner/#7-run_nikto_authenticated_scantarget_url-username-password-user_idnone","title":"7. <code>run_nikto_authenticated_scan(target_url, username, password, user_id=None)</code>","text":"<ul> <li> <p>Purpose: Executes an authenticated Nikto scan against a specified target URL.</p> </li> <li> <p>Functionality:</p> <ul> <li>Similar to <code>run_nikto_scan()</code>, but includes username and password for authentication.</li> <li>Uses the <code>-id</code> option to provide authentication credentials to Nikto.</li> <li>Stores the results in the <code>authenticated_nikto_results</code> directory.</li> <li>Returns the filename of the generated PDF report, or an error message if the scan or conversion fails.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nimport subprocess\nfrom datetime import datetime\nfrom flask import current_app\nfrom bs4 import BeautifulSoup  # Import BeautifulSoup\nimport pdfkit\nimport fitz\n\ndef run_nikto_authenticated_scan(target_url, username, password, user_id=None):\n    NIKTO_EXECUTABLE = current_app.config.get('NIKTO_EXECUTABLE', '/usr/bin/nikto')  # Adjust path as needed\n    COMPANY_LOGO_PATH = 'static/images/company_logo.PNG'  # Change to your actual logo path - RELATIVE URL\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    results_dir = get_authenticated_nikto_results_directory()\n    html_report_filename = os.path.join(results_dir, f\"{user_id}_nikto_auth_{timestamp}.html\")\n    pdf_report_filename = os.path.join(results_dir, f\"{user_id}_nikto_auth_{timestamp}.pdf\")\n\n    command = [\n        NIKTO_EXECUTABLE,\n        '-h', target_url,\n        '-output', html_report_filename,\n        '-Format', 'html',\n        '-id', f'{username}:{password}',  # Use -id with username:password\n        '-timeout', '5',\n        '-maxtime', '60',\n        '-Tuning', '123bde'\n    ]\n\n    try:\n        print(f\"Running authenticated Nikto command: {' '.join(command)}\")\n        process = subprocess.Popen(command, shell=False, stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)  # Using subprocess.PIPE\n        stdout, stderr = process.communicate()\n        stdout_str = stdout.decode('utf-8')  # Decode bytes to string\n        stderr_str = stderr.decode('utf-8')\n\n        print(f\"Nikto Output:\\n{stdout_str}\")\n        if stderr_str:\n            print(f\"Nikto Errors:\\n{stderr_str}\")\n\n        if os.path.exists(html_report_filename):\n            with open(html_report_filename, 'r', encoding='utf-8') as f:\n                html_content = f.read()\n\n            modified_html_content = remove_nikto_summary(html_content)\n\n            pdf_filename = convert_html_to_pdf(modified_html_content, pdf_report_filename, COMPANY_LOGO_PATH,\n                                               report_type=\"Authenticated Nikto Scan Report\")\n\n            if pdf_filename:\n                os.remove(html_report_filename)\n                return pdf_filename\n            else:\n                return \"Error: Failed to convert authenticated Nikto HTML report to PDF.\"\n    else:\n        return f\"Error: Authenticated Nikto scan failed with return code {process.returncode}. See output for details.\"\n\n    except FileNotFoundError:\n        return f\"Error: Nikto executable not found at {NIKTO_EXECUTABLE}. Please check your configuration.\"\n    except subprocess.TimeoutExpired:\n        return \"Error: Authenticated Nikto scan timed out.\"\n    except Exception as e:\n        return f\"Error: An unexpected error occurred during authenticated Nikto scan: {e}\"\n</code></pre> </li> </ul>"},{"location":"04_nikto_scanner/#dependencies","title":"Dependencies","text":"<ul> <li>Nikto: A web vulnerability scanner. Must be installed and in the system's PATH.</li> <li>Python Libraries:<ul> <li><code>subprocess</code>: For running external commands (Nikto).</li> <li><code>os</code>: For file system operations.</li> <li><code>datetime</code>: For generating unique report filenames.</li> <li><code>flask</code>: For accessing the application's root path and configuration.</li> <li><code>pdfkit</code>: For converting HTML to PDF (<code>pip install pdfkit</code>). Requires <code>wkhtmltopdf</code> to be installed.</li> <li><code>BeautifulSoup4</code>: For parsing and manipulating HTML content (<code>pip install beautifulsoup4</code>).</li> <li><code>PyMuPDF (fitz)</code>: For adding the company logo and title to the PDF (<code>pip install pymupdf</code>).</li> </ul> </li> <li>wkhtmltopdf: A command-line tool required by <code>pdfkit</code> to convert HTML to PDF. It needs to be installed separately. Follow the instructions at https://wkhtmltopdf.org/downloads.html for your operating system.</li> </ul>"},{"location":"04_nikto_scanner/#configuration","title":"Configuration","text":"<ul> <li><code>NIKTO_EXECUTABLE</code>: A configuration setting in the Flask application that specifies the path to the Nikto executable. If not set, it defaults to <code>/usr/bin/nikto</code>. This is accessed via <code>current_app.config.get('NIKTO_EXECUTABLE', '/usr/bin/nikto')</code>.</li> <li><code>WKHTMLTOPDF_EXECUTABLE</code>: A configuration setting in the Flask application that specifies the path to the <code>wkhtmltopdf</code> executable. If not set, it defaults to <code>/usr/local/bin/wkhtmltopdf</code>. This is accessed via <code>current_app.config.get('WKHTMLTOPDF_EXECUTABLE', '/usr/local/bin/wkhtmltopdf')</code>.</li> <li><code>COMPANY_LOGO_PATH</code>: Specifies the relative path to the company logo image within the Flask application's static files directory (e.g., <code>'static/images/company_logo.PNG'</code>).</li> </ul>"},{"location":"04_nikto_scanner/#error-handling","title":"Error Handling","text":"<p>The script includes error handling in the following areas:</p> <ul> <li>Nikto execution (handling <code>FileNotFoundError</code>, <code>subprocess.TimeoutExpired</code>, and general exceptions).</li> <li>HTML report processing.</li> <li>PDF conversion (both <code>pdfkit</code> and <code>PyMuPDF</code>).</li> <li>Missing dependencies (e.g., Nikto or <code>wkhtmltopdf</code> not installed).</li> </ul> <p>Errors are printed to the console and returned as error messages by the functions.</p>"},{"location":"04_nikto_scanner/#security-considerations","title":"Security Considerations","text":"<ul> <li>Authentication Credentials: The <code>run_nikto_authenticated_scan()</code> function handles sensitive authentication credentials. It's critical to:<ul> <li>Store the credentials securely before passing them to the script.</li> <li>Avoid logging the credentials in plaintext.</li> </ul> </li> <li>Input Validation: The target URL should be validated to prevent command injection vulnerabilities.</li> <li>Nikto Execution: Nikto scans can be intrusive and may be detected by intrusion detection systems (IDS). Ensure you have permission to scan the target.</li> </ul>"},{"location":"05_zap_scanner/","title":"ZAP Scanner","text":"<p>This document details the functionality of the file <code>zap_scanner.py</code>, which automates web application security scanning using OWASP ZAP (Zed Attack Proxy). The script provides functions to execute both unauthenticated and authenticated ZAP scans, convert the generated HTML reports to PDF format, and include a company logo within the reports.</p>"},{"location":"05_zap_scanner/#overview","title":"Overview","text":"<p>The script performs the following steps:</p> <ol> <li>Defines Report Directories: Establishes directories for storing both unauthenticated and authenticated ZAP reports.</li> <li>Executes ZAP Scans: Runs ZAP scans against specified target URLs, with options for providing authentication credentials.</li> <li>Converts to PDF: Converts the generated HTML report to a PDF format, adding a company logo and title page using <code>pdfkit</code> and <code>PyMuPDF</code>.  It also covers the original ZAP logo on the report.</li> <li>Returns Report Filename: Returns the filename of the generated PDF report.</li> </ol>"},{"location":"05_zap_scanner/#functions","title":"Functions","text":""},{"location":"05_zap_scanner/#1-get_zap_report_base_directory","title":"1. <code>get_zap_report_base_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the base directory where all ZAP reports will be stored.</p> </li> <li> <p>Functionality:</p> <ul> <li>Defines the base directory path as <code>reports/zap</code> within the Flask application's root directory.</li> <li>Uses <code>os.makedirs(report_dir_base, exist_ok=True)</code> to create the directory if it doesn't exist.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_zap_report_base_directory():\n    report_dir_base = os.path.join(current_app.root_path, 'reports', 'zap')\n    os.makedirs(report_dir_base, exist_ok=True)\n    return report_dir_base\n</code></pre> </li> </ul>"},{"location":"05_zap_scanner/#2-get_zap_results_directory","title":"2. <code>get_zap_results_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the directory for storing unauthenticated ZAP scan results.</p> </li> <li> <p>Functionality:</p> <ul> <li>Creates a sub-directory named <code>zap_results</code> within the base ZAP report directory.</li> <li>Uses <code>os.makedirs()</code> to ensure the directory exists.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_zap_results_directory():\n    results_dir = os.path.join(get_zap_report_base_directory(), 'zap_results')\n    os.makedirs(results_dir, exist_ok=True)\n    return results_dir\n</code></pre> </li> </ul>"},{"location":"05_zap_scanner/#3-get_authenticated_zap_results_directory","title":"3. <code>get_authenticated_zap_results_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the directory for storing authenticated ZAP scan results.</p> </li> <li> <p>Functionality:</p> <ul> <li>Creates a sub-directory named <code>authenticated_zap_results</code> within the base ZAP report directory.</li> <li>Uses <code>os.makedirs()</code> to ensure the directory exists.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_authenticated_zap_results_directory():\n    results_dir = os.path.join(get_zap_report_base_directory(), 'authenticated_zap_results')\n    os.makedirs(results_dir, exist_ok=True)\n    return results_dir\n</code></pre> </li> </ul>"},{"location":"05_zap_scanner/#4-format_target_urltarget","title":"4. <code>format_target_url(target)</code>","text":"<ul> <li> <p>Purpose: Formats the target URL to ensure it includes a protocol (HTTP or HTTPS).</p> </li> <li> <p>Functionality:</p> <ul> <li>Checks if the target URL starts with \"http://\" or \"https://\".</li> <li>If not, it prepends \"http://\" to the target URL.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>def format_target_url(target):\n    if not target.startswith((\"http://\", \"https://\")):\n        target = \"http://\" + target  # Default to HTTP if not provided\n    return target\n</code></pre> </li> </ul>"},{"location":"05_zap_scanner/#5-convert_html_to_pdfhtml_path-pdf_path-logo_path-report_typezap-scan-report","title":"5. <code>convert_html_to_pdf(html_path, pdf_path, logo_path, report_type=\"ZAP Scan Report\")</code>","text":"<ul> <li> <p>Purpose: Converts an HTML file to PDF, adds a company logo and title using <code>pdfkit</code> for the initial conversion and <code>PyMuPDF</code> for post-processing. Also, it covers the ZAP logo on the report.</p> </li> <li> <p>Functionality:</p> <ul> <li>HTML to PDF Conversion (pdfkit):<ul> <li>Uses <code>pdfkit.from_file()</code> to convert the HTML file at <code>html_path</code> to a PDF file at <code>pdf_path</code>.</li> <li>Configures <code>pdfkit</code> with <code>wkhtmltopdf</code> executable path (hardcoded as <code>/usr/local/bin/wkhtmltopdf</code>).</li> <li>Sets PDF options like page size, margins, encoding, and enables local file access.</li> </ul> </li> <li>Post-Processing (PyMuPDF):<ul> <li>Opens the generated PDF using <code>fitz.open()</code>.</li> <li>Loads the company logo from <code>logo_path</code> using <code>fitz.Pixmap()</code>. The <code>logo_path</code> is joined with <code>current_app.root_path</code> to create an absolute path.</li> <li>If the logo file exists, it calculates the logo's dimensions and position to center it on the first and last page.</li> <li>Adds a new blank page at the beginning and the end of the PDF containing the logo and title.</li> <li>Covers the ZAP logo on the second page with a white rectangle.</li> <li>Saves the modified PDF with incremental updates (<code>pdf_doc.saveIncr()</code>).</li> </ul> </li> <li>Error Handling: Uses <code>try...except</code> blocks to catch exceptions related to <code>pdfkit</code> and <code>PyMuPDF</code>, re-raising <code>pdfkit</code> related exceptions while returning <code>None</code> from the function if the error occurs during <code>PyMuPDF</code> processing.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import fitz\nimport pdfkit\nimport os\nfrom flask import current_app\n\ndef convert_html_to_pdf(html_path, pdf_path, logo_path, report_type=\"ZAP Scan Report\"):  # Added report_type argument\n    \"\"\"Convert HTML file to PDF using pdfkit, then add logo and title with PyMuPDF.\"\"\"\n    try:\n        # Configure pdfkit to point to the wkhtmltopdf executable\n        config = pdfkit.configuration(wkhtmltopdf='/usr/local/bin/wkhtmltopdf')  # Update this path if necessary\n\n        # Convert HTML file to PDF\n        options = {\n            'page-size': 'A4',\n            'margin-top': '10mm',\n            'margin-right': '10mm',\n            'margin-bottom': '10mm',\n            'margin-left': '10mm',\n            'encoding': \"UTF-8\",\n            'enable-local-file-access': '' # Ensure local file access is enabled\n        }\n        pdfkit.from_file(html_path, pdf_path, configuration=config, options=options)\n        print(f\"Successfully created PDF: {pdf_path}\")\n\n    except Exception as e:\n        msg = f\"Error converting HTML to PDF with pdfkit: {e}\"\n        print(msg)\n        raise Exception(msg)  # Re-raise exception for handling\n\n    try:\n        # Add logo and title using PyMuPDF\n        pdf_doc = fitz.open(pdf_path)\n        logo_path = os.path.join(current_app.root_path, logo_path)  # Absolute Path from Relative Path\n\n        if not os.path.exists(logo_path):\n            msg = f\"Logo not found at {logo_path}\"\n            print(msg)\n            raise FileNotFoundError(msg)\n\n        logo = fitz.Pixmap(logo_path)\n        logo_width_pt = 200  # Adjust as needed\n        aspect_ratio = logo.width / logo.height\n        logo_height_pt = logo_width_pt / aspect_ratio\n\n        # Create a new page as the first page\n        new_page = pdf_doc.new_page(width=pdf_doc[0].rect.width, height=pdf_doc[0].rect.height,\n                                     pno=0)  # Insert as the *first* page\n        page_width = new_page.rect.width\n        page_height = new_page.rect.height\n\n        # Calculate total height of logo and title with gap\n        title_text = report_type  # Use the dynamic report type\n        font_size = 24\n        text_height = font_size  # Approximate text height\n\n        total_height = logo_height_pt + 30 + text_height  # Logo + gap + title\n\n        # Calculate starting Y position for vertical centering\n        start_y = (page_height - total_height) / 2\n\n        # Calculate logo position (centered horizontally, vertically aligned)\n        logo_x = (page_width - logo_width_pt) / 2\n        logo_y = start_y  # Distance from the top\n\n        logo_rect = fitz.Rect(logo_x, logo_y, logo_x + logo_width_pt, logo_y + logo_height_pt)\n        new_page.insert_image(logo_rect, pixmap=logo)\n\n        # Add a title (optional)\n\n        text_width = fitz.get_text_length(title_text, fontname=\"helvetica-bold\",\n                                           fontsize=font_size)  # Use the get_text_length for exact positioning\n        text_x = (page_width - text_width) / 2\n        text_y = logo_y + logo_height_pt + 30  # Below the logo\n        new_page.insert_text((text_x, text_y), title_text, fontname=\"helvetica-bold\", fontsize=font_size,\n                              color=(0, 0, 0))  # Black text\n\n        # Cover the ZAP logo on the original first page with a white rectangle\n        original_first_page = pdf_doc[1]  # The original first page is now the *second* page.\n\n        # Define rectangle coordinates based on the image provided (adjust as needed)\n        rect_x = 0\n        rect_y = 0\n        rect_width = 450  # Adjust based on ZAP logo size\n        rect_height = 90  # Adjust based on ZAP logo size\n\n        # Draw a white rectangle to hide the ZAP logo\n        original_first_page.draw_rect(fitz.Rect(rect_x, rect_y, rect_x + rect_width, rect_y + rect_height),\n                                    color=(1, 1, 1), fill=(1, 1, 1)) #Draw white rectangle\n\n        # Add the same page to the end of the document\n        last_page = pdf_doc.new_page(width=pdf_doc[0].rect.width, height=pdf_doc[0].rect.height)  # Create new page with the same height and width with original file\n        logo_x = (page_width - logo_width_pt) / 2\n        logo_y = start_y  # Distance from the top\n\n        logo_rect = fitz.Rect(logo_x, logo_y, logo_x + logo_width_pt, logo_y + logo_height_pt)\n        last_page.insert_image(logo_rect, pixmap=logo)  # insert the logo to the last page\n\n        text_x = (page_width - text_width) / 2\n        text_y = logo_y + logo_height_pt + 30  # Below the logo\n        last_page.insert_text((text_x, text_y), title_text, fontname=\"helvetica-bold\", fontsize=font_size,\n                              color=(0, 0, 0))  # Black text #insert the text to the last page\n\n        pdf_doc.saveIncr()\n        print(f\"Successfully added new page and logo to PDF: {pdf_path}\")\n\n    except Exception as e:\n        msg = f\"Error processing PDF with PyMuPDF (fitz): {e}\"\n        print(msg)\n        raise Exception(msg)  # Re-raise exception for handling\n\n    return os.path.basename(pdf_path)\n</code></pre> </li> </ul>"},{"location":"05_zap_scanner/#6-run_zap_active_scantarget_url-user_idnone","title":"6. <code>run_zap_active_scan(target_url, user_id=None)</code>","text":"<ul> <li> <p>Purpose: Executes an unauthenticated ZAP active scan against a specified target URL.</p> </li> <li> <p>Functionality:</p> <ul> <li>Defines the path to the ZAP executable.</li> <li>Formats the target URL using <code>format_target_url()</code>.</li> <li>Constructs the ZAP command with the target URL and output options (HTML report).</li> <li>Executes the ZAP command using <code>subprocess.Popen</code> in daemon mode.</li> <li>Reads the ZAP output in real-time to determine when the scan is complete.</li> <li>Terminates the ZAP process after the results are written.</li> <li>Converts the HTML report to PDF using <code>convert_html_to_pdf()</code>.</li> <li>Returns the filename of the generated PDF report, or an error message if the scan or conversion fails.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nimport subprocess\nfrom datetime import datetime\nfrom flask import current_app\nimport pdfkit\nimport tempfile\nimport time\nimport fitz\n\ndef run_zap_active_scan(target_url, user_id=None):\n    ZAP_EXECUTABLE = current_app.config.get('ZAP_EXECUTABLE', '/usr/bin/zaproxy') # Adjust path as needed\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    results_dir = get_zap_results_directory()\n    html_report_filename = os.path.join(results_dir, f\"{user_id}_zap_{timestamp}.html\")\n    pdf_report_filename = os.path.join(results_dir, f\"{user_id}_zap_{timestamp}.pdf\")\n    formatted_target = format_target_url(target_url)\n    COMPANY_LOGO_PATH = 'static/images/company_logo.PNG'  # Change to your actual logo path - RELATIVE URL\n    print(COMPANY_LOGO_PATH)\n\n    # Create a temporary directory for ZAP's home\n    with tempfile.TemporaryDirectory() as zap_home:\n        command = [\n            ZAP_EXECUTABLE,\n            '-daemon',\n            '-quickurl', formatted_target,\n            '-quickout', html_report_filename,\n            '-quickprogress'\n        ]\n\n        try:\n            print(f\"Running ZAP command: {' '.join(command)}\")\n            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)\n\n            pdf_filename = None\n            for line in iter(process.stdout.readline, ''):\n                line = line.strip()\n                print(line)\n                if \"Writing results to\" in line:\n                    print(\"ZAP scan completed writing results. Proceeding to PDF conversion.\")\n                    time.sleep(30) # Give ZAP a moment to fully write the file\n                    process.terminate() # Terminate ZAP after writing results\n\n\n                    pdf_filename = convert_html_to_pdf(html_report_filename, pdf_report_filename, COMPANY_LOGO_PATH, report_type=\"ZAP Scan Report\")  # Default report type\n\n                    break\n\n            process.wait(timeout=60) # Wait for the process to terminate (with a timeout)\n\n            if pdf_filename:\n                # os.remove(html_report_filename) # or keep it for debugging\n                return pdf_filename\n            else:\n                error_output = process.stderr.read() if process.stderr else \"\"\n                return f\"Error: Failed to generate PDF report. ZAP output/errors:\\nStdout: (see logs above)\\nStderr: {error_output}\"\n        except FileNotFoundError:\n            return f\"Error: ZAP executable not found at {ZAP_EXECUTABLE}. Please check your configuration.\"\n        except subprocess.TimeoutExpired:\n            return \"Error: Authenticated ZAP scan timed out.\"\n        except Exception as e:\n            return f\"Error: An unexpected error occurred during Authenticated ZAP scan: {e}\"\n</code></pre> </li> </ul>"},{"location":"05_zap_scanner/#7-run_zap_authenticated_scantarget_url-username-password-user_idnone","title":"7. <code>run_zap_authenticated_scan(target_url, username, password, user_id=None)</code>","text":"<ul> <li> <p>Purpose: Executes an authenticated ZAP active scan against a specified target URL.</p> </li> <li> <p>Functionality:</p> <ul> <li>Similar to <code>run_zap_active_scan()</code>, but includes username and password for authentication.</li> <li>Uses the <code>-config</code> options to configure basic authentication for ZAP.</li> <li>Stores the results in the <code>authenticated_zap_results</code> directory.</li> <li>Returns the filename of the generated PDF report, or an error message if the scan or conversion fails.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nimport subprocess\nfrom datetime import datetime\nfrom flask import current_app\nimport pdfkit\nimport tempfile\nimport time\nimport fitz\n\ndef run_zap_authenticated_scan(target_url, username, password, user_id=None):\n    ZAP_EXECUTABLE = current_app.config.get('ZAP_EXECUTABLE', '/usr/bin/zaproxy') # Adjust path as needed\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    results_dir = get_authenticated_zap_results_directory()\n    html_report_filename = os.path.join(results_dir, f\"{user_id}_zap_auth_{timestamp}.html\")\n    pdf_report_filename = os.path.join(results_dir, f\"{user_id}_zap_auth_{timestamp}.pdf\")\n    formatted_target = format_target_url(target_url)\n    COMPANY_LOGO_PATH = 'static/images/company_logo.PNG'  # Change to your actual logo path - RELATIVE URL\n\n    # Create a temporary directory for ZAP's home\n    with tempfile.TemporaryDirectory() as zap_home:\n        command = [\n            ZAP_EXECUTABLE,\n            '-daemon',\n            '-config',\n            'api.disablekey=true',\n            '-quickurl', formatted_target,\n            '-quickout', html_report_filename,\n            '-quickprogress',\n            '-config',\n            f'http.authentication.basic.credentials={username}:{password}'\n        ]\n\n        try:\n            print(f\"Running ZAP authenticated command: {' '.join(command)}\")\n            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)\n\n            pdf_filename = None\n            for line in iter(process.stdout.readline, ''):\n                line = line.strip()\n                print(line)\n                if \"Writing results to\" in line:\n                    print(\"Authenticated ZAP scan completed writing results. Proceeding to PDF conversion.\")\n                    time.sleep(30) # Give ZAP a moment to fully write the file\n                    process.terminate() # Terminate ZAP after writing results\n\n                    pdf_filename = convert_html_to_pdf(html_report_filename, pdf_report_filename, COMPANY_LOGO_PATH, report_type=\"Authenticated ZAP Scan Report\") # Authenticated report type\n\n                    break\n\n            process.wait(timeout=60) # Wait for the process to terminate (with a timeout)\n\n            if pdf_filename:\n                #os.remove(html_report_filename) #or keep it for debugging\n                return pdf_filename\n            else:\n                error_output = process.stderr.read() if process.stderr else \"\"\n                return f\"Error: Failed to generate PDF report for authenticated scan. ZAP output/errors:\\nStdout: (see logs above)\\nStderr: {error_output}\"\n\n        except FileNotFoundError:\n            return f\"Error: ZAP executable not found at {ZAP_EXECUTABLE}. Please check your configuration.\"\n        except subprocess.TimeoutExpired:\n            return \"Error: Authenticated ZAP scan timed out.\"\n        except Exception as e:\n            return f\"Error: An unexpected error occurred during Authenticated ZAP scan: {e}\"\n</code></pre> </li> </ul>"},{"location":"05_zap_scanner/#dependencies","title":"Dependencies","text":"<ul> <li>OWASP ZAP (Zed Attack Proxy): A web application security scanner. Must be installed and in the system's PATH.</li> <li>Python Libraries:<ul> <li><code>subprocess</code>: For running external commands (ZAP).</li> <li><code>os</code>: For file system operations.</li> <li><code>datetime</code>: For generating unique report filenames.</li> <li><code>flask</code>: For accessing the application's root path and configuration.</li> <li><code>pdfkit</code>: For converting HTML to PDF (<code>pip install pdfkit</code>). Requires <code>wkhtmltopdf</code> to be installed.</li> <li><code>tempfile</code>: For creating temporary directories.</li> <li><code>time</code>: For adding delays.</li> <li><code>PyMuPDF (fitz)</code>: For adding the company logo and title to the PDF (<code>pip install pymupdf</code>).</li> </ul> </li> <li>wkhtmltopdf: A command-line tool required by <code>pdfkit</code> to convert HTML to PDF. It needs to be installed separately. Follow the instructions at https://wkhtmltopdf.org/downloads.html for your operating system.</li> </ul>"},{"location":"05_zap_scanner/#configuration","title":"Configuration","text":"<ul> <li><code>ZAP_EXECUTABLE</code>: A configuration setting in the Flask application that specifies the path to the ZAP executable. If not set, it defaults to <code>/usr/bin/zaproxy</code>. This is accessed via <code>current_app.config.get('ZAP_EXECUTABLE', '/usr/bin/zaproxy')</code>.</li> <li><code>WKHTMLTOPDF_EXECUTABLE</code>: In the provided code, this is hardcoded as <code>/usr/local/bin/wkhtmltopdf</code> within the <code>convert_html_to_pdf</code> function. Best practice is to configure it in the Flask app.</li> <li><code>COMPANY_LOGO_PATH</code>: Specifies the relative path to the company logo image within the Flask application's static files directory (e.g., <code>'static/images/company_logo.PNG'</code>).</li> </ul>"},{"location":"05_zap_scanner/#error-handling","title":"Error Handling","text":"<p>The script includes error handling in the following areas:</p> <ul> <li>ZAP execution (handling <code>FileNotFoundError</code>, <code>subprocess.TimeoutExpired</code>, and general exceptions).</li> <li>HTML to PDF conversion.</li> <li>Missing dependencies (e.g., ZAP or <code>wkhtmltopdf</code> not installed).</li> </ul> <p>Errors are printed to the console and returned as error messages by the functions.</p>"},{"location":"05_zap_scanner/#security-considerations","title":"Security Considerations","text":"<ul> <li>Authentication Credentials: The <code>run_zap_authenticated_scan()</code> function handles sensitive authentication credentials. It's critical to:<ul> <li>Store the credentials securely before passing them to the script. Avoid logging the credentials directly.</li> </ul> </li> <li>Input Validation: The target URL should be validated to prevent command injection vulnerabilities.</li> <li>ZAP Execution: ZAP scans can be resource-intensive and may impact the performance of the target application. Ensure you have permission to scan the target.</li> <li>Temporary Directory: ZAP temporary files are created in temp directory, these are handled properly to avoid accidental leak of sensitive data.</li> </ul>"},{"location":"06_mobsf_scanner/","title":"MobSF Scanner","text":"<p>This document details the functionality of the file <code>mobsf_scanner.py</code>, which automates mobile application security assessments using MobSF (Mobile Security Framework). The script provides functions to upload and analyze an application, fetch the generated PDF report, and customize the first page with a company logo.</p>"},{"location":"06_mobsf_scanner/#overview","title":"Overview","text":"<p>The script performs the following steps:</p> <ol> <li>Defines Report Directory: Establishes the directory for storing MobSF reports.</li> <li>Uploads and Analyzes App: Uploads the provided application file to the MobSF API for analysis.</li> <li>Fetches and Customizes PDF Report: Downloads the generated PDF report from MobSF, adds a company logo and title to the first page using <code>PyMuPDF</code>, and removes the original first page.</li> <li>Returns Report Filename: Returns the filename of the generated PDF report.</li> </ol>"},{"location":"06_mobsf_scanner/#functions","title":"Functions","text":""},{"location":"06_mobsf_scanner/#1-get_mobsf_report_directory","title":"1. <code>get_mobsf_report_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the directory where MobSF reports will be stored.</p> </li> <li> <p>Functionality:</p> <ul> <li>Defines the base directory path as <code>reports/mobsf</code> within the Flask application's root directory.</li> <li>Uses <code>os.makedirs(report_dir_base, exist_ok=True)</code> to create the directory if it doesn't exist.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_mobsf_report_directory():\n    report_dir_base = os.path.join(current_app.root_path, 'reports', 'mobsf')\n    os.makedirs(report_dir_base, exist_ok=True)\n    return report_dir_base\n</code></pre> </li> </ul>"},{"location":"06_mobsf_scanner/#2-upload_and_analyzeapp_file-api_url-api_key","title":"2. <code>upload_and_analyze(app_file, api_url, api_key)</code>","text":"<ul> <li> <p>Purpose: Uploads the mobile app file to the MobSF API and initiates the analysis.</p> </li> <li> <p>Functionality:</p> <ul> <li>Constructs the upload URL using the provided <code>api_url</code>.</li> <li>Sets the <code>Authorization</code> header with the <code>api_key</code>.</li> <li>Creates a <code>files</code> dictionary containing the application file details (filename, stream, content type).</li> <li>Uses <code>requests.post()</code> to upload the file to MobSF.</li> <li>Parses the JSON response to check for a successful upload.</li> <li>If the upload is successful, it extracts the file hash and calls <code>initiate_scan()</code> to start the analysis.</li> <li>Returns the file hash if the upload and scan initiation are successful, otherwise returns <code>None</code>.</li> <li>Includes exception handling for network-related errors.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import requests\n\ndef upload_and_analyze(app_file, api_url, api_key):\n    upload_url = f\"{api_url}/api/v1/upload\"\n    headers = {'Authorization': api_key}\n    files = {'file': (app_file.filename, app_file.stream, app_file.content_type)}\n\n    try:\n        response = requests.post(upload_url, headers=headers, files=files)\n        response.raise_for_status()\n        data = response.json()\n        if data.get('status') == \"success\":\n            file_hash = data.get('hash')\n            if file_hash:\n                if initiate_scan(file_hash, api_url, api_key):\n                    return file_hash\n                else:\n                    print(f\"MobSF Error: Failed to initiate scan for hash {file_hash}\")\n                    return None\n            else:\n                print(f\"MobSF Error: Missing hash in upload response: {data}\")\n                return None\n        else:\n            print(f\"MobSF Upload Error: {data}\")\n            return None\n    except requests.exceptions.RequestException as e:\n        print(f\"Error communicating with MobSF API (upload): {e}\")\n        return None\n</code></pre> </li> </ul>"},{"location":"06_mobsf_scanner/#3-initiate_scanfile_hash-api_url-api_key","title":"3. <code>initiate_scan(file_hash, api_url, api_key)</code>","text":"<ul> <li> <p>Purpose: Initiates the MobSF scan for a previously uploaded file.</p> </li> <li> <p>Functionality:</p> <ul> <li>Constructs the scan URL using the provided <code>api_url</code>.</li> <li>Sets the <code>Authorization</code> header with the <code>api_key</code>.</li> <li>Creates a <code>data</code> dictionary containing the file hash and scan type (assumes APK, but can be adjusted).</li> <li>Uses <code>requests.post()</code> to initiate the scan.</li> <li>Parses the JSON response to check for a successful scan initiation by confirming the existence of <code>title</code> key which determines the success</li> <li>Returns <code>True</code> if the scan initiation is successful, otherwise returns <code>False</code>.</li> <li>Includes exception handling for network-related errors.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import requests\n\ndef initiate_scan(file_hash, api_url, api_key):\n    scan_url = f\"{api_url}/api/v1/scan\"\n    headers = {'Authorization': api_key}\n    data = {'hash': file_hash, \"scan_type\": \"apk\"} # Assuming APK, adjust if needed\n\n    try:\n        response = requests.post(scan_url, headers=headers, data=data)\n        response.raise_for_status()\n        data = response.json()\n        if data.get('title'):\n            print(f\"MobSF Scan initiated successfully for hash: {file_hash}\")\n            return True\n        else:\n            print(f\"MobSF Scan Initiation Error: {data}\")\n            return False\n    except requests.exceptions.RequestException as e:\n        print(f\"Error communicating with MobSF API (scan): {e}\")\n        return False\n</code></pre> </li> </ul>"},{"location":"06_mobsf_scanner/#4-fetch_and_save_pdf_reportfile_hash-api_url-api_key-user_id-original_filename","title":"4. <code>fetch_and_save_pdf_report(file_hash, api_url, api_key, user_id, original_filename)</code>","text":"<ul> <li> <p>Purpose: Fetches the PDF report from the MobSF API and replaces the first page with a custom-generated one.</p> </li> <li> <p>Functionality:</p> <ul> <li>Constructs the PDF download URL using the provided <code>api_url</code>.</li> <li>Sets the <code>Authorization</code> header with the <code>api_key</code>.</li> <li>Creates a <code>data</code> dictionary containing the file hash.</li> <li>Uses <code>requests.post()</code> with <code>stream=True</code> to download the PDF report.</li> <li>Opens the PDF report using <code>fitz.open()</code>.</li> <li>Dynamically determine the report type based on file type.</li> <li>Creates a new page with company logo and mobile app title on the upper half and copies the lower half of the original mobsf report to the lower half of the new page, replacing the default MobSF first page with the custom content.</li> <li>Saves the modified PDF report to the reports directory with a unique filename.</li> <li>Returns the filename of the saved PDF report, or <code>None</code> on failure.</li> <li>Includes exception handling for network-related errors and PDF processing errors.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import requests\nimport os\nfrom datetime import datetime\nfrom flask import current_app\nimport fitz  # PyMuPDF\n\ndef fetch_and_save_pdf_report(file_hash, api_url, api_key, user_id, original_filename):\n    pdf_url = f\"{api_url}/api/v1/download_pdf\"\n    headers = {'Authorization': api_key}\n    data = {'hash': file_hash}\n\n    try:\n        response = requests.post(pdf_url, headers=headers, data=data, stream=True)\n        response.raise_for_status()\n\n        pdf_bytes = response.content\n        pdf_doc = fitz.open(stream=pdf_bytes, filetype=\"pdf\")\n\n        # Get dimensions of existing page\n        page_width = pdf_doc[0].rect.width\n        page_height = pdf_doc[0].rect.height\n\n        # Create a new page and insert it at the beginning (index 0), replacing the old one\n        pdf_doc.new_page(pno=1, width=page_width, height=page_height)\n\n        # Get new page\n        new_page= pdf_doc[1]\n\n        # --- Add dark gray background to the ENTIRE page ---\n        full_page_rect = fitz.Rect(0, 0, page_width, page_height)\n\n        # White color\n        gray_color = (1, 1, 1)\n        new_page.draw_rect(full_page_rect, color=gray_color, fill=gray_color)\n\n        # --- Create the UPPER HALF of the new first page ---\n        logo_path = os.path.join(current_app.root_path, 'static', 'images', 'company_logo.PNG')\n        if os.path.exists(logo_path):\n            logo = fitz.Pixmap(logo_path)\n            logo_width_pt = 200\n            aspect_ratio = logo.width / logo.height\n            logo_height_pt = logo_width_pt / aspect_ratio\n\n            # Center the logo at the top of the page\n            logo_x = (page_width - logo_width_pt) / 2\n            logo_y = 50\n\n            logo_rect = fitz.Rect(logo_x, logo_y, logo_x + logo_width_pt, logo_y + logo_height_pt)\n\n            new_page.insert_image(logo_rect, pixmap=logo, overlay=True)\n        else:\n            print(f\"Warning: Logo not found at {logo_path}\")\n\n        # Load the font file\n        font_file = os.path.join(current_app.root_path, 'static', 'fonts', 'Montserrat-Medium.ttf')\n\n        # Check if the font file exists\n        if not os.path.exists(font_file):\n            print(f\"Warning: Font file not found at {font_file}\")\n            font_name = \"Helvetica-Bold\" # Fallback to a standard font\n\n\n        # Determine the report type\n        if original_filename.lower().endswith(('.apk')):\n            report_type = \"ANDROID\"\n        elif original_filename.lower().endswith(('.ipa')):\n            report_type = \"IOS\"\n        else:\n            report_type = \"MOBILE\"\n\n        title_text = f\"{report_type} STATIC ANALYSIS REPORT\"\n        title_font_size = 28\n        title_color = (0, 0, 0)\n\n        # Calculate text width using the font file\n        text_width = fitz.get_text_length(title_text, fontname='helvetica-bold', fontsize=title_font_size)\n        text_x = (page_width - text_width) / 2\n        text_y = logo_y + logo_height_pt + 30\n\n        # Insert the title text\n        new_page.insert_text(\n            (text_x, text_y),\n            title_text,\n            fontname='helvetica-bold',  # Use the font name assigned\n            fontsize=title_font_size,\n            color=title_color\n        )\n\n        # --- Copy the LOWER HALF of the original MobSF first page ---\n        # Define the rectangle to copy from the original page\n        source_rect = fitz.Rect(0, page_height / 2, page_width, page_height)\n\n        # Create a temporary PDF document containing only the first page\n        temp_pdf = fitz.open()\n        temp_page = temp_pdf.new_page(width=page_width, height=page_height)\n        temp_page.show_pdf_page(temp_page.rect, pdf_doc, 0)\n\n        # Define the target rectangle on the new page for the lower half\n        target_rect = fitz.Rect(0, page_height / 2, page_width, page_height)\n\n        # Insert the area into the new page from the temp PDF, using target_rect\n        new_page.show_pdf_page(target_rect, temp_pdf, 0, clip=source_rect)\n\n        # Delete the original first page (now at position 0)\n        pdf_doc.delete_page(0)\n\n        #Close temporary pdf doc\n        temp_pdf.close()\n\n        # --- Save the modified PDF ---\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        report_filename = f\"{user_id}_mobsf_{os.path.splitext(original_filename)[0].replace('.', '_')}_{timestamp}.pdf\"\n        report_dir = get_mobsf_report_directory()\n        pdf_path = os.path.join(report_dir, report_filename)\n        pdf_doc.save(pdf_path)\n        pdf_doc.close()\n\n        return os.path.basename(report_filename)\n\n    except requests.exceptions.RequestException as e:\n        print(f\"Error fetching MobSF PDF report: {e}\")\n        return None\n    except Exception as e:\n        print(f\"Error processing MobSF PDF report: {e}\")\n        return None\n</code></pre> </li> </ul>"},{"location":"06_mobsf_scanner/#dependencies","title":"Dependencies","text":"<ul> <li>MobSF (Mobile Security Framework): A mobile application security assessment framework. MobSF server must be running and accessible.</li> <li>Python Libraries:<ul> <li><code>requests</code>: For making HTTP requests to the MobSF API (<code>pip install requests</code>).</li> <li><code>os</code>: For file system operations.</li> <li><code>datetime</code>: For generating unique report filenames.</li> <li><code>flask</code>: For accessing the application's root path and configuration.</li> <li><code>PyMuPDF (fitz)</code>: For manipulating PDF reports and adding the company logo (<code>pip install pymupdf</code>).</li> </ul> </li> </ul>"},{"location":"06_mobsf_scanner/#configuration","title":"Configuration","text":"<ul> <li>MobSF API URL and API Key: These are external configuration parameters that needs to be configured.</li> <li><code>COMPANY_LOGO_PATH</code>: Specifies the relative path to the company logo image within the Flask application's static files directory (e.g., <code>'static/images/company_logo.PNG'</code>).</li> <li><code>font_file</code>: Specifies the location of the font file to load.</li> </ul>"},{"location":"06_mobsf_scanner/#error-handling","title":"Error Handling","text":"<p>The script includes error handling for:</p> <ul> <li>Network connectivity issues when communicating with the MobSF API.</li> <li>Invalid responses from the MobSF API.</li> <li>File processing errors during PDF report generation and manipulation.</li> <li>Font loading errors.</li> </ul> <p>Errors are printed to the console and returned as <code>None</code> by the functions.</p>"},{"location":"06_mobsf_scanner/#security-considerations","title":"Security Considerations","text":"<ul> <li>API Key: The MobSF API key is a sensitive credential. It's crucial to:<ul> <li>Store the API key securely.</li> <li>Avoid hardcoding the API key directly into the script. Use environment variables, configuration files, or a secret management solution.</li> </ul> </li> <li>Network Communication: Ensure that the communication channel between the script and the MobSF API is secure (HTTPS).</li> <li>File Handling: The script handles uploaded application files. Implement appropriate file type validation and size limits to prevent malicious uploads.</li> </ul>"},{"location":"07_sqlmap_scanner/","title":"SQLMap Scanner","text":"<p>This document details the functionality of the file <code>sqlmap_scanner.py</code>, which automates SQL injection vulnerability scanning using SQLMap. The script provides a function to execute a SQLMap scan, process the generated raw text report, and generate a PDF report.</p>"},{"location":"07_sqlmap_scanner/#overview","title":"Overview","text":"<p>The script performs the following steps:</p> <ol> <li>Defines Report Directories: Establishes directories for storing raw SQLMap reports and generated PDF reports.</li> <li>Executes SQLMap Scan: Runs SQLMap against a specified target URL.</li> <li>Processes Raw Report: Reads the raw text report (CSV, log, or target.txt) generated by SQLMap.</li> <li>Generates PDF Report: Creates a formatted PDF report using <code>reportlab</code>, including user information, target URL, and the content of the raw SQLMap report.</li> <li>Returns Report Filename: Returns the filename of the generated PDF report.</li> </ol>"},{"location":"07_sqlmap_scanner/#functions","title":"Functions","text":""},{"location":"07_sqlmap_scanner/#1-get_sqlmap_base_report_directory","title":"1. <code>get_sqlmap_base_report_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the base directory where all SQLMap reports will be stored.</p> </li> <li> <p>Functionality:</p> <ul> <li>Defines the base directory path as <code>reports/sqlmap</code> within the Flask application's root directory.</li> <li>Uses <code>os.makedirs(report_dir_base, exist_ok=True)</code> to create the directory if it doesn't exist.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_sqlmap_base_report_directory():\n    report_dir_base = os.path.join(current_app.root_path, 'reports', 'sqlmap')\n    os.makedirs(report_dir_base, exist_ok=True)\n    return report_dir_base\n</code></pre> </li> </ul>"},{"location":"07_sqlmap_scanner/#2-get_sqlmap_results_directory","title":"2. <code>get_sqlmap_results_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the directory for storing raw SQLMap scan results (CSV, log files).</p> </li> <li> <p>Functionality:</p> <ul> <li>Creates a sub-directory named <code>sqlmap_results</code> within the base SQLMap report directory.</li> <li>Uses <code>os.makedirs()</code> to ensure the directory exists.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_sqlmap_results_directory():\n    results_dir = os.path.join(get_sqlmap_base_report_directory(), 'sqlmap_results')\n    os.makedirs(results_dir, exist_ok=True)\n    return results_dir\n</code></pre> </li> </ul>"},{"location":"07_sqlmap_scanner/#3-get_sqlmap_pdf_directory","title":"3. <code>get_sqlmap_pdf_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the directory for storing generated PDF reports.</p> </li> <li> <p>Functionality:</p> <ul> <li>Creates a sub-directory named <code>pdf_results</code> within the base SQLMap report directory.</li> <li>Uses <code>os.makedirs()</code> to ensure the directory exists.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_sqlmap_pdf_directory():\n    pdf_dir = os.path.join(get_sqlmap_base_report_directory(), 'pdf_results')\n    os.makedirs(pdf_dir, exist_ok=True)\n    return pdf_dir\n</code></pre> </li> </ul>"},{"location":"07_sqlmap_scanner/#4-generate_sqlmap_report_pdftarget_url-report_text","title":"4. <code>generate_sqlmap_report_pdf(target_url, report_text)</code>","text":"<ul> <li> <p>Purpose: Generates a PDF report from the raw SQLMap scan results using the <code>reportlab</code> library.</p> </li> <li> <p>Functionality:</p> <ul> <li>Generates a unique filename for the PDF report based on the user ID and timestamp.</li> <li>Initializes a <code>SimpleDocTemplate</code> for creating the PDF.</li> <li>Defines custom styles for the title, body text, and other elements of the report.</li> <li>Creates a <code>story</code> list to hold the content of the PDF.</li> <li>Adds a company logo at the beginning and end of the report.</li> <li>Adds a title to the report.</li> <li>Includes a report information table containing the scan initiator (username), timestamp, and target URL.</li> <li>Formats the raw SQLMap report content, splitting it into lines and adding each line as a paragraph to the story.</li> <li>Builds the PDF document using <code>doc.build(story)</code>.</li> <li>Returns the filename of the generated PDF report.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import os\nfrom flask import current_app\nfrom flask_login import current_user\nfrom datetime import datetime\nfrom reportlab.lib.pagesizes import letter\nfrom reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.lib.enums import TA_LEFT, TA_CENTER\nfrom reportlab.lib.units import inch\n\nAPP_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nCOMPANY_LOGO = os.path.join(APP_ROOT, 'static', 'images', 'company_logo.PNG')  # Replace with the actual filename\n\ndef generate_sqlmap_report_pdf(target_url, report_text):\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    pdf_dir = get_sqlmap_pdf_directory()\n    pdf_filename = os.path.join(pdf_dir, f\"{current_user.id}_sqlmap_{timestamp}.pdf\")\n\n    doc = SimpleDocTemplate(pdf_filename, pagesize=letter)\n    styles = getSampleStyleSheet()\n\n    # Modern font style\n    modern_style = ParagraphStyle(\n        name='Modern',\n        parent=styles['Normal'],\n        fontName='Helvetica',\n        fontSize=12,\n        leading=14,\n        alignment=TA_LEFT,\n    )\n\n    title_style = ParagraphStyle(\n        name='Title',\n        parent=modern_style,\n        fontSize=16,\n        leading=20,\n        alignment=TA_CENTER,\n        fontName='Helvetica-Bold',\n    )\n\n    story = []\n\n    # --- Header ---\n    if os.path.exists(COMPANY_LOGO):\n        logo_header = Image(COMPANY_LOGO, width=1 * inch, height=1 * inch)\n        story.append(logo_header)\n        print(\"logo added in header\")\n    story.append(Spacer(1, 0.2 * inch))\n\n    # --- Title ---\n    title_text = \"SQLMap Scan Report\"\n    story.append(Paragraph(title_text, title_style))\n    story.append(Spacer(1, 0.3 * inch))\n\n    # --- Report Information ---\n    report_info_data = [\n        [\"Scan Initiated By:\", f\"{current_user.username if current_user.is_authenticated else 'N/A'}\"],\n        [\"Timestamp:\", datetime.now().strftime('%Y-%m-%d %H:%M:%S')],\n        [\"Target URL:\", target_url],\n    ]\n    from reportlab.platypus import Table, TableStyle\n    report_info_table = Table(report_info_data, colWidths=[2 * inch, 5 * inch])\n    report_info_table.setStyle(TableStyle([\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTSIZE', (0, 0), (-1, -1), 10),\n        ('BOTTOMPADDING', (0, 0), (-1, 0), 6),\n    ]))\n    story.append(report_info_table)\n    story.append(Spacer(1, 0.3 * inch))\n\n    # --- Report Content ---\n    report_lines = report_text.splitlines()\n    for line in report_lines:\n        p = Paragraph(line, modern_style)\n        story.append(p)\n        story.append(Spacer(1, 0.05 * inch)) # Adjust spacing as needed\n\n    story.append(Spacer(1, 0.5 * inch))\n\n    # --- Logo at the End ---\n    if os.path.exists(COMPANY_LOGO):\n        logo_footer = Image(COMPANY_LOGO, width=1 * inch, height=1 * inch, hAlign='CENTER')\n        story.append(logo_footer)\n\n    doc.build(story)\n    return os.path.basename(pdf_filename)\n</code></pre> </li> </ul>"},{"location":"07_sqlmap_scanner/#5-run_sqlmap_scantarget_url-user_idnone","title":"5. <code>run_sqlmap_scan(target_url, user_id=None)</code>","text":"<ul> <li> <p>Purpose: Executes a SQLMap scan against a specified target URL.</p> </li> <li> <p>Functionality:</p> <ul> <li>Constructs the SQLMap command with the target URL and scan options (batch mode, level 1, risk 1, dump all, output directory, crawl 2, verbosity 3).</li> <li>Executes the SQLMap command using <code>subprocess.run</code>.</li> <li>Handles cases where the SQLMap scan fails.</li> <li>Finds the most recent CSV file, log, or target.txt file generated by SQLMap (based on creation time).</li> <li>Reads the content of the raw report.</li> <li>Generates the PDF report by calling <code>generate_sqlmap_report_pdf</code>.</li> <li>Deletes the raw report file after PDF report generation.</li> <li>Includes error handling for file processing and command execution.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import subprocess\nimport os\nimport glob\nfrom datetime import datetime\nfrom flask import current_app\nfrom flask_login import current_user\n\ndef run_sqlmap_scan(target_url, user_id=None):\n    results_dir = get_sqlmap_results_directory()\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    print(results_dir)\n    command = [\n        \"sqlmap\",\n        \"-u\", target_url,\n        \"--batch\",\n        \"--level\", \"1\",\n        \"--risk\", \"1\",\n        \"--dump-all\",\n        \"--output-dir\", results_dir,\n        \"--crawl=2\",\n        \"-v\", \"3\"  # Increased verbosity for debugging\n    ]\n\n    try:\n        result = subprocess.run(command, capture_output=True, text=True, check=False)\n\n        print(\"SQLMap Standard Output:\")\n        print(result.stdout)\n        print(\"SQLMap Standard Error:\")\n        print(result.stderr)\n\n        if result.returncode != 0:\n            error_message = f\"SQLMap scan failed (Return Code: {result.returncode}):\\n{result.stdout}\\n{result.stderr}\"\n            print(error_message)\n            return error_message\n\n        csv_files = glob.glob(os.path.join(results_dir, 'results-*.csv'))\n        raw_report_path = None\n        if csv_files:\n            raw_report_path = max(csv_files, key=os.path.getctime)\n        else:\n            log_files = glob.glob(os.path.join(results_dir, 'log'))\n            if log_files:\n                raw_report_path = max(log_files, key=os.path.getctime)\n            else:\n                target_files = glob.glob(os.path.join(results_dir, 'target.txt'))\n                if target_files:\n                    raw_report_path = max(target_files, key=os.path.getctime)\n                else:\n                    return \"Error: SQLMap did not generate a raw text report (CSV, log, or target.txt).\"\n\n        try:\n            with open(raw_report_path, 'r', encoding='utf-8') as f:\n                report_content = f.read()\n\n            pdf_filename = generate_sqlmap_report_pdf(target_url, report_content)\n            os.remove(raw_report_path)\n            return pdf_filename\n\n        except Exception as e:\n            error_message = f\"Error processing SQLMap report for PDF: {e}\"\n            print(error_message)\n            if os.path.exists(raw_report_path):\n                os.remove(raw_report_path)\n            pdf_path = os.path.join(get_sqlmap_pdf_directory(), f\"{current_user.id}_sqlmap_{timestamp}.pdf\")\n            if os.path.exists(pdf_path):\n                os.remove(pdf_path)\n            return error_message\n\n    except FileNotFoundError:\n        error_message = \"Error: sqlmap command not found. Ensure SQLMap is installed and in your system's PATH.\"\n        print(error_message)\n        return error_message\n    except Exception as e:\n        error_message = f\"An unexpected error occurred during SQLMap scan: {e}\"\n        print(error_message)\n        return error_message\n</code></pre> </li> </ul>"},{"location":"07_sqlmap_scanner/#dependencies","title":"Dependencies","text":"<ul> <li>SQLMap: An open-source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws. Must be installed and in the system's PATH.</li> <li>Python Libraries:<ul> <li><code>subprocess</code>: For running external commands (SQLMap).</li> <li><code>os</code>: For file system operations.</li> <li><code>glob</code>: For finding files matching a pattern.</li> <li><code>datetime</code>: For generating unique report filenames.</li> <li><code>flask</code>: For accessing the application's root path and configuration.</li> <li><code>flask_login</code>: For accessing the current user's information.</li> <li><code>reportlab</code>: For generating PDF reports (<code>pip install reportlab</code>).</li> </ul> </li> </ul>"},{"location":"07_sqlmap_scanner/#configuration","title":"Configuration","text":"<ul> <li><code>APP_ROOT</code>: Dynamically determines the application's root directory.</li> <li><code>COMPANY_LOGO</code>: Defines the path to the company logo image. The logo path is relative to <code>APP_ROOT</code>.</li> </ul>"},{"location":"07_sqlmap_scanner/#error-handling","title":"Error Handling","text":"<p>The script includes error handling in the following areas:</p> <ul> <li>SQLMap execution (handling <code>FileNotFoundError</code> and non-zero return codes).</li> <li>File processing errors during report generation.</li> <li>Cases where SQLMap fails to generate a raw report file.</li> </ul> <p>Errors are printed to the console and returned as error messages by the functions.</p>"},{"location":"07_sqlmap_scanner/#security-considerations","title":"Security Considerations","text":"<ul> <li>SQLMap Execution: SQLMap scans can be intrusive and may be detected by intrusion detection systems (IDS). Ensure you have permission to scan the target.</li> <li>Information Disclosure: SQLMap can extract sensitive information from databases. Handle the scan results and reports securely. Limit access to the generated reports to authorized personnel.</li> <li>Command Injection: Ensure you have proper access controls to prevent unauthorized users from executing SQLMap scans.</li> <li>Output Sanitization: While the code dumps SQLMap's report to a string, validate to ensure sensitive information is not inadvertently leaked through exception messages, or other unforeseen channels. Consider sanitizing this output.</li> </ul>"},{"location":"08_ssl_scanner/","title":"SSL Scanner","text":"<p>This document details the functionality of the file <code>ssl_scanner.py</code>, which automates SSL/TLS vulnerability scanning using <code>sslscan</code>. The script provides a function to execute <code>sslscan</code> against a specified hostname and generate a PDF report of the results.</p>"},{"location":"08_ssl_scanner/#overview","title":"Overview","text":"<p>The script performs the following steps:</p> <ol> <li>Defines Report Directory: Establishes the directory for storing SSL scan reports.</li> <li>Executes <code>sslscan</code>: Runs <code>sslscan</code> against the specified hostname, capturing its output.</li> <li>Generates PDF Report: Creates a formatted PDF report using <code>reportlab</code>, including the hostname, scan results, and a company logo. The reports are user-specific.</li> <li>Returns Report Path: Returns the full path to the generated PDF report.</li> </ol>"},{"location":"08_ssl_scanner/#functions","title":"Functions","text":""},{"location":"08_ssl_scanner/#1-get_ssl_report_directory","title":"1. <code>get_ssl_report_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the directory where SSL scan reports will be stored.</p> </li> <li> <p>Functionality:</p> <ul> <li>Defines the base directory path as <code>reports/ssl</code> within the Flask application's root directory.</li> <li>Uses <code>os.makedirs(report_dir_base, exist_ok=True)</code> to create the directory if it doesn't exist.</li> </ul> </li> <li> <p>Code Example:</p> <pre><code>import os\nfrom flask import current_app\n\ndef get_ssl_report_directory():\n    report_dir_base = os.path.join(current_app.root_path, 'reports', 'ssl')\n    os.makedirs(report_dir_base, exist_ok=True)\n    return report_dir_base\n</code></pre> </li> </ul>"},{"location":"08_ssl_scanner/#2-run_sslscanhostname-user_id","title":"2. <code>run_sslscan(hostname, user_id)</code>","text":"<ul> <li> <p>Purpose: Executes <code>sslscan</code> against the specified hostname.</p> </li> <li> <p>Functionality:</p> <ul> <li>Constructs the <code>sslscan</code> command.</li> <li>Executes the command using <code>subprocess.run</code>, capturing the output.</li> <li>If there is an error during the sslscan process, the stderr will be printed.</li> <li>Calls the <code>generate_sslscan_report_pdf</code> to generate a pdf report.</li> <li>Returns the path to the generated report or <code>None</code> if the scan failed.</li> <li>Includes error handling for <code>CalledProcessError</code> and <code>FileNotFoundError</code>.</li> </ul> </li> <li> <p>Code Example:</p> <pre><code>import subprocess\n\ndef run_sslscan(hostname, user_id):\n    try:\n        command = ['/usr/bin/sslscan', '--no-colour', hostname]\n        process = subprocess.run(command, capture_output=True, text=True, check=True)\n        sslscan_output = process.stdout\n        error_output = process.stderr\n\n        if error_output:\n            print(f\"sslscan error for {hostname}: {error_output}\")\n            return None\n\n        pdf_path = generate_sslscan_report_pdf(hostname, sslscan_output)\n        return pdf_path\n\n    except subprocess.CalledProcessError as e:\n        print(f\"Error running sslscan for {hostname}: {e}\")\n        print(f\"Stderr: {e.stderr}\")\n        return None\n    except FileNotFoundError:\n        print(\"Error: sslscan command not found. Ensure it is installed and in your system's PATH.\")\n        return None\n    except Exception as e:\n        print(f\"An unexpected error occurred during sslscan: {e}\")\n        return None\n</code></pre> </li> </ul>"},{"location":"08_ssl_scanner/#3-generate_sslscan_report_pdfhostname-report_text","title":"3. <code>generate_sslscan_report_pdf(hostname, report_text)</code>","text":"<ul> <li> <p>Purpose: Generates a PDF report from the <code>sslscan</code> output using the <code>reportlab</code> library.</p> </li> <li> <p>Functionality:</p> <ul> <li>Generates a unique filename for the PDF report.</li> <li>Initializes a <code>SimpleDocTemplate</code> for creating the PDF.</li> <li>Defines custom styles for the title, body text, and other elements of the report.</li> <li>Creates a <code>story</code> list to hold the content of the PDF.</li> <li>Adds a company logo at the beginning and the end of the report.</li> <li>Adds a title to the report.</li> <li>Includes a report information table containing the scan initiator (username), timestamp, and target hostname.</li> <li>Formats the <code>sslscan</code> output, splitting it into lines and adding each line as a paragraph to the story.</li> <li>Builds the PDF document.</li> </ul> </li> <li> <p>Code Example:</p> <pre><code>import os\nfrom flask import current_app\nfrom flask_login import current_user\nfrom datetime import datetime\nfrom reportlab.lib.pagesizes import letter\nfrom reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.lib.enums import TA_LEFT, TA_CENTER\nfrom reportlab.lib.units import inch\n\nAPP_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nCOMPANY_LOGO = os.path.join(APP_ROOT, 'static', 'images', 'company_logo.PNG')  # Replace with the actual filename\n\ndef generate_sslscan_report_pdf(hostname, report_text):\n    \"\"\"Generates an improved PDF report from SSLScan output with logo at the end, using username.\"\"\"\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    report_dir = get_ssl_report_directory()\n    pdf_filename = os.path.join(report_dir, f\"{current_user.id}_sslscan_{hostname.replace('.', '_')}_{timestamp}.pdf\")\n\n    doc = SimpleDocTemplate(pdf_filename, pagesize=letter)\n    styles = getSampleStyleSheet()\n\n    # Modern font style\n    modern_style = ParagraphStyle(\n        name='Modern',\n        parent=styles['Normal'],\n        fontName='Helvetica',\n        fontSize=14,\n        leading=16,\n        alignment=TA_LEFT,\n    )\n\n    title_style = ParagraphStyle(\n        name='Title',\n        parent=modern_style,\n        fontSize=18,\n        leading=22,\n        alignment=TA_CENTER,\n        fontName='Helvetica-Bold',\n    )\n\n    story = []\n\n    # --- Header ---\n    if os.path.exists(COMPANY_LOGO):\n        logo_header = Image(COMPANY_LOGO, width=1 * inch, height=1 * inch)\n        story.append(logo_header)\n        print(\"logo added in header\")\n    story.append(Spacer(1, 0.2 * inch))\n\n    # --- Title ---\n    title_text = f\"SSL/TLS Vulnerability Scan Report\"\n    story.append(Paragraph(title_text, title_style))\n    story.append(Spacer(1, 0.3 * inch))\n\n    # --- Report Information ---\n    report_info_data = [\n        [\"Scan Initiated By:\", f\"{current_user.username if current_user.is_authenticated else 'N/A'}\"],\n        [\"Timestamp:\", datetime.now().strftime('%Y-%m-%d %H:%M:%S')],\n        [\"Target Host:\", hostname],\n    ]\n    from reportlab.platypus import Table, TableStyle\n    report_info_table = Table(report_info_data, colWidths=[2 * inch, 5 * inch])\n    report_info_table.setStyle(TableStyle([\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTSIZE', (0, 0), (-1, -1), 12),\n        ('BOTTOMPADDING', (0, 0), (-1, 0), 6),\n    ]))\n    story.append(report_info_table)\n    story.append(Spacer(1, 0.3 * inch))\n\n    # --- Report Content ---\n    report_lines = report_text.splitlines()\n    for line in report_lines:\n        p = Paragraph(line, modern_style)\n        story.append(p)\n        story.append(Spacer(1, 0.1 * inch)) # Add a little space between lines\n\n    story.append(Spacer(1, 0.5 * inch))\n\n    # --- Logo at the End ---\n    if os.path.exists(COMPANY_LOGO):\n        logo_footer = Image(COMPANY_LOGO, width=1 * inch, height=1 * inch, hAlign='CENTER')\n        story.append(logo_footer)\n\n    doc.build(story)\n    return pdf_filename\n</code></pre> </li> </ul>"},{"location":"08_ssl_scanner/#dependencies","title":"Dependencies","text":"<ul> <li><code>sslscan</code>: A command-line tool for testing SSL/TLS configurations. Must be installed and in the system's PATH.</li> <li>Python Libraries:<ul> <li><code>subprocess</code>: For running external commands (<code>sslscan</code>).</li> <li><code>os</code>: For file system operations.</li> <li><code>datetime</code>: For generating unique report filenames.</li> <li><code>flask</code>: For accessing the application's root path and configuration.</li> <li><code>reportlab</code>: For generating PDF reports (<code>pip install reportlab</code>).</li> <li><code>flask_login</code>: Used for identifying current user.</li> </ul> </li> </ul>"},{"location":"08_ssl_scanner/#configuration","title":"Configuration","text":"<ul> <li><code>APP_ROOT</code>: Dynamically determines the application's root directory.</li> <li><code>COMPANY_LOGO</code>: Defines the path to the company logo image. The logo path is relative to <code>APP_ROOT</code>.</li> <li><code>sslscan</code> path: Hardcoded as <code>/usr/bin/sslscan</code>. Change the <code>command</code> variable in <code>run_sslscan</code> to the path of the program.</li> </ul>"},{"location":"08_ssl_scanner/#error-handling","title":"Error Handling","text":"<p>The script includes error handling for:</p> <ul> <li><code>sslscan</code> execution (handling <code>FileNotFoundError</code> and <code>CalledProcessError</code>).</li> <li>Unexpected exceptions during the scan process.</li> </ul> <p>Errors are printed to the console and returned as <code>None</code> by the <code>run_sslscan</code> function.</p>"},{"location":"08_ssl_scanner/#security-considerations","title":"Security Considerations","text":"<ul> <li><code>sslscan</code> Execution: Ensure <code>sslscan</code> is installed from a trusted source.</li> <li>Permissions: Verify correct permission of the <code>sslscan</code> executable is set.</li> <li>Information Disclosure: Limit access to the generated PDF reports to authorized personnel.</li> </ul>"},{"location":"09_prowler_scanner_aws/","title":"Prowler AWS Scanner","text":"<p>This document details the functionality of the file <code>prowler_scanner_aws.py</code>, which automates security assessments of Amazon Web Services (AWS) environments using Prowler. The script takes AWS access key ID, AWS secret access key, regions, and user ID as input, runs a Prowler scan, processes the generated HTML report (removing sensitive information and expanding \"read more\" sections), converts it to a PDF report with a company logo, and returns the filename of the resulting PDF report.</p>"},{"location":"09_prowler_scanner_aws/#overview","title":"Overview","text":"<p>The script performs the following steps:</p> <ol> <li>Receives Input: Takes AWS access key ID, AWS secret access key, a list of AWS regions, and user ID.</li> <li>Executes Prowler: Runs the Prowler security assessment tool against the specified AWS account and regions, utilizing the provided credentials for authentication.</li> <li>Processes HTML Report:<ul> <li>Expands the \"read more\" sections within the HTML report.</li> <li>Removes sensitive data from the HTML report.</li> </ul> </li> <li>Converts to PDF: Converts the processed HTML report to a PDF format, adding a company logo and title page using <code>pdfkit</code> and <code>PyMuPDF</code>.</li> <li>Returns Report Filename:  Returns the filename of the generated PDF report.</li> </ol>"},{"location":"09_prowler_scanner_aws/#functions","title":"Functions","text":""},{"location":"09_prowler_scanner_aws/#1-get_prowler_report_directory","title":"1. <code>get_prowler_report_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the directory where Prowler AWS reports will be stored.</p> </li> <li> <p>Functionality:</p> <ul> <li>Defines the base directory path as <code>reports/cloud_audit/aws_reports</code> within the Flask application's root directory.</li> <li>Uses <code>os.makedirs(report_dir_base, exist_ok=True)</code> to create the directory if it doesn't exist. <code>exist_ok=True</code> prevents errors if the directory already exists.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>def get_prowler_report_directory():\n    report_dir_base = os.path.join(current_app.root_path, 'reports', 'cloud_audit', 'aws_reports')\n    os.makedirs(report_dir_base, exist_ok=True)\n    return report_dir_base\n</code></pre> </li> </ul>"},{"location":"09_prowler_scanner_aws/#2-convert_html_to_pdfhtml_path-pdf_path-logo_path-report_typeprowler-aws-scan-report","title":"2. <code>convert_html_to_pdf(html_path, pdf_path, logo_path, report_type=\"Prowler AWS Scan Report\")</code>","text":"<ul> <li> <p>Purpose: Converts an HTML file to PDF, adds a company logo and title using <code>pdfkit</code> for the initial conversion and <code>PyMuPDF</code> for post-processing.</p> </li> <li> <p>Functionality:</p> <ul> <li>HTML to PDF Conversion (pdfkit):<ul> <li>Uses <code>pdfkit.from_file()</code> to convert the HTML file at <code>html_path</code> to a PDF file at <code>pdf_path</code>.</li> <li>Configures <code>pdfkit</code> with <code>wkhtmltopdf</code> executable path (obtained from <code>current_app.config</code> or defaults to <code>/usr/local/bin/wkhtmltopdf</code>).</li> <li>Sets PDF options like page size, margins, and encoding.</li> </ul> </li> <li>Post-Processing (PyMuPDF):<ul> <li>Opens the generated PDF using <code>fitz.open()</code>.</li> <li>Loads the company logo from <code>logo_path</code> using <code>fitz.Pixmap()</code>.</li> <li>Calculates the logo's dimensions and position to center it on the first page and last page.</li> <li>Adds a new blank page at the beginning and the end of the PDF.</li> <li>Inserts the logo and the report title (e.g., \"Prowler AWS Scan Report\") onto the added first and last page.</li> <li>Saves the modified PDF with incremental updates (<code>pdf_doc.saveIncr()</code>).  This is crucial to preserve the original PDF content while adding the new elements.</li> </ul> </li> <li>Error Handling: Uses <code>try...except</code> blocks to catch and re-raise exceptions related to both <code>pdfkit</code> and <code>PyMuPDF</code> processes, ensuring proper error handling and reporting.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import fitz\nimport pdfkit\n\ndef convert_html_to_pdf(html_path, pdf_path, logo_path, report_type=\"Prowler AWS Scan Report\"):\n    try:\n        config = pdfkit.configuration(wkhtmltopdf=current_app.config.get('WKHTMLTOPDF_EXECUTABLE', '/usr/local/bin/wkhtmltopdf'))\n        options = {\n            'page-size': 'A4',\n            'margin-top': '10mm',\n            'margin-right': '10mm',\n            'margin-bottom': '10mm',\n            'margin-left': '10mm',\n            'encoding': \"UTF-8\",\n        }\n        pdfkit.from_file(html_path, pdf_path, configuration=config, options=options)\n        print(f\"Successfully created PDF: {pdf_path}\")\n\n    except Exception as e:\n        msg = f\"Error converting HTML to PDF with pdfkit: {e}\"\n        print(msg)\n        raise Exception(msg)\n\n    try:\n        pdf_doc = fitz.open(pdf_path)\n        logo_path = os.path.join(current_app.root_path, logo_path)  # Absolute Path from Relative Path\n\n        if not os.path.exists(logo_path):\n            msg = f\"Logo not found at {logo_path}\"\n            print(msg)\n            raise FileNotFoundError(msg)\n\n        logo = fitz.Pixmap(logo_path)\n        logo_width_pt = 200  # Adjust as needed\n        aspect_ratio = logo.width / logo.height\n        logo_height_pt = logo_width_pt / aspect_ratio\n\n        # Create a new page as the first page\n        new_page = pdf_doc.new_page(width=pdf_doc[0].rect.width, height=pdf_doc[0].rect.height, pno=0)  # Insert as the *first* page\n        page_width = new_page.rect.width\n        page_height = new_page.rect.height\n\n        # Calculate total height of logo and title with gap\n        title_text = report_type  # Use the dynamic report type\n        font_size = 24\n        text_height = font_size  # Approximate text height\n\n        total_height = logo_height_pt + 30 + text_height  # Logo + gap + title\n\n        # Calculate starting Y position for vertical centering\n        start_y = (page_height - total_height) / 2\n\n        # Calculate logo position (centered horizontally, vertically aligned)\n        logo_x = (page_width - logo_width_pt) / 2\n        logo_y = start_y  # Distance from the top\n\n        logo_rect = fitz.Rect(logo_x, logo_y, logo_x + logo_width_pt, logo_y + logo_height_pt)\n        new_page.insert_image(logo_rect, pixmap=logo)\n\n        # Add a title (optional)\n\n        text_width = fitz.get_text_length(title_text, fontname=\"helvetica-bold\", fontsize=font_size)  # Use the get_text_length for exact positioning\n        text_x = (page_width - text_width) / 2\n        text_y = logo_y + logo_height_pt + 30  # Below the logo\n        new_page.insert_text((text_x, text_y), title_text, fontname=\"helvetica-bold\", fontsize=font_size, color=(0, 0, 0))  # Black text\n\n        # Add the same page to the end of the document\n        last_page = pdf_doc.new_page(width=pdf_doc[0].rect.width, height=pdf_doc[0].rect.height)  # Create new page with the same height and width with original file\n        logo_x = (page_width - logo_width_pt) / 2\n        logo_y = start_y  # Distance from the top\n\n        logo_rect = fitz.Rect(logo_x, logo_y, logo_x + logo_width_pt, logo_y + logo_height_pt)\n        last_page.insert_image(logo_rect, pixmap=logo)  # insert the logo to the last page\n\n        text_x = (page_width - text_width) / 2\n        text_y = logo_y + logo_height_pt + 30  # Below the logo\n        last_page.insert_text((text_x, text_y), title_text, fontname=\"helvetica-bold\", fontsize=font_size, color=(0, 0, 0))  # Black text #insert the text to the last page\n\n        pdf_doc.saveIncr()\n        print(f\"Successfully added new page and logo to PDF: {pdf_path}\")\n\n    except Exception as e:\n        msg = f\"Error processing PDF with PyMuPDF (fitz): {e}\"\n        print(msg)\n        raise Exception(msg)\n\n    return True\n</code></pre> </li> </ul>"},{"location":"09_prowler_scanner_aws/#3-remove_sensitive_informationhtml_content","title":"3. <code>remove_sensitive_information(html_content)</code>","text":"<ul> <li> <p>Purpose:  Removes sensitive information sections (\"Report Information\" and \"AWS Credentials\") from the HTML report before PDF conversion.</p> </li> <li> <p>Functionality:</p> <ul> <li>Parses the HTML content using <code>BeautifulSoup</code>.</li> <li>Finds all <code>div</code> elements with the class <code>card</code>.</li> <li>Iterates through these <code>div</code> elements and checks if their <code>card-header</code> contains \"Report Information\" or \"AWS Credentials\".</li> <li>If a matching <code>div</code> is found, it's removed from the HTML using <code>div.decompose()</code>.</li> <li>Returns the modified HTML content as a string.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>from bs4 import BeautifulSoup\n\ndef remove_sensitive_information(html_content):\n    soup = BeautifulSoup(html_content, 'html.parser')\n\n    divs_to_remove = soup.find_all('div', class_='card', recursive=True)\n\n    for div in divs_to_remove:\n        header = div.find('div', class_='card-header')\n        if header and ('Report Information' in header.text or 'AWS Credentials' in header.text):\n            div.decompose()\n\n    return str(soup)\n</code></pre> </li> </ul>"},{"location":"09_prowler_scanner_aws/#4-expand_read_more_linkshtml_content","title":"4. <code>expand_read_more_links(html_content)</code>","text":"<ul> <li> <p>Purpose: Expands all \"read more\" sections in the Prowler HTML report.</p> </li> <li> <p>Functionality:</p> <ul> <li>Parses the HTML content using <code>BeautifulSoup</code>.</li> <li>Finds all <code>&lt;p&gt;</code> tags with the class <code>show-read-more</code>.</li> <li>For each paragraph, extracts all text content and replaces the original paragraph's content with the combined text.</li> <li>Returns the modified HTML content as a string.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>from bs4 import BeautifulSoup\n\ndef expand_read_more_links(html_content):\n    soup = BeautifulSoup(html_content, 'html.parser')\n\n    paragraphs = soup.find_all('p', class_='show-read-more')\n\n    for paragraph in paragraphs:\n        text_content = ''.join(paragraph.stripped_strings)\n\n        paragraph.string = text_content\n\n    return str(soup)\n</code></pre> </li> </ul>"},{"location":"09_prowler_scanner_aws/#5-run_prowler_scanaws_access_key_id-aws_secret_access_key-regions-user_id","title":"5. <code>run_prowler_scan(aws_access_key_id, aws_secret_access_key, regions, user_id)</code>","text":"<ul> <li> <p>Purpose: Orchestrates the entire Prowler scanning process for AWS.</p> </li> <li> <p>Functionality:</p> <ul> <li>Setup:<ul> <li>Generates unique filenames for HTML and PDF reports based on the user ID and a timestamp.</li> <li>Defines paths for the reports and company logo.</li> </ul> </li> <li>Prowler Execution:<ul> <li>Constructs the Prowler command using <code>subprocess.run</code>. Key arguments include:<ul> <li><code>prowler aws</code>: Specifies the AWS assessment.</li> <li><code>--region</code>: The AWS region(s) to scan (space-separated).</li> <li><code>-M html</code>: Specifies HTML output format.</li> <li><code>--output-dir</code>: The directory to store the report.</li> <li><code>--output-filename</code>: The name of the HTML report file (without extension).</li> </ul> </li> <li>Sets the <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables for Prowler to authenticate with AWS.</li> <li>Executes the Prowler command and captures its output.</li> <li>Checks the return code of the <code>subprocess.run</code> call. Returns error messages for specific return codes (1 for invalid credentials, 2 for invalid region).</li> </ul> </li> <li>Report Processing:<ul> <li>Reads the generated HTML report.</li> <li>Calls <code>expand_read_more_links()</code> to expand the \"read more\" sections in the HTML.</li> <li>Calls <code>remove_sensitive_information()</code> to sanitize the HTML.</li> </ul> </li> <li>PDF Conversion:<ul> <li>Calls <code>convert_html_to_pdf()</code> to convert the sanitized HTML to a PDF report, adding the company logo and title.</li> </ul> </li> <li>Cleanup:<ul> <li>Deletes the HTML file.</li> <li>Unsets the <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables to avoid leaving credentials exposed.</li> </ul> </li> <li>Error Handling:  Includes extensive error handling for file operations, Prowler execution, and report conversion. Returns specific error messages to the caller if any step fails.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import subprocess\nimport os\nfrom datetime import datetime\nfrom flask import current_app\nfrom bs4 import BeautifulSoup\nimport pdfkit\nimport fitz\n\ndef run_prowler_scan(aws_access_key_id, aws_secret_access_key, regions, user_id):\n    report_dir = get_prowler_report_directory()\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    html_report_filename = f\"{user_id}_cloud_audit_prowler_aws_{timestamp}.html\"\n    pdf_report_filename = f\"{user_id}_cloud_audit_prowler_aws_{timestamp}.pdf\"\n    html_report_path = os.path.join(report_dir, html_report_filename)\n    pdf_report_path = os.path.join(report_dir, pdf_report_filename)\n    COMPANY_LOGO_PATH = 'static/images/company_logo.PNG'\n\n\n    try:\n        command = [\n            \"prowler\", \"aws\",\n            \"--region\", \" \".join(regions),\n            \"-M\", \"html\",\n            \"--output-dir\", report_dir,\n            \"--output-filename\", os.path.splitext(html_report_filename)[0]\n        ]\n\n        env = os.environ.copy()\n        env.update({\n            \"AWS_ACCESS_KEY_ID\": aws_access_key_id,\n            \"AWS_SECRET_ACCESS_KEY\": aws_secret_access_key\n        })\n\n        result = subprocess.run(command, env=env, capture_output=True, text=True)\n\n        if result.returncode == 1:\n            return \"Error: Invalid AWS credentials provided.\"\n        elif result.returncode == 2:\n            return f\"Error: Invalid AWS region specified: {', '.join(regions)}.\"\n\n        if not os.path.exists(html_report_path):\n            raise Exception(\"Prowler did not generate the HTML report.\")\n\n        # Post-process the HTML to remove sensitive information\n        with open(html_report_path, 'r', encoding='utf-8') as f:\n            html_content = f.read()\n\n        # Expand all \"read more\" links\n        expanded_html_content = expand_read_more_links(html_content)\n\n        modified_html_content = remove_sensitive_information(expanded_html_content)\n\n        # Save the processed HTML *overwriting* the raw HTML file\n        with open(html_report_path, 'w', encoding='utf-8') as f:\n            f.write(modified_html_content)\n\n        if not convert_html_to_pdf(html_report_path, pdf_report_path, COMPANY_LOGO_PATH,\n                                       report_type=\"Prowler AWS Scan Report\"):\n            raise Exception(\"PDF conversion failed using pdfkit.\")\n\n        if not os.path.exists(pdf_report_path):\n            raise Exception(\"PDF conversion failed.\")\n\n        return os.path.basename(pdf_report_filename)\n\n    except FileNotFoundError as e:\n        print(f\"Error: {e}. Ensure Prowler or wkhtmltopdf is installed.\")\n        return \"Error: Ensure Prowler or wkhtmltopdf is installed.\"\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return \"An unexpected error occurred during the scan.\"\n\n    finally:\n\n        if os.path.exists(html_report_path):\n            os.remove(html_report_path)\n\n        # Remove the environment variables added, if they exist\n        if \"AWS_ACCESS_KEY_ID\" in os.environ:\n            del os.environ[\"AWS_ACCESS_KEY_ID\"]\n        if \"AWS_SECRET_ACCESS_KEY\" in os.environ:\n            del os.environ[\"AWS_SECRET_ACCESS_KEY\"]\n</code></pre> </li> </ul>"},{"location":"09_prowler_scanner_aws/#dependencies","title":"Dependencies","text":"<ul> <li>Prowler: A security assessment tool for cloud environments (specifically AWS in this case). Must be installed and configured.</li> <li>Python Libraries:<ul> <li><code>subprocess</code>: For running external commands (Prowler).</li> <li><code>os</code>: For file system operations.</li> <li><code>datetime</code>: For generating unique report filenames.</li> <li><code>flask</code>: For accessing the application's root path and configuration.</li> <li><code>BeautifulSoup4</code>: For parsing and manipulating HTML content (<code>pip install beautifulsoup4</code>).</li> <li><code>pdfkit</code>: For converting HTML to PDF (<code>pip install pdfkit</code>). Requires <code>wkhtmltopdf</code> to be installed.</li> <li><code>PyMuPDF (fitz)</code>: For adding the company logo and title to the PDF (<code>pip install pymupdf</code>).</li> </ul> </li> <li>AWS CLI (Optional): While the script uses environment variables for credentials, having the AWS CLI installed and configured can be helpful for debugging or managing AWS resources.</li> <li>wkhtmltopdf: A command-line tool required by <code>pdfkit</code> to convert HTML to PDF. It needs to be installed separately. Follow the instructions at https://wkhtmltopdf.org/downloads.html for your operating system.</li> </ul>"},{"location":"09_prowler_scanner_aws/#configuration","title":"Configuration","text":"<ul> <li><code>WKHTMLTOPDF_EXECUTABLE</code>: A configuration setting in the Flask application that specifies the path to the <code>wkhtmltopdf</code> executable. If not set, it defaults to <code>/usr/local/bin/wkhtmltopdf</code>.  This is accessed via <code>current_app.config.get('WKHTMLTOPDF_EXECUTABLE', '/usr/local/bin/wkhtmltopdf')</code>.</li> <li><code>COMPANY_LOGO_PATH</code>: Specifies the relative path to the company logo image within the Flask application's static files directory (e.g., <code>'static/images/company_logo.PNG'</code>).</li> </ul>"},{"location":"09_prowler_scanner_aws/#error-handling","title":"Error Handling","text":"<p>The script includes robust error handling using <code>try...except...finally</code> blocks. It handles potential errors during:</p> <ul> <li>File operations.</li> <li>Prowler execution (checking the return code and specific error messages).</li> <li>HTML report processing.</li> <li>PDF conversion (both <code>pdfkit</code> and <code>PyMuPDF</code>).</li> <li>Missing dependencies (e.g., Prowler or <code>wkhtmltopdf</code> not installed).</li> </ul> <p>Errors are logged and also returned as error messages to the caller.</p>"},{"location":"09_prowler_scanner_aws/#security-considerations","title":"Security Considerations","text":"<ul> <li>AWS Credentials: The script handles sensitive AWS credentials (access key ID and secret access key). It's critical to:<ul> <li>Store the credentials securely before passing them to the script. Avoid hardcoding them. Use environment variables, configuration files, or secret management services.</li> <li>Ensure that the environment variables are unset after use to prevent accidental exposure.</li> </ul> </li> <li>HTML Sanitization: Removing sensitive information from the HTML report before PDF conversion is crucial to prevent data leaks in the final report.</li> <li>Region Selection: Limit the regions scanned to only those necessary to reduce the attack surface and scan time.</li> </ul>"},{"location":"10_prowler_scanner_gcp/","title":"Prowler GCP Scanner","text":"<p>This document details the functionality of the file <code>prowler_scanner_gcp.py</code>, which automates security assessments of Google Cloud Platform (GCP) environments using Prowler. The script takes a GCP service account key, project ID, and user ID as input, runs a Prowler scan, processes the generated HTML report (removing sensitive information), converts it to a PDF report with a company logo, and returns the filename of the resulting PDF report.</p>"},{"location":"10_prowler_scanner_gcp/#overview","title":"Overview","text":"<p>The script performs the following steps:</p> <ol> <li>Receives Input: Takes GCP service account key content, project ID, and user ID.</li> <li>Executes Prowler: Runs the Prowler security assessment tool against the specified GCP project, utilizing the provided service account for authentication.</li> <li>Processes HTML Report: Modifies the generated HTML report to remove sensitive data.</li> <li>Converts to PDF: Converts the processed HTML report to a PDF format, adding a company logo and title page using <code>pdfkit</code> and <code>PyMuPDF</code>.</li> <li>Returns Report Filename:  Returns the filename of the generated PDF report.</li> </ol>"},{"location":"10_prowler_scanner_gcp/#functions","title":"Functions","text":""},{"location":"10_prowler_scanner_gcp/#1-get_prowler_report_directory","title":"1. <code>get_prowler_report_directory()</code>","text":"<ul> <li> <p>Purpose:  Determines and creates the directory where Prowler reports will be stored.</p> </li> <li> <p>Functionality:</p> <ul> <li>Defines the base directory path as <code>reports/cloud_audit/gcp_reports</code> within the Flask application's root directory.</li> <li>Uses <code>os.makedirs(report_dir_base, exist_ok=True)</code> to create the directory if it doesn't exist.  <code>exist_ok=True</code> prevents errors if the directory already exists.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>def get_prowler_report_directory():\n    report_dir_base = os.path.join(current_app.root_path, 'reports', 'cloud_audit', 'gcp_reports')\n    os.makedirs(report_dir_base, exist_ok=True)\n    return report_dir_base\n</code></pre> </li> </ul>"},{"location":"10_prowler_scanner_gcp/#2-convert_html_to_pdfhtml_path-pdf_path-logo_path-report_typeprowler-gcp-scan-report","title":"2. <code>convert_html_to_pdf(html_path, pdf_path, logo_path, report_type=\"Prowler GCP Scan Report\")</code>","text":"<ul> <li> <p>Purpose: Converts an HTML file to PDF, adds a company logo and title using <code>pdfkit</code> for the initial conversion and <code>PyMuPDF</code> for post-processing.</p> </li> <li> <p>Functionality:</p> <ul> <li>HTML to PDF Conversion (pdfkit):<ul> <li>Uses <code>pdfkit.from_file()</code> to convert the HTML file at <code>html_path</code> to a PDF file at <code>pdf_path</code>.</li> <li>Configures <code>pdfkit</code> with <code>wkhtmltopdf</code> executable path (obtained from <code>current_app.config</code> or defaults to <code>/usr/local/bin/wkhtmltopdf</code>).</li> <li>Sets PDF options like page size, margins, and encoding.</li> </ul> </li> <li>Post-Processing (PyMuPDF):<ul> <li>Opens the generated PDF using <code>fitz.open()</code>.</li> <li>Loads the company logo from <code>logo_path</code> using <code>fitz.Pixmap()</code>.</li> <li>Calculates the logo's dimensions and position to center it on the first page and last page.</li> <li>Adds a new blank page at the beginning and the end of the PDF.</li> <li>Inserts the logo and the report title (e.g., \"Prowler GCP Scan Report\") onto the added first and last page.</li> <li>Saves the modified PDF with incremental updates (<code>pdf_doc.saveIncr()</code>).  This is crucial to preserve the original PDF content while adding the new elements.</li> </ul> </li> <li>Error Handling: Uses <code>try...except</code> blocks to catch and re-raise exceptions related to both <code>pdfkit</code> and <code>PyMuPDF</code> processes, ensuring proper error handling and reporting.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import fitz\nimport pdfkit\n\ndef convert_html_to_pdf(html_path, pdf_path, logo_path, report_type=\"Prowler GCP Scan Report\"):\n    try:\n        config = pdfkit.configuration(wkhtmltopdf=current_app.config.get('WKHTMLTOPDF_EXECUTABLE', '/usr/local/bin/wkhtmltopdf'))\n        options = {\n            'page-size': 'A4',\n            'margin-top': '10mm',\n            'margin-right': '10mm',\n            'margin-bottom': '10mm',\n            'margin-left': '10mm',\n            'encoding': \"UTF-8\",\n        }\n        pdfkit.from_file(html_path, pdf_path, configuration=config, options=options)\n        print(f\"Successfully created PDF: {pdf_path}\")\n\n    except Exception as e:\n        msg = f\"Error converting HTML to PDF with pdfkit: {e}\"\n        print(msg)\n        raise Exception(msg)\n\n    try:\n        pdf_doc = fitz.open(pdf_path)\n        logo_path = os.path.join(current_app.root_path, logo_path)  # Absolute Path from Relative Path\n\n        if not os.path.exists(logo_path):\n            msg = f\"Logo not found at {logo_path}\"\n            print(msg)\n            raise FileNotFoundError(msg)\n\n        logo = fitz.Pixmap(logo_path)\n        logo_width_pt = 200  # Adjust as needed\n        aspect_ratio = logo.width / logo.height\n        logo_height_pt = logo_width_pt / aspect_ratio\n\n        # Create a new page as the first page\n        new_page = pdf_doc.new_page(width=pdf_doc[0].rect.width, height=pdf_doc[0].rect.height, pno=0)  # Insert as the *first* page\n        page_width = new_page.rect.width\n        page_height = new_page.rect.height\n\n        # Calculate total height of logo and title with gap\n        title_text = report_type  # Use the dynamic report type\n        font_size = 24\n        text_height = font_size  # Approximate text height\n\n        total_height = logo_height_pt + 30 + text_height  # Logo + gap + title\n\n        # Calculate starting Y position for vertical centering\n        start_y = (page_height - total_height) / 2\n\n        # Calculate logo position (centered horizontally, vertically aligned)\n        logo_x = (page_width - logo_width_pt) / 2\n        logo_y = start_y  # Distance from the top\n\n        logo_rect = fitz.Rect(logo_x, logo_y, logo_x + logo_width_pt, logo_y + logo_height_pt)\n        new_page.insert_image(logo_rect, pixmap=logo)\n\n        # Add a title (optional)\n\n        text_width = fitz.get_text_length(title_text, fontname=\"helvetica-bold\", fontsize=font_size)  # Use the get_text_length for exact positioning\n        text_x = (page_width - text_width) / 2\n        text_y = logo_y + logo_height_pt + 30  # Below the logo\n        new_page.insert_text((text_x, text_y), title_text, fontname=\"helvetica-bold\", fontsize=font_size, color=(0, 0, 0))  # Black text\n\n        # Add the same page to the end of the document\n        last_page = pdf_doc.new_page(width=pdf_doc[0].rect.width, height=pdf_doc[0].rect.height)  # Create new page with the same height and width with original file\n        logo_x = (page_width - logo_width_pt) / 2\n        logo_y = start_y  # Distance from the top\n\n        logo_rect = fitz.Rect(logo_x, logo_y, logo_x + logo_width_pt, logo_y + logo_height_pt)\n        last_page.insert_image(logo_rect, pixmap=logo)  # insert the logo to the last page\n\n        text_x = (page_width - text_width) / 2\n        text_y = logo_y + logo_height_pt + 30  # Below the logo\n        last_page.insert_text((text_x, text_y), title_text, fontname=\"helvetica-bold\", fontsize=font_size, color=(0, 0, 0))  # Black text #insert the text to the last page\n\n        pdf_doc.saveIncr()\n        print(f\"Successfully added new page and logo to PDF: {pdf_path}\")\n\n    except Exception as e:\n        msg = f\"Error processing PDF with PyMuPDF (fitz): {e}\"\n        print(msg)\n        raise Exception(msg)\n\n    return True\n</code></pre> </li> </ul>"},{"location":"10_prowler_scanner_gcp/#3-remove_sensitive_informationhtml_content","title":"3. <code>remove_sensitive_information(html_content)</code>","text":"<ul> <li> <p>Purpose:  Removes sensitive information sections (\"Report Information\" and \"GCP Credentials\") from the HTML report before PDF conversion.</p> </li> <li> <p>Functionality:</p> <ul> <li>Parses the HTML content using <code>BeautifulSoup</code>.</li> <li>Finds all <code>div</code> elements with the class <code>card</code>.</li> <li>Iterates through these <code>div</code> elements and checks if their <code>card-header</code> contains \"Report Information\" or \"GCP Credentials\".</li> <li>If a matching <code>div</code> is found, it's removed from the HTML using <code>div.decompose()</code>.</li> <li>Returns the modified HTML content as a string.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>from bs4 import BeautifulSoup\n\ndef remove_sensitive_information(html_content):\n    soup = BeautifulSoup(html_content, 'html.parser')\n\n    divs_to_remove = soup.find_all('div', class_='card', recursive=True)\n\n    for div in divs_to_remove:\n        header = div.find('div', class_='card-header')\n        if header and ('Report Information' in header.text or 'GCP Credentials' in header.text):\n            div.decompose()\n\n    return str(soup)\n</code></pre> </li> </ul>"},{"location":"10_prowler_scanner_gcp/#4-run_prowler_scankey_file_content-project_id-user_id","title":"4. <code>run_prowler_scan(key_file_content, project_id, user_id)</code>","text":"<ul> <li> <p>Purpose: Orchestrates the entire Prowler scanning process.</p> </li> <li> <p>Functionality:</p> <ul> <li>Setup:<ul> <li>Generates unique filenames for HTML and PDF reports based on the user ID and a timestamp.</li> <li>Creates a temporary file to store the GCP service account key content.</li> <li>Sets the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable to point to the temporary key file, allowing Prowler to authenticate with GCP.</li> </ul> </li> <li>Prowler Execution:<ul> <li>Constructs the Prowler command using <code>subprocess.run</code>.  Key arguments include:<ul> <li><code>prowler gcp</code>: Specifies the GCP assessment.</li> <li><code>--project-id</code>: The GCP project ID to scan.</li> <li><code>-M html</code>:  Specifies HTML output format.</li> <li><code>--output-dir</code>: The directory to store the report.</li> <li><code>--output-filename</code>: The name of the HTML report file (without extension).</li> </ul> </li> <li>Executes the Prowler command and captures its output.</li> <li>Return code handling: checks if Prowler ran successfully (return code 0) or had findings/errors but still generated a report (return code 3). If the result return code is anything else other than 0 or 3, then returns with an error.</li> </ul> </li> <li>Report Processing:<ul> <li>Reads the generated HTML report.</li> <li>Calls <code>remove_sensitive_information()</code> to sanitize the HTML.</li> <li>Overwrites the original HTML file with the sanitized content.</li> </ul> </li> <li>PDF Conversion:<ul> <li>Calls <code>convert_html_to_pdf()</code> to convert the sanitized HTML to a PDF report, adding the company logo and title.</li> </ul> </li> <li>Cleanup:<ul> <li>Deletes the temporary key file.</li> <li>Deletes the HTML file</li> <li>Unsets the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable to avoid leaving sensitive credentials exposed.</li> </ul> </li> <li>Error Handling:  Includes extensive error handling for file operations, Prowler execution, HTML processing, and PDF conversion. Returns specific error messages to the caller if any step fails.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import subprocess\nimport os\nimport tempfile\nimport logging\nfrom datetime import datetime\nfrom flask import current_app\n\ndef run_prowler_scan(key_file_content, project_id, user_id):\n    report_dir = get_prowler_report_directory()\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    html_report_filename = f\"{user_id}_cloud_audit_prowler_gcp_{timestamp}.html\"\n    pdf_report_filename = f\"{user_id}_cloud_audit_prowler_gcp_{timestamp}.pdf\"\n    html_report_path = os.path.join(report_dir, html_report_filename)\n    pdf_report_path = os.path.join(report_dir, pdf_report_filename)\n    COMPANY_LOGO_PATH = 'static/images/company_logo.PNG'\n\n    try:\n        with tempfile.NamedTemporaryFile(mode='w', suffix=\".json\", delete=True) as temp_key_file:\n            temp_key_file.write(key_file_content)\n            temp_key_file.flush()\n\n            env = os.environ.copy()\n            env['GOOGLE_APPLICATION_CREDENTIALS'] = temp_key_file.name\n\n            command = [\n                \"prowler\", \"gcp\",\n                \"--project-id\", project_id,\n                \"-M\", \"html\",\n                \"--output-dir\", report_dir,\n                \"--output-filename\", os.path.splitext(html_report_filename)[0]\n            ]\n\n            result = subprocess.run(command, env=env, capture_output=True, text=True)\n            print(command)\n            print(result)\n\n            if result.returncode not in [0, 3]:\n                error_message = f\"Prowler scan failed with return code {result.returncode}: {result.stderr}\"\n                logging.error(error_message)\n                return f\"Error: Prowler scan failed. Check logs for details.\"\n\n            if not os.path.exists(html_report_path):\n                raise Exception(\"Prowler did not generate the HTML report.\")\n\n            with open(html_report_path, 'r', encoding='utf-8') as f:\n                html_content = f.read()\n\n            modified_html_content = remove_sensitive_information(html_content)\n\n            with open(html_report_path, 'w', encoding='utf-8') as f:\n                f.write(modified_html_content)\n\n            if not convert_html_to_pdf(html_report_path, pdf_report_path, COMPANY_LOGO_PATH,\n                                       report_type=\"Prowler GCP Scan Report\"):\n                raise Exception(\"PDF conversion failed using pdfkit.\")\n\n            if not os.path.exists(pdf_report_path):\n                raise Exception(\"PDF conversion failed.\")\n\n            return os.path.basename(pdf_report_filename)\n\n    except FileNotFoundError as e:\n        print(f\"Error: {e}. Ensure Prowler or wkhtmltopdf is installed.\")\n        return \"Error: Ensure Prowler or wkhtmltopdf is installed.\"\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return f\"An unexpected error occurred during the scan: {str(e)}\"\n\n    finally:\n        if os.path.exists(html_report_path):\n            os.remove(html_report_path)\n\n        if 'GOOGLE_APPLICATION_CREDENTIALS' in os.environ:\n            del os.environ['GOOGLE_APPLICATION_CREDENTIALS']\n</code></pre> </li> </ul>"},{"location":"10_prowler_scanner_gcp/#dependencies","title":"Dependencies","text":"<ul> <li>Prowler: A security assessment tool for cloud environments (specifically GCP in this case).  Must be installed and configured.</li> <li>Python Libraries:<ul> <li><code>subprocess</code>: For running external commands (Prowler).</li> <li><code>os</code>: For file system operations.</li> <li><code>tempfile</code>: For creating temporary files to store the service account key.</li> <li><code>json</code>: For handling JSON data (service account key).</li> <li><code>logging</code>: For logging errors and debugging information.</li> <li><code>datetime</code>: For generating unique report filenames.</li> <li><code>flask</code>: For accessing the application's root path and configuration.</li> <li><code>BeautifulSoup4</code>: For parsing and manipulating HTML content. Install with: <code>pip install beautifulsoup4</code></li> <li><code>pdfkit</code>: For converting HTML to PDF. Install with: <code>pip install pdfkit</code>.  Requires <code>wkhtmltopdf</code> to be installed.</li> <li><code>PyMuPDF (fitz)</code>: For adding the company logo and title to the PDF. Install with: <code>pip install pymupdf</code></li> </ul> </li> <li>wkhtmltopdf:  A command-line tool required by <code>pdfkit</code> to convert HTML to PDF.  It needs to be installed separately.  Follow the instructions at https://wkhtmltopdf.org/downloads.html for your operating system.</li> </ul>"},{"location":"10_prowler_scanner_gcp/#configuration","title":"Configuration","text":"<ul> <li><code>WKHTMLTOPDF_EXECUTABLE</code>:  A configuration setting in the Flask application that specifies the path to the <code>wkhtmltopdf</code> executable.  If not set, it defaults to <code>/usr/local/bin/wkhtmltopdf</code>. This is accessed via <code>current_app.config.get('WKHTMLTOPDF_EXECUTABLE', '/usr/local/bin/wkhtmltopdf')</code>.</li> <li><code>COMPANY_LOGO_PATH</code>: Specifies the relative path to the company logo image within the Flask application's static files directory (e.g., <code>'static/images/company_logo.PNG'</code>).</li> </ul>"},{"location":"10_prowler_scanner_gcp/#error-handling","title":"Error Handling","text":"<p>The script includes robust error handling using <code>try...except...finally</code> blocks. It handles potential errors during:</p> <ul> <li>File creation and writing.</li> <li>Prowler execution (checking the return code).</li> <li>HTML report processing.</li> <li>PDF conversion (both <code>pdfkit</code> and <code>PyMuPDF</code>).</li> <li>Missing dependencies (e.g., Prowler or <code>wkhtmltopdf</code> not installed).</li> </ul> <p>Errors are logged using the <code>logging</code> module and are also returned as error messages to the caller.</p>"},{"location":"10_prowler_scanner_gcp/#security-considerations","title":"Security Considerations","text":"<ul> <li>Service Account Key: The script handles sensitive service account keys.  It's critical to:<ul> <li>Store the service account key content securely before passing it to the script.</li> <li>Ensure that the temporary key file is deleted immediately after use (using <code>tempfile.NamedTemporaryFile(delete=True)</code>).</li> <li>Unset the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable after use to prevent accidental exposure.</li> </ul> </li> <li>HTML Sanitization:  Removing sensitive information from the HTML report before PDF conversion is crucial to prevent data leaks in the final report.</li> </ul>"},{"location":"11_cloudsploit_scanner_azure/","title":"CloudSploit Azure Scanner","text":"<p>This document details the functionality of the file <code>cloudsploit_scanner_azure.py</code>, which automates security assessments of Azure environments using CloudSploit. The script takes Azure subscription ID, tenant ID, client ID, client secret, and user ID as input, runs a CloudSploit scan, converts the generated CSV report to HTML and then PDF format, adds a company logo and title page, and returns the filename of the resulting PDF report.</p>"},{"location":"11_cloudsploit_scanner_azure/#overview","title":"Overview","text":"<p>The script performs the following steps:</p> <ol> <li>Receives Input: Takes Azure subscription ID, tenant ID, client ID, client secret, and user ID.</li> <li>Executes CloudSploit: Runs the CloudSploit security assessment tool against the specified Azure environment, utilizing the provided credentials for authentication.</li> <li>Converts CSV to HTML: Converts the generated CSV report into a basic HTML table format.</li> <li>Converts HTML to PDF: Converts the generated HTML to a PDF format, adding a company logo and title page using <code>pdfkit</code> and <code>PyMuPDF</code>.</li> <li>Returns Report Filename:  Returns the filename of the generated PDF report.</li> </ol>"},{"location":"11_cloudsploit_scanner_azure/#functions","title":"Functions","text":""},{"location":"11_cloudsploit_scanner_azure/#1-get_cloudsploit_report_directory","title":"1. <code>get_cloudsploit_report_directory()</code>","text":"<ul> <li> <p>Purpose: Determines and creates the directory where CloudSploit Azure reports will be stored.</p> </li> <li> <p>Functionality:</p> <ul> <li>Defines the base directory path as <code>reports/cloud_audit/azure_reports</code> within the Flask application's root directory.</li> <li>Uses <code>os.makedirs(report_dir_base, exist_ok=True)</code> to create the directory if it doesn't exist.  <code>exist_ok=True</code> prevents errors if the directory already exists.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>def get_cloudsploit_report_directory():\n    report_dir_base = os.path.join(current_app.root_path, 'reports', 'cloud_audit', 'azure_reports')\n    os.makedirs(report_dir_base, exist_ok=True)\n    return report_dir_base\n</code></pre> </li> </ul>"},{"location":"11_cloudsploit_scanner_azure/#2-convert_csv_to_html_tablecsv_file_path-output_file_path","title":"2. <code>convert_csv_to_html_table(csv_file_path, output_file_path)</code>","text":"<ul> <li> <p>Purpose: Converts a CSV file generated by CloudSploit into a simple HTML table.  It focuses on report data and removes any visual styling related to logos.</p> </li> <li> <p>Functionality:</p> <ul> <li>Reads the CSV file specified by <code>csv_file_path</code>.</li> <li>Extracts the header row from the CSV to create the HTML table headers (<code>&lt;th&gt;</code>).</li> <li>Iterates through the remaining rows in the CSV to create the HTML table data rows (<code>&lt;tr&gt;</code> and <code>&lt;td&gt;</code>).</li> <li>Wraps the generated table content in a basic HTML structure with minimal styling.</li> <li>Writes the complete HTML to the specified <code>output_file_path</code>.</li> <li>Returns the HTML content as a string.</li> <li>Includes a <code>try...except</code> block to handle potential file reading or processing errors.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import csv\n\ndef convert_csv_to_html_table(csv_file_path, output_file_path):\n    try:\n        html_content = f\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html lang=\"en\"&gt;\n        &lt;head&gt;\n            &lt;meta charset=\"UTF-8\"&gt;\n            &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n            &lt;title&gt;CloudSploit Azure Scan Report&lt;/title&gt;\n            &lt;style&gt;\n                body {{\n                    font-family: Arial, sans-serif;\n                }}\n                table {{\n                    width: 100%;\n                    border-collapse: collapse;\n                    margin-top: 1rem;\n                }}\n                th, td {{\n                    border: 1px solid #ddd;\n                    padding: 8px;\n                    text-align: left;\n                }}\n                th {{\n                    background-color: #f0f0f0;\n                }}\n                tr:nth-child(even) {{\n                    background-color: #f9f9f9;\n                }}\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;div class=\"section\"&gt;\n\n                &lt;table&gt;\n                    &lt;thead&gt;\n                        &lt;tr&gt;\n        \"\"\"\n        with open(csv_file_path, 'r', newline='') as csvfile:\n            reader = csv.reader(csvfile)\n            header = next(reader)  # Get the header row\n            for col in header:\n                html_content += f'&lt;th&gt;{col}&lt;/th&gt;'\n            html_content += \"\"\"\n                        &lt;/tr&gt;\n                    &lt;/thead&gt;\n                    &lt;tbody&gt;\n            \"\"\"\n            for row in reader:\n                html_content += \"&lt;tr&gt;\"\n                for cell in row:\n                    html_content += f'&lt;td&gt;{cell}&lt;/td&gt;'\n                html_content += \"&lt;/tr&gt;\"\n            html_content += \"\"\"\n                    &lt;/tbody&gt;\n                &lt;/table&gt;\n            &lt;/div&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n        with open(output_file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(html_content)\n        return html_content\n    except Exception as e:\n        return f\"Error converting CSV to HTML: {e}\"\n</code></pre> </li> </ul>"},{"location":"11_cloudsploit_scanner_azure/#3-convert_html_to_pdfhtml_path-pdf_path-logo_path-title","title":"3. <code>convert_html_to_pdf(html_path, pdf_path, logo_path, title)</code>","text":"<ul> <li> <p>Purpose: Converts an HTML file to PDF, adds a company logo and title using <code>pdfkit</code> for the initial conversion and <code>PyMuPDF</code> for post-processing.</p> </li> <li> <p>Functionality:</p> <ul> <li>HTML to PDF Conversion (pdfkit):<ul> <li>Uses <code>pdfkit.from_file()</code> to convert the HTML file at <code>html_path</code> to a PDF file at <code>pdf_path</code>.</li> <li>Configures <code>pdfkit</code> with <code>wkhtmltopdf</code> executable path (defaults to <code>/usr/local/bin/wkhtmltopdf</code>).  Important: This path should be configurable or dynamically determined.</li> <li>Sets PDF options like page size, margins, encoding, and explicitly enables local file access to allow <code>wkhtmltopdf</code> to access local resources within the HTML (such as CSS or images).</li> </ul> </li> <li>Post-Processing (PyMuPDF):<ul> <li>Opens the generated PDF using <code>fitz.open()</code>.</li> <li>Loads the company logo from <code>logo_path</code> using <code>fitz.Pixmap()</code>. <code>logo_path</code> is joined with <code>current_app.root_path</code> to create an absolute path.</li> <li>If the logo file is present calculates the logo's dimensions and position to center it on the first and last page.</li> <li>Adds a new blank page at the beginning and the end of the PDF.</li> <li>Inserts the logo and the report title onto the added first and last page.</li> <li>Saves the modified PDF with incremental updates (<code>pdf_doc.saveIncr()</code>). This is crucial to preserve the original PDF content while adding the new elements.</li> </ul> </li> <li>Error Handling: Uses <code>try...except</code> blocks to catch exceptions related to both <code>pdfkit</code> and <code>PyMuPDF</code> processes, ensuring proper error handling and reporting.  Raises the exception if the logo is not found after building the path.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import fitz\nimport pdfkit\nimport os\nfrom flask import current_app\n\ndef convert_html_to_pdf(html_path, pdf_path, logo_path, title):\n    \"\"\"\n    Converts an HTML file to a PDF using pdfkit and adds a logo and title to the first and last pages.\n\n    Args:\n        html_path (str): The path to the HTML file.\n        pdf_path (str): The path to save the generated PDF file.\n        logo_path (str): Path to the company logo image (relative to the Flask app).\n        title (str): The title/report type to display on the cover page (e.g., \"CloudSploit Azure Audit Report\").\n    \"\"\"\n    try:\n        # Configure pdfkit to point to the wkhtmltopdf executable\n        config = pdfkit.configuration(wkhtmltopdf='/usr/local/bin/wkhtmltopdf')  # Update this path if necessary\n\n        # Convert HTML file to PDF\n        options = {\n            'page-size': 'A4',\n            'margin-top': '10mm',\n            'margin-right': '10mm',\n            'margin-bottom': '10mm',\n            'margin-left': '10mm',\n            'encoding': \"UTF-8\",\n            'enable-local-file-access': ''\n        }\n        pdfkit.from_file(html_path, pdf_path, configuration=config, options=options)\n        print(f\"Successfully created PDF: {pdf_path}\")\n\n    except Exception as e:\n        msg = f\"Error converting HTML to PDF using pdfkit: {e}\"\n        print(msg)\n        raise Exception(msg) # Re-raise to signal failure\n\n    # Add logo and title using PyMuPDF\n    try:\n        pdf_doc = fitz.open(pdf_path)\n        logo_path = os.path.join(current_app.root_path, logo_path)  # Absolute Path from Relative Path\n        if os.path.exists(logo_path):\n            logo = fitz.Pixmap(logo_path)\n            logo_width_pt = 200  # Adjust as needed\n            aspect_ratio = logo.width / logo.height\n            logo_height_pt = logo_width_pt / aspect_ratio\n\n            # Create a new page as the first page\n            new_page = pdf_doc.new_page(width=pdf_doc[0].rect.width, height=pdf_doc[0].rect.height,\n                                            pno=0)  # Insert as the *first* page\n            page_width = new_page.rect.width\n            page_height = new_page.rect.height\n\n            # Calculate total height of logo and title with gap\n            font_size = 24\n            text_height = font_size  # Approximate text height\n\n            total_height = logo_height_pt + 30 + text_height  # Logo + gap + title\n\n            # Calculate starting Y position for vertical centering\n            start_y = (page_height - total_height) / 2\n\n            # Calculate logo position (centered horizontally, vertically aligned)\n            logo_x = (page_width - logo_width_pt) / 2\n            logo_y = start_y  # Distance from the top\n\n            logo_rect = fitz.Rect(logo_x, logo_y, logo_x + logo_width_pt, logo_y + logo_height_pt)\n            new_page.insert_image(logo_rect, pixmap=logo)\n\n            # Add a title (optional)\n\n            text_width = fitz.get_text_length(title, fontname=\"helvetica-bold\",\n                                                fontsize=font_size)  # Use the get_text_length for exact positioning\n            text_x = (page_width - text_width) / 2\n            text_y = logo_y + logo_height_pt + 30  # Below the logo\n            new_page.insert_text((text_x, text_y), title, fontname=\"helvetica-bold\", fontsize=font_size,\n                                    color=(0, 0, 0))  # Black text\n\n            # Add the same page to the end of the document\n            last_page = pdf_doc.new_page(width=pdf_doc[0].rect.width, height=pdf_doc[0].rect.height)  # Create new page with the same height and width with original file\n            logo_x = (page_width - logo_width_pt) / 2\n            logo_y = start_y  # Distance from the top\n\n            logo_rect = fitz.Rect(logo_x, logo_y, logo_x + logo_width_pt, logo_y + logo_height_pt)\n            last_page.insert_image(logo_rect, pixmap=logo)  # insert the logo to the last page\n\n            text_x = (page_width - text_width) / 2\n            text_y = logo_y + logo_height_pt + 30  # Below the logo\n            last_page.insert_text((text_x, text_y), title, fontname=\"helvetica-bold\", fontsize=font_size,\n                                    color=(0, 0, 0))  # Black text #insert the text to the last page\n\n            pdf_doc.saveIncr()\n            print(f\"Successfully added new page and logo to PDF: {pdf_path}\")\n\n        else:\n            msg = f\"Warning: Logo not found at {logo_path}\"\n            print(msg)\n            raise FileNotFoundError(msg)\n\n    except Exception as e:\n        msg = f\"Error adding new page and logo to PDF: {str(e)}\"\n        print(msg)\n        raise Exception(msg)  # Re-raise the exception\n\n    return True  # Indicate success\n</code></pre> </li> </ul>"},{"location":"11_cloudsploit_scanner_azure/#4-run_cloudsploit_scan_azureazure_subscription_id-azure_tenant_id-azure_client_id-azure_client_secret-user_id","title":"4. <code>run_cloudsploit_scan_azure(azure_subscription_id, azure_tenant_id, azure_client_id, azure_client_secret, user_id)</code>","text":"<ul> <li> <p>Purpose: Orchestrates the entire CloudSploit Azure scanning process.</p> </li> <li> <p>Functionality:</p> <ul> <li>Setup:<ul> <li>Generates unique filenames for CSV, HTML and PDF reports based on the user ID and a timestamp.</li> <li>Defines paths for the reports, credentials file and company logo.</li> <li>Creates a JSON file containing Azure credentials, which CloudSploit uses for authentication.</li> </ul> </li> <li>CloudSploit Execution:<ul> <li>Constructs the CloudSploit command using <code>subprocess.run</code>. Key arguments include:<ul> <li><code>node</code>:  The NodeJS runtime.</li> <li><code>os.path.join(cloudsploit_dir, 'index.js')</code>:  Path to the CloudSploit entry point.</li> <li><code>--cloud azure</code>: Specifies the Azure assessment.</li> <li><code>--config</code>:  Specifies the path to the CloudSploit config file.</li> <li><code>--console none</code>:  Disables console output.</li> <li><code>--csv</code>: The path to the output CSV report.</li> <li><code>--ignore-ok</code>:  Instructs CloudSploit to ignore certain \"OK\" results.</li> </ul> </li> <li>Executes the CloudSploit command and captures its output.</li> <li>Checks the return code of the <code>subprocess.run</code> call. A non-zero return code indicates an error.</li> <li>Verify if the csv report is generated after the scan or not.</li> </ul> </li> <li>Report Processing:<ul> <li>Calls <code>convert_csv_to_html_table()</code> to convert the CSV report to HTML.</li> </ul> </li> <li>PDF Conversion:<ul> <li>Calls <code>convert_html_to_pdf()</code> to convert the HTML to a PDF report, adding the company logo and title.</li> </ul> </li> <li>Cleanup:<ul> <li>Deletes the Azure credentials file.</li> <li>Deletes the CSV and HTML report files.</li> </ul> </li> <li>Error Handling:  Includes extensive error handling for file operations, CloudSploit execution, and report conversion. Returns specific error messages to the caller if any step fails.</li> </ul> </li> <li> <p>Code Snippet:</p> <pre><code>import subprocess\nimport os\nfrom datetime import datetime\nfrom flask import current_app\nimport csv\nimport json\n\ndef run_cloudsploit_scan_azure(azure_subscription_id, azure_tenant_id, azure_client_id, azure_client_secret, user_id):\n    report_dir = get_cloudsploit_report_directory()\n    cloudsploit_dir = os.path.join(os.path.dirname(current_app.root_path), 'cloudsploit')\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    report_base_filename = f\"{user_id}_cloud_audit_cloudsploit_azure_{timestamp}\"\n    csv_report_filename = f\"{report_base_filename}.csv\"\n    html_report_filename = f\"{report_base_filename}.html\"\n    pdf_report_filename = f\"{report_base_filename}.pdf\"\n\n    csv_report_path = os.path.join(report_dir, csv_report_filename)\n    html_report_path = os.path.join(report_dir, html_report_filename)\n    pdf_report_path = os.path.join(report_dir, pdf_report_filename)\n    credentials_file = os.path.join(cloudsploit_dir, \"azure_credentials.json\")\n    logo_path = os.path.join('static', 'images', 'company_logo.PNG') # Relative path to logo.  The function now uses the absolute path\n    title = \"CloudSploit Azure Scan Report\"  # Dynamic report type\n\n    try:\n        # Create Azure credentials file\n        azure_credentials = {\n            \"ApplicationID\": azure_client_id,\n            \"KeyValue\": azure_client_secret,\n            \"DirectoryID\": azure_tenant_id,\n            \"SubscriptionID\": azure_subscription_id,\n        }\n        with open(credentials_file, \"w\") as f:\n            json.dump(azure_credentials, f, indent=4)\n\n        # Construct the CloudSploit command for CSV output\n        command = [\n            \"node\",\n            os.path.join(cloudsploit_dir, 'index.js'),\n            \"--cloud\", \"azure\",\n            \"--config\", os.path.join(cloudsploit_dir, 'config.js'),\n            \"--console\", \"none\",\n            \"--csv\", csv_report_path,\n            \"--ignore-ok\"\n        ]\n\n        result = subprocess.run(command, capture_output=True, text=True)\n\n        if result.returncode != 0:\n            error_message = f\"CloudSploit Azure scan failed. Error: {result.stderr.strip()} Output: {result.stdout.strip()}\"\n            return error_message\n\n        # Check for report generation\n        if not os.path.exists(csv_report_path):\n            error_message = \"CloudSploit did not generate the CSV report.\"\n            raise Exception(error_message)\n\n        # Convert CSV to HTML\n        try:\n            html_content = convert_csv_to_html_table(csv_report_path, html_report_path)\n        except Exception as e:\n            error_message = f\"Error converting CSV to HTML: {e}\"\n            return error_message\n\n        # Convert HTML to PDF and add logo/title\n        try:\n            if not convert_html_to_pdf(html_report_path, pdf_report_path, logo_path, title):\n                return \"Error during PDF Conversion and/or Cover Page/Ending Page Addition\"\n\n        except Exception as e:\n            error_message = f\"Error converting HTML to PDF: {e}\"\n            return error_message\n\n        return os.path.basename(pdf_report_filename)\n\n    except FileNotFoundError as e:\n        error_message = f\"Error: {e}. Ensure CloudSploit and wkhtmltopdf are installed and in your PATH. Also, ensure the company logo exists at the specified path. CloudSploit path: /home/kali/Desktop/cloudsploit/index.js\"\n        return error_message\n    except Exception as e:\n        error_message = f\"An unexpected error occurred: {e}\"\n        return error_message\n    finally:\n        # Clean up the credentials file\n        if os.path.exists(credentials_file):\n            os.remove(credentials_file)\n\n        # Clean up the CSV and HTML report files\n        if os.path.exists(csv_report_path):\n            os.remove(csv_report_path)\n        if os.path.exists(html_report_path):\n            os.remove(html_report_path)\n</code></pre> </li> </ul>"},{"location":"11_cloudsploit_scanner_azure/#dependencies","title":"Dependencies","text":"<ul> <li>CloudSploit:  A security assessment tool for cloud environments (specifically Azure in this case). Must be installed and configured, typically using NodeJS.</li> <li>NodeJS:  CloudSploit is a NodeJS application, so NodeJS and NPM (Node Package Manager) must be installed.</li> <li>Python Libraries:<ul> <li><code>subprocess</code>: For running external commands (CloudSploit).</li> <li><code>os</code>: For file system operations.</li> <li><code>datetime</code>: For generating unique report filenames.</li> <li><code>flask</code>: For accessing the application's root path and configuration.</li> <li><code>csv</code>: For reading and processing CSV files.</li> <li><code>json</code>: For handling JSON data (Azure credentials).</li> <li><code>pdfkit</code>: For converting HTML to PDF (<code>pip install pdfkit</code>). Requires <code>wkhtmltopdf</code> to be installed.</li> <li><code>PyMuPDF (fitz)</code>: For adding the company logo and title to the PDF (<code>pip install pymupdf</code>).</li> </ul> </li> <li>wkhtmltopdf:  A command-line tool required by <code>pdfkit</code> to convert HTML to PDF. It needs to be installed separately. Follow the instructions at https://wkhtmltopdf.org/downloads.html for your operating system.</li> </ul>"},{"location":"11_cloudsploit_scanner_azure/#configuration","title":"Configuration","text":"<ul> <li><code>WKHTMLTOPDF_EXECUTABLE</code>: A configuration setting (though not explicitly used in the provided code - it's hardcoded as <code>/usr/local/bin/wkhtmltopdf</code> within the <code>convert_html_to_pdf</code> function).  In a production environment, this should be configurable in the Flask application to specify the path to the <code>wkhtmltopdf</code> executable.</li> <li><code>COMPANY_LOGO_PATH</code>: Specifies the relative path to the company logo image within the Flask application's static files directory (e.g., <code>'static/images/company_logo.PNG'</code>).</li> <li><code>cloudsploit_dir</code>: This path, <code>os.path.join(os.path.dirname(current_app.root_path), 'cloudsploit')</code>, should point to where the CloudSploit code is installed. Ensure this path is correct.</li> </ul>"},{"location":"11_cloudsploit_scanner_azure/#error-handling","title":"Error Handling","text":"<p>The script includes robust error handling using <code>try...except...finally</code> blocks. It handles potential errors during:</p> <ul> <li>File creation and writing (credentials file).</li> <li>CloudSploit execution (checking the return code).</li> <li>CSV to HTML conversion.</li> <li>PDF conversion (both <code>pdfkit</code> and <code>PyMuPDF</code>).</li> <li>Missing dependencies (e.g., CloudSploit or <code>wkhtmltopdf</code> not installed).</li> <li>Logo file not found.</li> </ul> <p>Errors are returned as error messages to the caller.</p>"},{"location":"11_cloudsploit_scanner_azure/#security-considerations","title":"Security Considerations","text":"<ul> <li>Azure Credentials: The script handles sensitive Azure credentials (client ID, client secret, tenant ID, subscription ID). It's crucial to:<ul> <li>Store the credentials securely before passing them to the script.</li> <li>Ensure that the credentials file is deleted immediately after use.</li> </ul> </li> <li>Path Handling:  Carefully validate and sanitize any user-provided paths to prevent path traversal vulnerabilities.</li> <li>Subprocess Execution: While <code>subprocess.run</code> is used, be aware of potential command injection vulnerabilities if any part of the command arguments are derived from untrusted sources (which doesn't appear to be the case here, but it's a general security principle).</li> </ul>"},{"location":"12_views/","title":"Directory: <code>app/views</code>","text":"<p>Purpose: This directory contains the view functions (route handlers) that define the application's behavior. These functions handle user requests, interact with models, and render HTML templates.</p> <p>Files:</p> <ul> <li> <p><code>analyze_report_ai.py</code>:</p> <ul> <li>Description: Analyzes scan reports using the Google Gemini model. Extracts text from PDFs, masks PII, and generates insights.</li> <li>Key Functionality: Uses <code>GeminiReportAnalyzer</code> class to handle PDF processing, PII masking, and Gemini API interactions.</li> <li>Dependencies: <code>google.generativeai</code>, <code>pypdf</code>, <code>flask</code>, <code>re</code></li> </ul> </li> <li> <p><code>auth.py</code>:</p> <ul> <li>Description: Handles user authentication routes (login, registration, password reset, update password, email verification, etc.).</li> <li>Key Functionality: Manages user registration, login, logout, password reset, and email verification using Flask-Login, <code>bcrypt</code>, and itsdangerous for secure token generation and email verification process.</li> <li>Dependencies: <code>flask</code>, <code>flask_login</code>, <code>bcrypt</code>, <code>forms</code>, <code>models</code>, <code>flask_mail</code>, <code>itsdangerous</code>, <code>requests</code>, <code>os</code></li> </ul> </li> <li> <p><code>genai.py</code>:</p> <ul> <li>Description: Contains routes and functions for interacting with the Gemini AI model for security report analysis.</li> <li>Key Functionality: Handles uploading reports, analyzing them with Gemini, and managing chat sessions for follow-up questions.</li> <li>Dependencies: <code>flask</code>, <code>flask_login</code>, <code>google.generativeai</code>, <code>werkzeug</code>, <code>os</code>, <code>logging</code>, <code>app.analyze_report_ai</code></li> </ul> </li> <li> <p><code>main.py</code>:</p> <ul> <li>Description: Contains the main application routes (home page, profile page, about page, scan page, contact page, pricing page, download report page, etc.).</li> <li>Key Functionality: Handles core web application routes, manages vulnerability scans, provides report downloads, and facilitates user communication via contact forms.</li> <li>Dependencies: <code>flask</code>, <code>flask_login</code>, <code>werkzeug</code>, <code>os</code>, <code>requests</code>, <code>app.scanners.*</code>, <code>app.forms</code>, <code>app.models</code>, <code>app.analyze_report_ai</code>, <code>flask_mail</code>, <code>logging</code>, <code>json</code></li> </ul> </li> <li> <p><code>payments.py</code>:</p> <ul> <li>Description: Handles payment-related functionality using the PayPal API (creates orders, captures payments, handles cancellations, updates subscriptions).</li> <li>Key Functionality: Integrates with PayPal to create and capture payments, manage user subscriptions, and record payment transactions in the database. Includes retry logic and error handling for API interactions.</li> <li>Dependencies: <code>flask</code>, <code>flask_login</code>, <code>app.extensions</code>, <code>app.models</code>, <code>datetime</code>, <code>os</code>, <code>requests</code>, <code>logging</code>, <code>uuid</code>, <code>time</code>, <code>random</code>, <code>sqlalchemy.exc</code></li> </ul> </li> <li> <p><code>__init__.py</code>:</p> <ul> <li>Description: Makes the <code>views</code> directory a Python package.</li> <li>Key Functionality: Registers blueprints for the view modules (e.g., <code>auth</code>, <code>main</code>, <code>payments</code>, <code>genai</code>).</li> <li>Dependencies: <code>flask</code></li> </ul> </li> </ul>"},{"location":"13_views_init/","title":"File: <code>views/__init__.py</code>","text":"<p>Purpose: This file acts as the initialization module for the <code>views</code> package. Its primary responsibility is to import and expose Flask blueprint instances, enabling organized and modular handling of application routes and views.</p> <p>Overview:</p> <p>The <code>views/__init__.py</code> file performs these core functions:</p> <ul> <li>Blueprint Imports: Imports blueprint objects that are defined in separate modules within the <code>views</code> package. These imported blueprints are <code>main_bp</code> (from <code>main.py</code>), <code>auth_bp</code> (from <code>auth.py</code>), <code>payments_bp</code> (from <code>payments.py</code>), and <code>genai_bp</code> (from <code>genai.py</code>).</li> <li>Blueprint Exposure: Defines the <code>all</code> variable, which serves as a list specifying the blueprints that should be made publicly accessible when using a wildcard import (<code>from views import *</code>). This ensures controlled access to the package's contents.</li> </ul> <p>Key Components and Functionality:</p> <ul> <li> <p>Blueprint Imports: The file imports <code>Blueprint</code> instances from their respective modules. <code>Blueprint</code> objects in Flask are used to organize a group of related views and other code.</p> <pre><code>from .main import main_bp\nfrom .auth import auth_bp\nfrom .payments import payments_bp\nfrom .genai import genai_bp\n</code></pre> </li> <li> <p><code>all</code> Variable:  This list defines the public API of the <code>views</code> package.  It lists the names of the blueprints that are intended for external use. This enforces encapsulation by preventing unwanted names from being imported when using a wildcard import.  Using <code>__all__</code> (double underscore) instead of <code>all</code> is more common for defining the public API of a module, though <code>all</code> will also work.</p> <pre><code>all = ['main_bp', 'auth_bp', 'payments_bp', 'genai_bp']\n</code></pre> </li> </ul> <p>Explanation of Blueprints:</p> <ul> <li><code>main_bp</code>: Handles core application views accessible to all users, such as the homepage and general information pages.  This Blueprint is defined in the <code>main.py</code> module.</li> <li><code>auth_bp</code>: Responsible for managing user authentication-related views, including login, registration, password management, and profile settings. This Blueprint is defined in the <code>auth.py</code> module.</li> <li><code>payments_bp</code>: Handles payment-related views, subscription management, and integration with payment gateways. This Blueprint is defined in the <code>payments.py</code> module.</li> <li><code>genai_bp</code>: Manages views associated with generative AI functionalities in the application. This Blueprint is defined in the <code>genai.py</code> module.</li> </ul> <p>Package Structure:</p> <p>The <code>views</code> package is structured to promote code organization and separation of concerns. Each core area of the application (main views, authentication, payments, AI) has its dedicated module with a corresponding Blueprint. The <code>__init__.py</code> file consolidates these Blueprints and defines the package's public API.</p> <p>How it Works:</p> <p>When the <code>views</code> package is imported, the Python interpreter executes the code within <code>views/__init__.py</code>. This results in the importing of the Blueprint instances and the creation of the <code>all</code> list, thereby making those blueprints ready for registration within the main Flask application instance. The main Flask app would then use <code>app.register_blueprint()</code> to activate these blueprints and make their routes available.</p>"},{"location":"14_main/","title":"File: <code>main.py</code>","text":"<p>Purpose: This file defines the main Flask blueprint for the VulnScanAI web application. It handles core routes related to the homepage, user profiles, vulnerability scanning, report downloads, and contact/demo requests. It serves as the primary entry point for the application's core functionalities.</p> <p>Overview:</p> <p>The <code>main.py</code> file handles essential tasks such as:</p> <ul> <li>Routing: Defining URL endpoints and associating them with specific functions.</li> <li>Templating: Rendering HTML pages using the Jinja2 templating engine.</li> <li>User Authentication: Handling user login and authorization using Flask-Login.</li> <li>Vulnerability Scanning: Integrating with various security scanners to perform assessments.</li> <li>Report Management: Downloading generated reports.</li> <li>Form Handling: Processing user input from forms for contact, demo requests, etc.</li> <li>Email Integration: Sending emails for confirmation or admin notification.</li> </ul> <p>Key Components and Functionality:</p> <ul> <li> <p>Blueprint Creation: Creates a Flask Blueprint named <code>main_bp</code> to organize the routes and related resources.</p> <pre><code>from flask import Blueprint\n\nmain_bp = Blueprint('main', __name__)\n</code></pre> </li> <li> <p>Report Directories: Defines constants for the base directories where reports are stored.</p> <pre><code>import os\n\nUPLOAD_FOLDER = os.path.join(os.path.dirname(main_bp.root_path), 'uploads')\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\nMAX_FILE_SIZE_BYTES = 5 * 1024 * 1024  # 5MB\n\nNMAP_REPORT_BASE = os.path.join(os.path.dirname(main_bp.root_path), 'reports', 'nmap')\nSSL_REPORT_BASE = os.path.join(os.path.dirname(main_bp.root_path), 'reports', 'ssl')\nMOBSF_REPORT_BASE = os.path.join(os.path.dirname(main_bp.root_path), 'reports', 'mobsf')\nCLOUD_AUDIT_REPORT_BASE = os.path.join(os.path.dirname(main_bp.root_path), 'reports', 'cloud_audit')\nSQLMAP_REPORT_BASE = os.path.join(os.path.dirname(main_bp.root_path), 'reports', 'sqlmap', 'pdf_results')\nZAP_REPORT_BASE = os.path.join(os.path.dirname(main_bp.root_path), 'reports', 'zap') # Define ZAP report base\nNIKTO_REPORT_BASE = os.path.join(os.path.dirname(main_bp.root_path), 'reports', 'nikto')\nNIKTO_RESULTS_DIR = os.path.join(NIKTO_REPORT_BASE, 'nikto_results')\nAUTHENTICATED_NIKTO_RESULTS_DIR = os.path.join(NIKTO_REPORT_BASE, 'authenticated_nikto_results')\n</code></pre> </li> <li> <p>URL Validation: Implements helper functions for validating URLs and IP addresses.</p> <pre><code>import re\n\ndef is_valid_url(url):\n    \"\"\"Simple URL validation.\"\"\"\n    url_pattern = re.compile(r'^(https?://)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*/?$')\n    return bool(url_pattern.match(url))\n\ndef is_valid_ip(ip):\n    \"\"\"Simple IPv4 validation, excluding suspicious IPs.\"\"\"\n    ip_pattern = re.compile(r'^(\\d{1,3}\\.){3}\\d{1,3}$')\n    if not ip_pattern.match(ip):\n        return False\n\n    parts = ip.split('.')\n    if not all(0 &lt;= int(part) &lt;= 255 for part in parts):\n        return False\n\n    # Exclude all zeros, all 255s, and other potentially suspicious ranges\n    if all(part == '0' for part in parts) or all(part == '255' for part in parts):\n        return False\n\n    return True\n</code></pre> </li> <li> <p><code>home()</code> Route: Handles requests to the application's homepage.</p> <pre><code>from flask import render_template\n\n@main_bp.route('/')\ndef home():\n    return render_template('home.html')\n</code></pre> </li> <li> <p><code>profile()</code> Route: Displays the user profile information, requires authentication.</p> <pre><code>from flask import render_template\nfrom flask_login import login_required, current_user\n\n@main_bp.route('/profile')\n@login_required\ndef profile():\n    user = current_user\n    # ... (code to retrieve subscription details) ...\n    return render_template('profile.html', subscriptions=subscriptions)\n</code></pre> </li> <li> <p><code>get_user_subscription_details()</code>: A helper function to determine a user's subscription</p> <pre><code>from app.models import User, Subscription\nfrom app.extensions import db\n\ndef get_user_subscription_details(user_id):\n\"\"\"\nRetrieves the user's subscription details, including the subscription plan name.\n\nArgs:\n    user_id (int): The ID of the user.\n\nReturns:\n    tuple: (subscription_id, subscription_name) or (None, None) if not found.\n\"\"\"\nuser = User.query.get(user_id)\nif user and user.subscription_id:\n    subscription = Subscription.query.get(user.subscription_id)\n    if subscription:\n        return user.subscription_id, subscription.plan_name\n    else:\n        return None, None\nreturn None, None\n</code></pre> </li> <li> <p><code>get_allowed_scan_options()</code>: A helper function to determine a user's allowed scans</p> <pre><code>def get_allowed_scan_options(subscription_name):\n\"\"\"\nReturns a dictionary of allowed scan options based on the subscription plan.\n\"\"\"\nall_options = {\n    \"Network Scanning\": {\n        \"port_scan\": \"Port Scan\",\n        \"os_detection\": \"OS Detection\",\n        \"aggressive_scan\": \"Aggressive Scan\",\n        \"tcp_syn_scan\": \"TCP SYN Scan\",\n        \"fragmented_scan\": \"Fragmented Packet Scan\",\n    },\n    \"Web Application Scanning\": {\n        \"zap_scan\": \"ZAP Scan\",\n        \"zap_authenticated_scan\": \"ZAP Authenticated Scan\",\n        \"nikto_scan\": \"Nikto Scan\",\n        \"nikto_authenticated_deep\": \"Nikto Authenticated Scan\",\n    },\n    \"Mobile Application Scans\": {\n        \"mobsf_scan\": \"MobSF Scan\",\n    },\n    \"Database Scans\": {\n        \"sqlmap_scan\": \"SQLMap Scan\",\n    },\n    \"SSL Scans\": {\n        \"ssl_scan\": \"SSL/TLS Vulnerability Scan (SSLScan)\",\n    },\n    \"Cloud Audits\": {\n        \"prowler_aws_scan\": \"Prowler AWS Audit\",\n        \"cloudsploit_azure_scan\": \"CloudSploit Azure Audit\",\n        \"prowler_gcp_scan\": \"Prowler GCP Audit\"\n    },\n}\nif subscription_name == \"Free Security\":\n    allowed_options = {\n        \"Network Scanning\": all_options[\"Network Scanning\"],  # Allow all network scans\n        \"SSL Scans\": {\"ssl_scan\": \"SSL/TLS Vulnerability Scan (SSLScan)\"},\n    }\nelif subscription_name == \"Pro Security\":\n    allowed_options = {\n        \"Network Scanning\": all_options[\"Network Scanning\"],\n        \"Web Application Scanning\": {\n            \"zap_scan\": \"ZAP Scan\",\n            \"zap_authenticated_scan\": \"ZAP Authenticated Scan\",\n            \"nikto_scan\": \"Nikto Scan\",\n            \"nikto_authenticated_deep\": \"Nikto Authenticated Scan\",\n        },\n        \"Database Scans\": {\"sqlmap_scan\": \"SQLMap Scan\"},\n        \"SSL Scans\": {\"ssl_scan\": \"SSL/TLS Vulnerability Scan (SSLScan)\"},\n    }\nelif subscription_name == \"Premium Security\":\n    allowed_options = all_options\nelse:\n    allowed_options = {}\n\nreturn allowed_options\n</code></pre> </li> <li> <p><code>scan()</code> Route: Handles vulnerability scanning requests. It is a central function for various scan types.</p> <pre><code>from flask import request, jsonify\nfrom flask_login import login_required, current_user\nimport app.scanners.nmap_scanner as nmap_scanner #Example scanner import\nimport os #to get the base name\nfrom app.models import User, Subscription #for access control\n# And other scanner modules...\n\n@main_bp.route('/scan', methods=['GET', 'POST'])\n@login_required\ndef scan():\n    user_id = current_user.id\n    subscription_id, subscription_name = get_user_subscription_details(user_id)\n    if request.method == 'POST':\n    scan_category = request.form.get('scan_category')\n    scan_type = request.form.get('scan_type')\n    print(f\"Scan Type: {scan_type}, Category: {scan_category}\")\n     # Get allowed options for the user's subscription\n    allowed_options = get_allowed_scan_options(subscription_name)\n\n    # Check if the requested scan_type is allowed for the user's subscription.\n    if (\n        scan_category not in allowed_options or\n        scan_type not in allowed_options[scan_category]\n    ):\n        return jsonify({'error': 'You are not authorized to perform this scan.'}), 403\n\n\n    if scan_category == 'Network Scanning':\n        target = request.form.get('target')\n        nmap_options = request.form.get('nmap_options')\n        ports = request.form.get('ports') # For TCP SYN Scan\n\n        if not target:\n            return jsonify({'error': 'Target is required for Network Scan.'}), 400\n\n        if scan_type in ['port_scan', 'tcp_syn_scan', 'aggressive_scan', 'os_detection', 'fragmented_scan']:\n            if not is_valid_url(target) and not is_valid_ip(target):\n                return jsonify({'error': 'Please enter a valid URL or IP address for the target.'}), 400\n\n            print(target)\n            if target == '127.0.0.1':\n                target = request.remote_addr\n            print(target)\n\n        try:\n            pdf_path = None\n            if scan_type == 'port_scan':\n                pdf_path = nmap_scanner.run_port_scan(target=target, options=nmap_options, user_id=current_user.id)\n            elif scan_type == 'tcp_syn_scan':\n                pdf_path = nmap_scanner.run_tcp_syn_scan(target=target, ports=ports, options=nmap_options, user_id=current_user.id)\n            elif scan_type == 'aggressive_scan':\n                pdf_path = nmap_scanner.run_aggressive_scan(target=target, options=nmap_options, user_id=current_user.id)\n            elif scan_type == 'os_detection':\n                pdf_path = nmap_scanner.run_os_detection(target=target, options=nmap_options, user_id=current_user.id)\n            elif scan_type == 'fragmented_scan':\n                pdf_path = nmap_scanner.run_fragmented_packet_scan(target=target, options=nmap_options, user_id=current_user.id)\n\n            if pdf_path:\n                return jsonify({'pdf_path': os.path.basename(pdf_path)}), 200\n            else:\n                return jsonify({'error': 'Failed to generate scan report.'}), 500\n\n        except Exception as e:\n            return jsonify({'error': str(e)}), 500\n\n\n    # and so on for other scan categories\n</code></pre> <pre><code>It validates that user has the necessary level and authentication\nProvides proper error messages for missing authentication for the type of scans selected.\n</code></pre> </li> <li> <p><code>download_report()</code> Route: Handles requests to download previously generated scan reports.</p> <pre><code>from flask import send_from_directory, flash, redirect, url_for\nimport os #required to find files on OS\n\n@main_bp.route('/download_report/&lt;path:filename&gt;')\n@login_required\ndef download_report(filename):\n# ... (complex logic to determine the correct report directory) ...\n    if os.path.exists(report_path):\n        return send_from_directory(report_dir, filename, as_attachment=True)\n    else:\n        flash('Report not found.', 'danger')\n        return redirect(url_for('main.scan'))\n</code></pre> <ul> <li>Has checks at every stage to verify that the scanned file is present before trying to download it.</li> <li>Uses complex logic to manage files from a variety of subfolders.</li> </ul> </li> <li> <p><code>about()</code> Route: Renders the \"About Us\" page.</p> <pre><code>from flask import render_template\n\n@main_bp.route('/about')\ndef about():\n    return render_template('about.html')\n</code></pre> </li> <li> <p><code>pricing()</code> Route: Renders the \"Pricing\" page.</p> <pre><code>from flask import render_template\nfrom flask_login import current_user\n\n@main_bp.route('/pricing')\ndef pricing():\n    return render_template('pricing.html', is_authenticated=current_user.is_authenticated)\n</code></pre> </li> <li> <p><code>contact_us()</code> Route: Handles the \"Contact Us\" form submission, including reCAPTCHA verification and sending email notifications.</p> <pre><code>from flask import request, flash, url_for, redirect, current_app, render_template\nfrom flask_mail import Message\nimport requests #required to get verification\nfrom app.forms import ContactForm\n\n@main_bp.route('/contact_us', methods=['GET', 'POST'])\ndef contact_us():\n    form = ContactForm()\n    # ... (form validation, reCAPTCHA verification, and email sending logic) ...\n    return render_template('contact_us.html', form=form)\n</code></pre> <p>Includes steps to:</p> <ul> <li>Handle the rendering for the contact us page.</li> <li>Validates all parts of the response.</li> <li>Sends a message to the client acknowledging receipt.</li> </ul> </li> <li> <p><code>request_demo()</code> Route: Handles the \"Request Demo\" form submission, including reCAPTCHA verification and sending email notifications.</p> <pre><code>from flask import request, flash, url_for, redirect, current_app, render_template\nfrom flask_mail import Message\nimport requests\nfrom app.forms import RequestDemoForm\n\n@main_bp.route('/request_demo', methods=['GET', 'POST'])\ndef request_demo():\n    form = RequestDemoForm()\n    # ... (similar form handling logic to `contact_us()`) ...\n    return render_template('request_demo.html', form=form)\n</code></pre> <ul> <li>It uses the anti-fraud technique reCAPTCHA.</li> <li>sends a message to the system administrator.</li> <li>sends a message to the client acknowledging receipt.</li> </ul> </li> </ul> <p>Dependencies:</p> <ul> <li><code>os</code>: For file system operations.</li> <li><code>re</code>: For regular expressions (URL validation).</li> <li><code>datetime</code>: Unnecessary.</li> <li><code>requests</code>: For making HTTP requests to the reCAPTCHA API.</li> <li><code>flask</code>: For creating the blueprint and handling routes, templates, requests, and responses.</li> <li><code>flask_login</code>: For user authentication.</li> <li><code>flask_mail</code>: For sending emails.</li> <li><code>.config</code>, <code>.extensions</code>, <code>.forms</code>, <code>.models</code>, <code>.scanners</code> (and submodules within <code>.scanners</code>): Internal application modules.</li> </ul> <p>Configuration:</p> <ul> <li>Report Directories: The script relies on several directory constants, such as <code>NMAP_REPORT_BASE</code>, <code>SSL_REPORT_BASE</code>, etc., to determine where scan reports are stored.  Ensure these paths are correctly configured based on your project structure.</li> <li>reCAPTCHA Keys: The <code>RECAPTCHA_PRIVATE_KEY</code> setting in the Flask application configuration is required to verify reCAPTCHA responses.</li> <li>Email Settings: The <code>MAIL_*</code> settings in the Flask application configuration are required for sending email notifications.</li> <li> <p>MOBSF API Keys: Ensure that you have set and configured mobsf_api_key.</p> <p><code>mobsf_api_url = current_app.config.get('MOBSF_API_URL')</code></p> <p><code>mobsf_api_key = current_app.config.get('MOBSF_API_KEY')</code></p> </li> </ul> <p>Security Considerations:</p> <ul> <li>Authentication: The <code>/scan</code> and <code>/download_report</code> routes require user authentication, preventing unauthorized access to scanning and report download functionality.</li> <li>Input Validation: The script validates URLs and IP addresses to prevent potential injection attacks. However, robust input sanitization and escaping should also be implemented in the templates.</li> <li>File Handling: The script handles file uploads. Careful file type validation and size limits are essential to prevent malicious uploads.</li> <li>Error Handling: The script includes error handling for various operations, such as database interactions and API calls. However, detailed error logging and reporting mechanisms should be implemented to improve debugging and security monitoring.</li> <li>reCAPTCHA: The script uses reCAPTCHA to mitigate bot submissions for the contact and demo request forms.</li> <li>Rate Limiting: Consider adding rate limiting to prevent abuse of the scanning and report download features.</li> </ul>"},{"location":"15_auth/","title":"File: <code>auth.py</code>","text":"<p>Purpose: This file defines the authentication blueprint for the VulnScanAI Flask web application. It handles user registration, email verification, login, logout, password reset, and password update functionalities.</p> <p>Overview:</p> <p>The <code>auth.py</code> file manages the core authentication processes:</p> <ul> <li>Registration: Allows new users to create accounts, verify their email, and subscribe to the free plan.</li> <li>Login: Authenticates existing users and manages user sessions.</li> <li>Logout: Terminates user sessions and cleans up user-related data.</li> <li>Password Management: Provides mechanisms for users to reset forgotten passwords and update existing passwords.</li> </ul> <p>Key Components and Functionality:</p> <ul> <li> <p>Blueprint Creation: Creates a Flask Blueprint named <code>auth_bp</code>.</p> <pre><code>from flask import Blueprint\n\nauth_bp = Blueprint('auth', __name__)\n</code></pre> </li> <li> <p><code>register()</code> Route: Handles user registration.</p> <pre><code>from flask import render_template, flash, request, url_for, redirect, current_app\nfrom flask_mail import Message\nimport requests\nfrom app.extensions import mail, db\nfrom app.forms import RegistrationForm\nfrom app.models import User, Subscription\nfrom werkzeug.security import generate_password_hash\nfrom itsdangerous import URLSafeTimedSerializer\n\n@auth_bp.route('/register', methods=['GET', 'POST'])\ndef register():\n    form = RegistrationForm()\n    if form.validate_on_submit():\n        # ... (form validation, reCAPTCHA verification, user creation, email verification sending) ...\n        return redirect(url_for('auth.login'))\n    return render_template('registration.html', form=form)\n</code></pre> <ul> <li>If the current user is already logged in, redirect to the home page.</li> <li>Uses reCAPTCHA for fraud detection.</li> <li>Checks for existing email and username</li> <li>Hashes the password before adding it to the database.</li> <li>Sends email verification messages upon registration.</li> </ul> </li> <li> <p><code>verify_email()</code> Route: Verifies user email addresses using a unique token.</p> <pre><code>from flask import flash, url_for, redirect\nfrom app.models import User, Subscription\nfrom app.extensions import db\nfrom itsdangerous import URLSafeTimedSerializer\nfrom datetime import datetime, timedelta\n\n@auth_bp.route('/verify_email/&lt;token&gt;')\ndef verify_email(token):\n    # ... (token validation, user verification, subscription assignment logic) ...\n    return redirect(url_for('auth.login'))\n</code></pre> <ul> <li>Validates the token</li> <li>Uses a Free plan, making sure the user gets the appropriate subcriptions</li> </ul> </li> <li> <p><code>login()</code> Route: Handles user login.</p> <pre><code>from flask import render_template, flash, request, url_for, redirect\nfrom flask_login import login_user, current_user\nimport requests\nfrom app.forms import LoginForm\nfrom app.models import User\nfrom werkzeug.security import check_password_hash\nfrom datetime import datetime\n\n@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login():\n    if current_user.is_authenticated:\n        return redirect(url_for('main.home'))\n    form = LoginForm()\n    if form.validate_on_submit():\n        # ... (form validation, reCAPTCHA verification, user authentication, session management) ...\n        return redirect(request.args.get('next') or url_for('main.home'))\n    return render_template('login.html', form=form)\n</code></pre> <ul> <li>Check for prior authentication</li> <li>Utilizes reCAPTCHA</li> <li>Makes sure that user is verified</li> <li>makes sure the subsription has not expired.</li> </ul> </li> <li> <p><code>logout()</code> Route: Handles user logout.</p> <pre><code>from flask import flash, url_for, redirect\nfrom flask_login import logout_user, current_user, login_required\nimport os\nfrom app.extensions import db\n#Delete reports\nfrom flask import current_app\n@auth_bp.route('/logout')\n@login_required\ndef logout():\n    user_id = current_user.id\n    logout_user()\n    flash('Logged out successfully!', 'info')\n\n    # Delete user's reports\n    reports_dir = os.path.join(current_app.root_path, 'reports')\n    if os.path.exists(reports_dir):\n        for root, dirs, files in os.walk(reports_dir):\n            for filename in files:\n                if filename.startswith(f\"{user_id}_\"):\n                    file_path = os.path.join(root, filename)\n                    try:\n                        os.remove(file_path)\n                        print(f\"Deleted report: {file_path}\")\n                    except Exception as e:\n                        print(f\"Error deleting report {file_path}: {e}\")\n\n    return redirect(url_for('main.home'))\n</code></pre> <p>Deletes the reports after a successful Logout</p> </li> <li> <p><code>forgot_password()</code> Route: Handles password reset requests.</p> <pre><code>from flask import render_template, flash, url_for, redirect\nfrom flask_mail import Message\nfrom app.extensions import mail\nfrom app.forms import ForgotPasswordForm\nfrom app.models import User\nfrom itsdangerous import URLSafeTimedSerializer\nfrom flask import current_app\n\n\n@auth_bp.route('/forgot_password', methods=['GET', 'POST'])\ndef forgot_password():\n    # ... (form validation, email sending logic) ...\n    return render_template('forgot_password.html', form=form)\n</code></pre> </li> </ul> <p>Sends email confirmation that there was a request to reset password</p> <ul> <li> <p><code>reset_password()</code> Route: Handles password reset after the user clicks on the reset link in his or her email.</p> <pre><code>from flask import render_template, flash, url_for, redirect\nfrom app.forms import ResetPasswordForm\nfrom app.models import User\nfrom werkzeug.security import generate_password_hash\nfrom app.extensions import db\nfrom itsdangerous import URLSafeTimedSerializer\nfrom flask import current_app\n\n\n@auth_bp.route('/reset_password/&lt;token&gt;', methods=['GET', 'POST'])\ndef reset_password(token):\n    # ... (token validation, password reset logic) ...\n    return render_template('reset_password.html', form=form)\n</code></pre> <p>sets the user\u2019s new password once the token is validated</p> </li> <li> <p><code>update_password()</code> Route: Handles updating a user\u2019s password through the profile page.</p> <pre><code>from flask import render_template, flash, url_for, redirect\nfrom flask_login import login_required, current_user\nfrom app.forms import ChangePasswordForm\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom app.extensions import db\n\n@auth_bp.route('/update_password', methods=['GET', 'POST'])\n@login_required\ndef update_password():\n    form = ChangePasswordForm()\n    # ... (form validation, update password logic) ...\n    return render_template('update_password.html', form=form)\n</code></pre> <p>It makes sure that the old password is correct And applies the new password.</p> </li> </ul> <p>Dependencies:</p> <ul> <li><code>flask</code>: For creating the blueprint, handling routes, templates, requests, and responses.</li> <li><code>flask_login</code>: For user authentication.</li> <li><code>flask_mail</code>: For sending emails.</li> <li><code>werkzeug.security</code>: For password hashing.</li> <li><code>itsdangerous</code>: For generating secure tokens.</li> <li><code>datetime</code>: For working with dates and times.</li> <li><code>requests</code>: For making HTTP requests to the reCAPTCHA API.</li> <li><code>.extensions</code>, <code>.forms</code>, <code>.models</code>: Internal application modules.</li> </ul> <p>Security Considerations:</p> <ul> <li>Password Hashing: Uses <code>generate_password_hash</code> from <code>werkzeug.security</code> to securely store passwords.</li> <li>reCAPTCHA: The registration and login routes utilize reCAPTCHA to prevent bot submissions.</li> <li>Email Verification: Requires users to verify their email addresses before logging in.</li> <li>Password Reset: Provides a secure password reset mechanism using time-limited tokens.</li> <li>Secure Tokens: Uses <code>URLSafeTimedSerializer</code> to generate and validate secure tokens for email verification and password reset.</li> <li>Logout Report Deletion: Removes reports after logout.</li> </ul>"},{"location":"16_genai/","title":"File: <code>genai.py</code>","text":"<p>Purpose: This file defines the Blueprint for Generative AI (GenAI) functionality within the VulnScanAI Flask web application. It integrates with Google's Gemini AI model to analyze security reports, provide insights, and enable interactive chat with the AI about the reports.</p> <p>Overview:</p> <p>The <code>genai.py</code> file facilitates:</p> <ul> <li>Report Analysis: Uploading security reports and using the Gemini AI model to extract key findings and insights.</li> <li>Interactive Chat: Allowing users to ask questions and engage in a conversation with the AI about the analyzed reports.</li> <li>Security: Adds a user security check to only let users with reports that they own to be able to analyze the report</li> </ul> <p>Key Components and Functionality:</p> <ul> <li> <p>Blueprint Creation: Creates a Flask Blueprint named <code>genai_bp</code>.</p> <pre><code>from flask import Blueprint\n\ngenai_bp = Blueprint('genai', __name__)\n</code></pre> </li> <li> <p>Import Statements: Imports necessary modules and scanner modules. It imports <code>GeminiReportAnalyzer</code> from a relative path, enabling access to a customized AI analysis model for analyzing the contents of the security reports.</p> <pre><code>import os\nimport logging\nfrom flask import Blueprint, request, jsonify, session, flash, redirect, url_for, render_template\nfrom werkzeug.utils import secure_filename\nfrom flask_login import login_required, current_user\nfrom .analyze_report_ai import GeminiReportAnalyzer  # Relative import for AI analyzer\nfrom .main import UPLOAD_FOLDER, MAX_FILE_SIZE_BYTES, NMAP_REPORT_BASE, SSL_REPORT_BASE, MOBSF_REPORT_BASE, CLOUD_AUDIT_REPORT_BASE, SQLMAP_REPORT_BASE, ZAP_REPORT_BASE, NIKTO_RESULTS_DIR, AUTHENTICATED_NIKTO_RESULTS_DIR\n</code></pre> </li> <li> <p>Gemini Analyzer Instance: Uses a global variable to store and manage the <code>GeminiReportAnalyzer</code> instance, which uses Gemini to analyze the reports.</p> <pre><code># Global variable to hold the GeminiReportAnalyzer instance\ngemini_analyzer_instance = None\n\ndef get_gemini_analyzer():\n    global gemini_analyzer_instance\n    if gemini_analyzer_instance is None:\n        try:\n            gemini_analyzer_instance = GeminiReportAnalyzer()\n        except ValueError as e:\n            logging.error(f\"Error initializing Gemini AI: {e}\")\n            return None\n    return gemini_analyzer_instance\n</code></pre> </li> <li> <p><code>analyze_report()</code> Route: Renders the initial page for report analysis.</p> <p><pre><code>from flask import render_template, session\nfrom flask_login import login_required\n\n@genai_bp.route('/analyze_report')\n@login_required\ndef analyze_report():\n    session.pop('gemini_chat_history', None) # Clear any previous chat session\n    return render_template('analyze_report.html')\n</code></pre> This part will only load the initial HTML page.</p> </li> <li> <p><code>upload_report()</code> Route: Handles report uploads and initial analysis.</p> <pre><code>import os\nfrom flask import request, jsonify\nfrom flask_login import login_required\nfrom werkzeug.utils import secure_filename\n\n@genai_bp.route('/analyze_report/upload', methods=['POST'])\n@login_required\ndef upload_report():\n    gemini_analyzer = get_gemini_analyzer()\n    if not gemini_analyzer:\n        return jsonify({'error': 'Gemini AI functionality is not configured.'}), 503\n\n    if 'report_file' not in request.files:\n        return jsonify({'error': 'No file part'}), 400\n    file = request.files['report_file']\n    # ... (file processing and analysis logic) ...\n</code></pre> </li> <li> <p><code>chat_with_ai()</code> Route: Enables users to interact with the Gemini AI model about the uploaded report.</p> <pre><code>from flask import request, jsonify\nfrom flask_login import login_required\n\n@genai_bp.route('/analyze_report/chat', methods=['POST'])\n@login_required\ndef chat_with_ai():\n    gemini_analyzer = get_gemini_analyzer()\n    if not gemini_analyzer:\n        return jsonify({'error': 'Gemini AI functionality is not configured.'}), 503\n\n    data = request.get_json()\n    user_message = data.get('message')\n\n    if not user_message:\n        return jsonify({'error': 'No message provided'}), 400\n\n    analysis_result = gemini_analyzer.continue_chat(user_message)\n    if \"error\" in analysis_result:\n        return jsonify(analysis_result), 500\n    return jsonify({'response': analysis_result['analysis']})\n</code></pre> </li> <li> <p><code>start_analysis()</code> Route: Handles the initial PDF report analysis. It also checks that the users actually have access to the PDF being scanned.</p> <pre><code>import os\nfrom flask import request, jsonify, session, flash, redirect, url_for, render_template\nfrom flask_login import login_required, current_user\n\n@genai_bp.route('/analyze_report/start_analysis/&lt;filename&gt;', methods=['GET'])  # &lt;--- Add methods=['POST']\n@login_required\ndef start_analysis(filename):\n    # ... (report directory determination, file existence checks, and analysis logic) ...\n</code></pre> <p>This function performs a critical security check to authorize reports to only be analyzed to users that own the files. This prevents users from potentially gaining insights into other users scans. It uses logic to ensure that any request to view the PDF or any scanned documents MUST belong to the user.</p> </li> </ul> <p>Dependencies:</p> <ul> <li><code>os</code>: For file system operations.</li> <li><code>logging</code>: For logging errors and debugging information.</li> <li><code>flask</code>: For creating the blueprint and handling routes, templates, requests, and responses.</li> <li><code>flask_login</code>: For user authentication.</li> <li><code>werkzeug.utils</code>: For <code>secure_filename</code> (securing filenames for uploads).</li> <li><code>app.scanners.*</code>: To get the base reports used to ensure people can't scan other peoples reports</li> <li><code>.analyze_report_ai</code>: To analyze and generate insights from the report</li> </ul> <p>Configuration:</p> <ul> <li><code>GEMINI_API_KEY</code>: The API key for accessing the Google Gemini AI model. This must be set in the Flask application configuration.</li> <li><code>UPLOAD_FOLDER</code>, <code>MAX_FILE_SIZE_BYTES</code>: File upload configurations.</li> </ul> <p>Security Considerations:</p> <ul> <li>Authentication: The core functions of this module require authentication with <code>@login_required</code></li> <li>Authorization: Report ownership validation is implemented in the <code>/analyze_report/start_analysis/&lt;filename&gt;</code> route.</li> <li>File Uploads: The <code>/analyze_report/upload</code> path utilizes <code>secure_filename</code> to sanitize upload filenames.</li> <li>API Keys: API keys should be stored securely (e.g., using environment variables) and never hardcoded directly into the script.</li> <li>Thorough security check to confirm that the user owns the particular reports.</li> </ul>"},{"location":"17_analyze_report_ai/","title":"File: <code>analyze_report_ai.py</code>","text":"<p>Purpose: This file defines the <code>GeminiReportAnalyzer</code> class, which leverages Google's Gemini AI model to analyze security reports (specifically PDFs), extract relevant information, mask Personally Identifiable Information (PII), and facilitate interactive chat regarding the report's content.</p> <p>Overview:</p> <p>The <code>analyze_report_ai.py</code> provides the following functionalities:</p> <ul> <li>Gemini AI Integration: Establishes a connection with the Google Gemini AI model for report analysis and conversational interaction.</li> <li>PDF Text Extraction: Extracts text from PDF reports.</li> <li>PII Masking: Employs regular expressions to mask sensitive information within the extracted text before sending it to the AI model, safeguarding privacy.</li> <li>Report Analysis: Utilizes the AI model to analyze the report and provide initial key insights.</li> <li>Chat Interaction: Enables users to interact conversationally with the AI about the report's contents.</li> </ul> <p>Key Components and Functionality:</p> <ul> <li> <p><code>GeminiReportAnalyzer</code> Class:</p> <ul> <li> <p><code>__init__(self, api_key=None)</code>: The constructor initializes the Gemini AI model.</p> <ul> <li>Retrieves the Gemini API key from the Flask application configuration or uses a provided key.</li> <li>Raises a <code>ValueError</code> if the API key is not set.</li> <li>Configures the Gemini AI model using the API key.</li> <li>Initializes the <code>model</code> and <code>chat</code> attributes.</li> </ul> <pre><code>import google.generativeai as genai\nimport logging\nfrom pypdf import PdfReader\nfrom flask import current_app\nimport re\n\nclass GeminiReportAnalyzer:\n    def __init__(self, api_key=None):\n        self.api_key = api_key or current_app.config.get('GEMINI_API_KEY')\n        if not self.api_key:\n            raise ValueError(\"GEMINI_API_KEY is not set in configuration.\")\n        genai.configure(api_key=self.api_key)\n        self.model = genai.GenerativeModel(\"gemini-1.5-flash\")  # Use one model\n        self.chat = None  # To store the ongoing chat session\n</code></pre> </li> <li> <p><code>extract_text_from_pdf(self, pdf_path)</code>: Extracts text content from a PDF file.</p> <ul> <li>Uses <code>PdfReader</code> from the <code>pypdf</code> library to read the PDF.</li> <li>Iterates over the pages and extracts text from each page.</li> <li>Returns the extracted text as a single string or <code>None</code> if extraction fails.</li> <li>Includes error handling for PDF processing.</li> </ul> <pre><code>from pypdf import PdfReader\n\ndef extract_text_from_pdf(self, pdf_path):\n    try:\n        reader = PdfReader(pdf_path)\n        text = \"\\n\".join([page.extract_text() for page in reader.pages if page.extract_text()])\n        return text if text else None\nexcept Exception as e:\n    logging.exception(\"PDF Extraction Failed\")\n    return None\n</code></pre> </li> <li> <p><code>mask_pii(self, text)</code>: Masks Personally Identifiable Information (PII) from the extracted text before sending it to the Gemini AI model.  This method focuses on providing a good balance between accuracy and avoiding false positives while attempting to maintain document structure.</p> <ul> <li>Uses regular expressions (<code>re.sub</code>) to identify and replace email addresses, IP addresses, phone numbers, website URLs, and physical addresses with placeholder values.  The regex patterns are more complex to avoid common pitfalls.</li> </ul> <pre><code>import re\n\ndef mask_pii(self, text):\n    \"\"\"\n    Masks email addresses, phone numbers, IP addresses, physical addresses, and website URLs,\n    while minimizing false positives and preserving report structure.\n    \"\"\"\n\n    # 1. Email Addresses (Accurate Pattern)\n    text = re.sub(r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b', 'user@example.com', text)\n\n    # 2. IP Addresses (IPv4 and IPv6, Careful with CIDR Notation)\n    text = re.sub(r'\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?:/\\d{1,2})?\\b', '127.0.0.1', text) # Includes optional CIDR notation\n    text = re.sub(r'([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}', '2001:db8::1', text)  # Basic IPv6\n    text = re.sub(r'((([0-9a-fA-F]{1,4}:){6}:)|(([0-9a-fA-F]{1,4}:){5}:[0-9a-fA-F]{1,4})|(([0-9a-fA-F]{1,4}:){4}:([0-9a-fA-F]{1,4}:){1,2})|(([0-9a-fA-F]{1,4}:){3}:([0-9a-fA-F]{1,4}:){1,3})|(([0-9a-fA-F]{1,4}:){2}:([0-9a-fA-F]{1,4}:){1,4})|(([0-9a-fA-F]{1,4}:){6}(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9a-fA-F]{1,4}:){5}(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9a-fA-F]{1,4}:){1,2}:([0-9a-fA-F]{1,4}:){1,5}:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))))\\b', '2001:db8::1', text) # More complete IPv6\n\n    # 3. Phone Numbers (More robust with various formats)\n    text = re.sub(r'\\b(?:\\+\\d{1,3}[- ]?)?(?:\\(\\d{1,4}\\)[- ]?)?(?:\\d{1,4}[- ]?){1,3}\\d{1,4}\\b', '+1-555-123-4567', text)\n\n    # 4. Website URLs (Handles http/https, www, and various TLDs)\n    text = re.sub(r'(?:https?://)?(?:www\\.)?([a-zA-Z0-9-]+(?:\\.[a-zA-Z]{2,})+)(?:[/\\w \\.-]*)?', r'https://example.com', text)  # Modified regex\n    # The above preserves TLD\n\n    # 5. Physical Addresses (Simplified, requires context - still prone to errors)\n    text = re.sub(r'\\b\\d+\\s+[A-Za-z0-9\\s]+\\s+(?:St|Street|Ave|Avenue|Rd|Road|Dr|Drive).*', '[REDACTED_ADDRESS]', text)\n\n    return text\n</code></pre> </li> <li> <p><code>upload_pdf_and_analyze(self, pdf_path)</code>: Uploads a PDF file and triggers AI-powered analysis.</p> <ul> <li>Calls <code>extract_text_from_pdf()</code> to extract text from the PDF.</li> <li>Masks PII in the extracted text using <code>mask_pii()</code>.</li> <li>Constructs an initial prompt for the AI model, including the masked text.</li> <li>Starts a chat session using <code>self.model.start_chat()</code>.</li> <li>Sends the initial prompt to the AI model and retrieves the response.</li> <li>Returns the AI's analysis or an error message.</li> <li>It ensures to use the masked text for enhanced privacy.</li> </ul> <pre><code>def upload_pdf_and_analyze(self, pdf_path):\n    extracted_text = self.extract_text_from_pdf(pdf_path)\n    if not extracted_text:\n        return {\"error\": \"Failed to extract text from PDF\"}\n\n    # Mask PII before sending to Gemini\n    masked_text = self.mask_pii(extracted_text)\n\n    user_message = \"Analyze this security scan report and provide key insights.\"\n    initial_prompt = f\"{user_message}\\n\\n{masked_text}\"  # Use masked_text\n\n    try:\n        self.chat = self.model.start_chat(history=[{\"role\": \"user\", \"parts\": [initial_prompt]}])\n\n        response = self.chat.send_message(initial_prompt)\n\n        return {\n            \"analysis\": response.text if response else \"No response received.\"\n        }\nexcept Exception as e:\n    logging.exception(\"Gemini analysis failed.\")\n    return {\"error\": \"Gemini analysis failed\", \"details\": str(e)}\n</code></pre> </li> <li> <p><code>continue_chat(self, user_message)</code>: Continues an existing chat session with the Gemini AI model.</p> <ul> <li>Checks if a chat session is active.</li> <li>Sends the user's message to the AI model and retrieves the response.</li> <li>Returns the AI's response or an error message.</li> </ul> <pre><code>def continue_chat(self, user_message):\n    try:\n        if self.chat is None:\n            return {\"error\": \"No active chat session found. Please upload a PDF first.\"}\n\n    response = self.chat.send_message(user_message)\n    assistant_response = response.text if response else \"No response received.\"\n    return {\"analysis\": assistant_response}\nexcept Exception as e:\n    logging.exception(\"Gemini follow-up failed.\")\n    return {\"error\": \"Gemini follow-up failed\", \"details\": str(e)}\n</code></pre> </li> </ul> </li> </ul> <p>Dependencies:</p> <ul> <li><code>google.generativeai</code>: For interacting with the Gemini AI model (<code>pip install google-generativeai</code>).</li> <li><code>pypdf</code>: For reading PDF files (<code>pip install pypdf</code>).</li> <li><code>flask</code>: For accessing the application configuration.</li> <li><code>logging</code>: For logging errors and debugging information.</li> <li><code>re</code>: For regular expressions used in PII masking.</li> </ul> <p>Configuration:</p> <ul> <li><code>GEMINI_API_KEY</code>: The API key for accessing the Google Gemini AI model. This must be set in the Flask application configuration.</li> </ul> <p>Security Considerations:</p> <ul> <li>API Key Security: The Gemini API key is a sensitive credential and should be stored securely. Avoid hardcoding the key and consider using environment variables or a secrets management system.</li> <li>PII Masking: The <code>mask_pii()</code> function helps protect sensitive information by removing it from the text sent to the AI model. This is crucial for maintaining user privacy. The regular expressions used in <code>mask_pii()</code> should be regularly reviewed and updated to ensure they are effective and cover all relevant PII types. The existing implementation prioritizes accuracy and minimizing false positives but might not catch all possible PII variations. Consider using dedicated PII detection libraries for enhanced accuracy.</li> <li>Data Sent to AI Model:  Be aware of the data being sent to the AI model. While PII masking is implemented, it's crucial to avoid sending any unnecessary sensitive information to the AI service.</li> <li>Error Handling: The code includes error handling for various operations, such as PDF processing and API calls. Log all exceptions and errors to allow for debugging.</li> <li>Rate Limiting and Cost:  Be mindful of Gemini's API usage costs and implement rate-limiting measures if necessary to prevent excessive usage. Refer to the Gemini API documentation for their specific rate limit policies. The current implementation does not include rate limiting.</li> </ul>"},{"location":"18_payments/","title":"File: <code>payments.py</code>","text":"<p>Purpose: This file defines the <code>payments_bp</code> Blueprint, responsible for managing payment-related functionalities within the application. It facilitates integration with the PayPal API for handling subscription payments, updating user subscription details, and recording payment transactions.</p> <p>Overview:</p> <p>The <code>payments.py</code> file encompasses the following key functionalities:</p> <ul> <li>PayPal API Integration: It orchestrates interactions with the PayPal API to initiate and finalize orders, in addition to retrieving comprehensive order details. Robust error handling and retry mechanisms are in place.</li> <li>Subscription Management: It diligently updates user subscription data, including the subscription ID and expiry date, within the database upon successful payment confirmation.</li> <li>Payment Recording: The module meticulously records crucial payment information, such as user details, amounts, currency, transaction identifiers, and status, within the database.</li> <li>Error Handling: Comprehensive error handling strategies, incorporating custom exceptions and logging, are implemented to ensure the dependability of the payment processing workflow.</li> <li>Idempotency: UUIDs are employed to generate unique idempotency keys for PayPal capture requests, mitigating the risk of duplicate transactions.</li> <li>Payer Action Handling: The code anticipates and manages scenarios where PayPal mandates user intervention (e.g., supplementary verification steps) by seamlessly redirecting users to the PayPal platform.</li> </ul> <p>Key Components and Functionality:</p> <ul> <li> <p><code>payments_bp</code> Blueprint:</p> <ul> <li>Serves as the foundation for defining all payment-centric routes within the application.</li> </ul> <pre><code>from flask import Blueprint\n\npayments_bp = Blueprint('payments', __name__)\n</code></pre> </li> <li> <p><code>PayPalAPIError</code> Exception:</p> <ul> <li>A bespoke exception class designed for capturing and managing errors originating from the PayPal API, ensuring standardized error reporting throughout the module.</li> </ul> <pre><code>class PayPalAPIError(Exception):\n    \"\"\"Custom exception for PayPal API errors.\"\"\"\n    def __init__(self, message, status_code=None, response_json=None):\n        super().__init__(message)\n        self.status_code = status_code\n        self.response_json = response_json\n</code></pre> </li> <li> <p>Helper Functions:</p> <ul> <li> <p><code>get_paypal_access_token(max_retries=3, backoff_factor=0.5)</code>:</p> <ul> <li>Retrieves an access token from the PayPal API, utilizing the client ID and secret stored in the Flask application's configuration.</li> <li>Incorporates retry logic with exponential backoff and jitter to gracefully handle transient network-related issues.</li> <li>Propagates a <code>PayPalAPIError</code> exception if retrieval of the access token fails after multiple attempts or if parsing the response encounters issues.</li> </ul> <pre><code>def get_paypal_access_token(max_retries=3, backoff_factor=0.5):\n    \"\"\"Retrieves an access token from PayPal with retry logic.\"\"\"\n    auth = (current_app.config['PAYPAL_SANDBOX_CLIENT_ID'], current_app.config['PAYPAL_SANDBOX_CLIENT_SECRET'])\n    headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n    data = {'grant_type': 'client_credentials'}\n\n    for attempt in range(max_retries):\n        try:\n            response = requests.post(f'{current_app.config[\"PAYPAL_API_BASE\"]}/v1/oauth2/token', auth=auth, headers=headers, data=data)\n            response.raise_for_status()\n            token_data = response.json()\n            logger.debug(f\"PayPal Access Token Response: {token_data}\")\n            return token_data['access_token']\n        except requests.exceptions.RequestException as e:\n            logger.warning(f\"Attempt {attempt + 1} failed to get PayPal access token: {e}\")\n            if attempt &lt; max_retries - 1:\n                sleep_duration = (backoff_factor * (2 ** attempt)) + random.uniform(0, 0.1)\n                logger.info(f\"Retrying in {sleep_duration:.2f} seconds...\")\n                time.sleep(sleep_duration)\n            else:\n                logger.error(f\"Max retries reached for getting PayPal access token: {e}\")\n                raise PayPalAPIError(\"Failed to get PayPal access token.\")\n        except (KeyError, ValueError) as e:\n            logger.error(f\"Error parsing PayPal access token response: {e}\")\n            raise PayPalAPIError(\"Failed to parse PayPal access token response.\")\n    return None\n</code></pre> </li> <li> <p><code>create_paypal_order(amount, access_token, currency='USD')</code>:</p> <ul> <li>Generates a PayPal order with the specified amount and currency details.</li> <li>Implements robust error handling for potential request exceptions and response parsing failures.</li> <li>Returns the order ID and approval URL to facilitate user authorization of the payment.</li> <li>Raises a <code>PayPalAPIError</code> exception if the order creation encounters an issue or if response parsing fails.</li> </ul> <pre><code>def create_paypal_order(amount, access_token, currency='USD'):\n    \"\"\"Creates a PayPal order.\"\"\"\n    headers = {\n        'Content-Type': 'application/json',\n        'Authorization': f'Bearer {access_token}'\n    }\n    data = {\n        \"intent\": \"CAPTURE\",\n        \"purchase_units\": [\n            {\n                \"amount\": {\n                    \"currency_code\": currency,\n                    \"value\": f\"{amount:.2f}\"\n                }\n            }\n        ]\n    }\n    try:\n        response = requests.post(f'{current_app.config[\"PAYPAL_API_BASE\"]}/v2/checkout/orders', headers=headers, json=data)\n        response.raise_for_status()\n        response_json = response.json()\n        logger.debug(f\"PayPal Create Order Response: {response_json}\")\n        order_id = response_json['id']\n        approval_url = next(link['href'] for link in response_json['links'] if link['rel'] == 'approve')\n        return order_id, approval_url\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Error creating PayPal order: {e}\")\n        raise PayPalAPIError(\"Failed to create PayPal order.\")\n    except (KeyError, IndexError) as e:\n        logger.error(f\"Error parsing PayPal create order response: {e}\")\n        raise PayPalAPIError(\"Failed to parse PayPal create order response.\")\n</code></pre> </li> <li> <p><code>capture_paypal_order(order_id, access_token, idempotency_key=None)</code>:</p> <ul> <li>Captures a previously authorized PayPal order.</li> <li>Employs an <code>idempotency_key</code> to prevent accidental or malicious duplicate transactions.</li> <li>Manages any errors that may arise during the capture process.</li> <li>Extracts the capture ID and status from the PayPal response.</li> <li>Raises a <code>PayPalAPIError</code> if order capturing fails or if parsing the response encounters issues.</li> </ul> <pre><code>def capture_paypal_order(order_id, access_token, idempotency_key=None):\n    \"\"\"Captures a PayPal order.\"\"\"\n    headers = {\n        'Content-Type': 'application/json',\n        'Authorization': f'Bearer {access_token}'\n    }\n    if idempotency_key:\n        headers['PayPal-Request-Id'] = idempotency_key\n\n    try:\n        response = requests.post(f'{current_app.config[\"PAYPAL_API_BASE\"]}/v2/checkout/orders/{order_id}/capture', headers=headers)\n        response.raise_for_status()\n        response_json = response.json()\n        logger.debug(f\"PayPal Capture Order Response: {response_json}\")\n\n        # Extract capture ID and status safely\n        purchase_units = response_json.get('purchase_units', [])\n        if purchase_units and isinstance(purchase_units, list) and purchase_units:\n            payments = purchase_units[0].get('payments', {})\n            captures = payments.get('captures', [])\n            if captures and isinstance(captures, list) and captures:\n                capture = captures[0] #Assuming only one capture per purchase unit\n                capture_id = capture.get('id')\n                capture_status = capture.get('status')\n                if capture_id and capture_status:\n                    return capture_status, capture_id\n\n        # If any of the extractions fail, log the error and raise an exception\n        logger.error(f\"Could not extract capture ID/status from PayPal response: {response_json}\")\n        raise PayPalAPIError(\"Failed to parse PayPal capture order response (missing capture ID/status).\")\n\n\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Error capturing PayPal order {order_id}: {e}\")\n        raise PayPalAPIError(\"Failed to capture PayPal order.\")\n    except (KeyError, IndexError) as e:\n        logger.error(f\"Error parsing PayPal capture order response: {e}\")\n        raise PayPalAPIError(\"Failed to parse PayPal capture order response.\")\n</code></pre> </li> <li> <p><code>get_paypal_order_details(order_id, access_token)</code>:</p> <ul> <li>Retrieves comprehensive details regarding a specific PayPal order.</li> <li>Includes error handling mechanisms for potential retrieval issues.</li> <li>Raises a <code>PayPalAPIError</code> exception if retrieving order details is unsuccessful.</li> </ul> <pre><code>def get_paypal_order_details(order_id, access_token):\n    \"\"\"Gets PayPal order details.\"\"\"\n    headers = {\n        'Content-Type': 'application/json',\n        'Authorization': f'Bearer {access_token}'\n    }\n    try:\n        response = requests.get(f'{current_app.config[\"PAYPAL_API_BASE\"]}/v2/checkout/orders/{order_id}', headers=headers)\n        response.raise_for_status()\n        order_details = response.json()\n        logger.debug(f\"PayPal Order Details for {order_id}: {order_details}\")\n        return order_details\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Error getting PayPal order details for {order_id}: {e}\")\n        raise PayPalAPIError(\"Failed to get PayPal order details.\")\n</code></pre> </li> <li> <p><code>update_user_subscription(user, subscription)</code>:</p> <ul> <li>Updates the user's subscription information within the database, including the subscription ID and its corresponding expiry date.</li> <li>Implements error handling for database-related operations.</li> <li>Raises a general <code>Exception</code> if the database update encounters any problems.</li> </ul> <pre><code>def update_user_subscription(user, subscription):\n    \"\"\"Updates the user's subscription information in the database.\"\"\"\n    try:\n        user.subscription_id = subscription.id\n        user.subscription_expiry = datetime.utcnow() + timedelta(days=30 * subscription.validity_months)\n        db.session.add(user) # add back to session so the changes can be tracked and persisted\n        logger.info(f\"User {user.id} subscription updated to {subscription.id}\")\n    except Exception as e:\n        logger.error(f\"Error updating user {user.id} subscription to {subscription.id}: {e}\")\n        raise\n</code></pre> </li> <li> <p><code>record_payment(user, subscription, paypal_transaction_id)</code>:</p> <ul> <li>Records payment-related details in the database, which includes user data, subscription details, payment amount, currency type, and the PayPal transaction ID.</li> <li>Contains error handling mechanisms for database operations.</li> <li>Raises a general <code>Exception</code> if payment recording fails to complete successfully.</li> </ul> <pre><code>def record_payment(user, subscription, paypal_transaction_id):\n    \"\"\"Records the payment details in the database.\"\"\"\n    try:\n        payment = Payment(\n            user_id=user.id,\n            payment_id=paypal_transaction_id,\n            amount=subscription.price,\n            currency='USD',\n            payment_status='Completed',\n            subscription_id=subscription.id\n        )\n        db.session.add(payment)\n        db.session.commit()\n        logger.info(f\"Payment recorded for user {user.id}, subscription {subscription.id}, transaction {paypal_transaction_id}\")\n        return payment  #Return the payment instance for payment.id access\n\n    except Exception as e:\n        logger.error(f\"Error recording payment for user {user.id}, subscription {subscription.id}, transaction {paypal_transaction_id}: {e}\")\n        raise\n</code></pre> </li> </ul> </li> <li> <p>Route Handlers:</p> <ul> <li> <p><code>@payments_bp.route('/create_paypal_order', methods=['POST'])</code> - <code>create_order()</code>:</p> <ul> <li>Handles incoming requests aimed at creating PayPal orders.</li> <li>Verifies the validity of the requested subscription plan.</li> <li>Obtains a PayPal access token.</li> <li>Initiates the creation of a PayPal order through the <code>create_paypal_order()</code> function.</li> <li>Dispatches the approval URL to the client.</li> <li>Manages any <code>PayPalAPIError</code> exceptions or other unexpected errors that may occur.</li> <li>Restricts access to only logged-in users via the <code>@login_required</code> decorator.</li> </ul> <pre><code>@payments_bp.route('/create_paypal_order', methods=['POST'])\n@login_required\ndef create_order():\n    data = request.get_json()\n    plan = data.get('plan')\n    valid_plans = ['pro', 'premium']\n\n    if not plan or plan not in valid_plans:\n        logger.warning(f\"Invalid plan requested: {plan}\")\n        return jsonify({'error': 'Invalid request.'}), 400\n\n    subscription = Subscription.query.filter_by(plan_name=plan.capitalize() + \" Security\").first()\n    if not subscription:\n        logger.warning(f\"Create order request for invalid plan: {plan}\")\n        return jsonify({'error': 'Invalid request.'}), 400\n\n    try:\n        access_token = get_paypal_access_token()\n        order_id, approval_url = create_paypal_order(subscription.price, access_token)\n        return jsonify({'approval_url': approval_url, 'order_id': order_id}), 200\n    except PayPalAPIError:\n        flash(\"There was an error creating the payment. Please try again.\", \"danger\")\n        return jsonify({'error': 'Payment creation failed.'}), 500\n    except Exception as e:\n        logger.critical(f\"Unexpected error in create_order: {e}\")\n        flash(\"There was an unexpected error. Please try again later.\", \"danger\")\n        return jsonify({'error': 'Payment creation failed.'}), 500\n</code></pre> </li> <li> <p><code>@payments_bp.route('/capture_paypal_order', methods=['GET'])</code> - <code>capture_order()</code>:</p> <ul> <li>Handles requests to capture a PayPal order after the user has authorized the payment.</li> <li>Retrieves the order ID and plan name from the request parameters.</li> <li>Retrieves a PayPal access token.</li> <li>Gets the order details using <code>get_paypal_order_details()</code>.</li> <li>Handles <code>PAYER_ACTION_REQUIRED</code> status by redirecting the user to PayPal for further action.</li> <li>Captures the PayPal order using the <code>capture_paypal_order()</code> function, including an idempotency key.</li> <li>Updates the user's subscription in the database using <code>update_user_subscription()</code>.</li> <li>Records the payment details in the database using <code>record_payment()</code>.</li> <li>Redirects the user to a payment success page.</li> <li>Includes comprehensive error handling and logging.</li> <li>Requires the user to be logged in (<code>@login_required</code>).</li> </ul> <pre><code>@payments_bp.route('/capture_paypal_order', methods=['GET'])\n@login_required\ndef capture_order():\n    order_id = request.args.get('token')\n    plan_name = request.args.get('plan')\n\n    if not order_id or not plan_name:\n        flash('Invalid payment request.', 'danger')\n        return redirect(url_for('main.pricing'))\n\n    try:\n        access_token = get_paypal_access_token()\n        order_details = get_paypal_order_details(order_id, access_token)\n        order_status = order_details.get('status')\n\n        # Handle PAYER_ACTION_REQUIRED by redirecting\n        if order_status == 'PAYER_ACTION_REQUIRED':\n            payer_action_url = next((link['href'] for link in order_details['links'] if link['rel'] == 'payer-action'), None)\n            if payer_action_url:\n                return redirect(payer_action_url)\n            else:\n                logger.warning(f\"Order {order_id} requires payer action, but no 'payer-action' link found.\")\n                flash('Payment requires additional action on PayPal. Please check your PayPal account.', 'warning')\n                return redirect(url_for('main.pricing'))\n\n        # Proceed with capture only if the order is APPROVED\n        if order_status != 'APPROVED':\n            logger.warning(f\"Order {order_id} is not in a capturable state: {order_status}\")\n            flash('Payment cannot be completed at this time. Please try again later.', 'warning')\n            return redirect(url_for('main.pricing'))\n\n        paypal_request_id = str(uuid.uuid4())  # Generate UUID for idempotency\n        try:\n            capture_status, paypal_capture_id = capture_paypal_order(order_id, access_token, paypal_request_id)\n        except PayPalAPIError as e:\n            logger.error(f\"Capture failed: {e}\")\n            flash(\"There was an error capturing the payment. Please try again or contact support.\", \"danger\")\n            return jsonify({'redirect_url': url_for('main.pricing')})\n\n        if capture_status == 'COMPLETED':\n            subscription = Subscription.query.filter_by(plan_name=plan_name.capitalize() + \" Security\").first()\n            if not subscription:\n                flash('Error: Invalid plan during payment completion.', 'danger')\n                return jsonify({'redirect_url': url_for('main.scan')})\n\n            try:\n                # Validation and Logging\n                logger.info(f\"Attempting to update subscription for user {current_user.id}, subscription {subscription.id}, paypal_capture_id {paypal_capture_id}\")\n\n                if not isinstance(paypal_capture_id, str) or not paypal_capture_id:\n                    logger.error(f\"Invalid paypal_capture_id: {paypal_capture_id}\")\n                    raise ValueError(\"Invalid paypal_capture_id\")\n\n                update_user_subscription(current_user, subscription)\n                payment = record_payment(current_user, subscription, paypal_capture_id)\n\n\n                logger.info(f\"Subscription updated and payment recorded successfully for user {current_user.id}\")\n\n                # Payment successful, redirect to success page\n                return jsonify({\n                    'redirect_url': url_for('payments.payment_successful', payment_id=payment.id)\n                })\n\n            except Exception as e:\n                #In automatic transaction mode, we must manually call rollback\n                db.session.rollback()\n                logger.error(f\"Error processing payment for user {current_user.id}: {e}\", exc_info=True)  # Log full traceback\n                flash(\"An error occurred while updating your subscription. Please contact support.\", \"danger\")\n                return jsonify({'redirect_url': url_for('main.pricing')})\n\n        else:\n            logger.error(f\"PayPal Capture failed for order {order_id}, status {capture_status}\")\n            flash('Payment failed or was not completed.', 'warning')\n            return jsonify({'redirect_url': url_for('main.pricing')})\n\n    except PayPalAPIError as e:\n         flash(f\"There was an error processing your payment: {e}\", \"danger\")\n         return jsonify({'redirect_url': url_for('main.pricing')})\n    except Exception as e:\n        logger.critical(f\"Unexpected error in capture_order: {e}\")\n        flash(\"There was an unexpected error during payment processing.\", \"danger\")\n        return jsonify({'redirect_url': url_for('main.pricing')})\n</code></pre> </li> <li> <p><code>@payments_bp.route('/cancel_paypal_order')</code> - <code>cancel_order()</code>:</p> <ul> <li>Manages scenarios where the user cancels their PayPal payment.</li> <li>Presents a flash message to inform the user that the payment has been canceled.</li> <li>Redirects the user back to the pricing page.</li> <li>This route is restricted to authenticated users only via the <code>@login_required</code> decorator.</li> </ul> <pre><code>@payments_bp.route('/cancel_paypal_order')\n@login_required\ndef cancel_order():\n    flash('Payment was canceled by the user.', 'info')\n    return redirect(url_for('main.pricing'))\n</code></pre> </li> <li> <p><code>@payments_bp.route('/payment_successful/&lt;int:payment_id&gt;')</code> - <code>payment_successful()</code>:</p> <ul> <li>Renders the payment confirmation page after a successful transaction, displaying relevant payment details.</li> <li>Retrieves the payment information from the database based on the provided payment ID.</li> <li>Validates that the payment corresponds to the currently logged-in user, preventing unauthorized access.</li> <li>Returns a 404 error if the specified payment cannot be located.</li> <li>Requires user authentication using the <code>@login_required</code> decorator.</li> </ul> <pre><code>@payments_bp.route('/payment_successful/&lt;int:payment_id&gt;')\n@login_required\ndef payment_successful(payment_id):\n    \"\"\"Renders the payment successful page with payment details.\"\"\"\n    payment = Payment.query.get_or_404(payment_id)\n    if payment.user_id != current_user.id:\n        flash(\"You are not authorized to view this payment.\", \"danger\")\n        return redirect(url_for('main.home'))  # Or appropriate error page\n\n    return render_template('payment_successful.html', payment=payment)\n</code></pre> </li> </ul> </li> </ul> <p>Dependencies:</p> <ul> <li><code>flask</code>: Powers the Blueprint, manages HTTP requests, renders templates, and provides access to application configuration settings.</li> <li><code>flask_login</code>: Enforces user authentication and authorization protocols.</li> <li><code>app.extensions</code>: Grants access to the database instance (<code>db</code>).</li> <li><code>app.models</code>: Specifies data models representing <code>Subscription</code>, <code>Payment</code>, and <code>User</code> entities.</li> <li><code>datetime</code>: Facilitates working with date and time values.</li> <li><code>os</code>: Used to access environment variables.</li> <li><code>requests</code>: Enables making HTTP requests to interact with the PayPal API.</li> <li><code>logging</code>: Provides a mechanism for logging errors and debugging information.</li> <li><code>uuid</code>: Generates universally unique identifiers (UUIDs) for idempotency purposes.</li> <li><code>time</code>: Facilitates the implementation of delays in retry logic.</li> <li><code>random</code>: Introduces randomness or \"jitter\" into retry delays to avoid synchronized retries.</li> <li><code>sqlalchemy.exc</code>: Allows for handling exceptions related to SQLAlchemy database operations.</li> </ul> <p>Configuration:</p> <p>The following configuration variables are essential for proper operation:</p> <ul> <li><code>PAYPAL_SANDBOX_CLIENT_ID</code>: The PayPal client ID designated for the sandbox testing environment.</li> <li><code>PAYPAL_SANDBOX_CLIENT_SECRET</code>: The PayPal client secret associated with the sandbox environment.</li> <li><code>PAYPAL_API_BASE</code>: The base URL for accessing the PayPal API (e.g., <code>https://api-m.sandbox.paypal.com</code>).</li> </ul> <p>These configuration parameters should be accurately defined within the Flask application's configuration settings.</p> <p>Error Handling:</p> <ul> <li>A specialized <code>PayPalAPIError</code> exception is used to handle errors specifically related to the PayPal API interactions.</li> <li>Retry mechanisms with exponential backoff and jitter are implemented when attempting to retrieve PayPal access tokens.</li> <li>Comprehensive error handling is incorporated into each function, which involves logging, displaying user-friendly flash messages, and redirecting users as needed.</li> <li>Database operations are enclosed within try-except blocks to handle and manage potential exceptions gracefully.</li> </ul> <p>Security Considerations:</p> <ul> <li>The PayPal client ID and secret are highly sensitive credentials and must be protected diligently. Avoid hardcoding these credentials directly into the source code. Instead, use environment variables or a secure secrets management system to store and retrieve them.</li> <li>Input validation is conducted to mitigate the risk of malicious requests and potential security vulnerabilities.</li> <li>User authorization is rigorously enforced through the <code>@login_required</code> decorator, ensuring that only authenticated users can access payment-related functionalities.</li> <li>The <code>idempotency_key</code> plays a critical role in preventing duplicate transactions, thereby enhancing the system's reliability and preventing accidental charges.</li> <li>Database transactions are rolled back automatically whenever an error occurs to maintain data integrity and consistency.</li> <li>The payment capture logic incorporates a validation step to confirm that the order is in the <code>APPROVED</code> state before proceeding with the capture operation. Additionally, the system handles the <code>PAYER_ACTION_REQUIRED</code> status by redirecting the user to PayPal to complete any necessary verification or authorization steps.</li> </ul>"},{"location":"20_base/","title":"<code>base.html</code>","text":"<p>Purpose: This file defines the base HTML template for the entire web application. It establishes the foundational structure, consistent styling, and core JavaScript functionality shared across all pages. It also includes security features, particularly CSP and session timeout handling.</p> <p>Overview:</p> <p>As the base template, <code>base.html</code> provides the skeleton upon which all other pages are built. It encompasses the following critical components:</p> <ol> <li>HTML Document Structure: Sets up the basic HTML document, including the <code>&lt;!DOCTYPE html&gt;</code>, <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, and <code>&lt;body&gt;</code> elements.</li> <li>Metadata and Resources: Defines metadata (character set, viewport), includes external CSS stylesheets (Tailwind CSS, Material Symbols), and loads external JavaScript libraries (Tailwind CSS script, Google reCAPTCHA).</li> <li>CSS Styling:<ul> <li>Loads Tailwind CSS from a CDN for consistent, utility-based styling.</li> <li>Defines custom CSS classes for specific behaviors:<ul> <li><code>.fade-out</code>: Animation for fading out flash messages.</li> <li><code>.close-button</code>: Style for the close button on flash messages.</li> <li><code>.active-nav-link</code>: Style for active navigation links on desktop.</li> <li><code>.active-nav-link-mobile</code>: Style for active navigation links on mobile.</li> <li>Sticky footer styles to ensure the footer remains at the bottom of the page regardless of content length.</li> </ul> </li> </ul> </li> <li>Header and Navigation: Creates the header area, containing the site logo, main navigation links, and authentication-related actions (login, registration, logout, profile).</li> <li>Main Content Area: Defines the main content region where page-specific content will be inserted, using a Jinja2 <code>{% block content %}</code>.</li> <li>Footer: Implements the footer section with copyright information and links.</li> <li>Flash Message Handling: Displays flash messages (success or error messages) to provide user feedback, with a fade-out animation and close button.</li> <li>Session Timeout Warning: Integrates a session timeout warning and automatic logout mechanism to enhance security by preventing unattended sessions.</li> <li>JavaScript Functionality: Includes JavaScript code for mobile menu toggling, flash message handling, session timeout management, and Content Security Policy (CSP) enforcement.</li> </ol> <p>Key Components and Functionality:</p> <ol> <li> <p>Document Setup (<code>&lt;head&gt;</code>):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/&gt;\n    &lt;title&gt;{% block title %}VulnScanAI{% endblock %}&lt;/title&gt;\n\n    &lt;script src=\"https://cdn.tailwindcss.com\" nonce=\"{{ nonce }}\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://www.google.com/recaptcha/api.js\" async defer nonce=\"{{ nonce }}\"&gt;&lt;/script&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200\" /&gt;\n\n&lt;/head&gt;\n</code></pre> <ul> <li>Declares the document as HTML5 and sets the language to English.</li> <li>Configures the viewport for responsive design.</li> <li>Sets the page title dynamically using a Jinja2 block.</li> <li>Includes:<ul> <li>Tailwind CSS script from a CDN, utilizing a <code>nonce</code> attribute for CSP.</li> <li>Google reCAPTCHA API script, also with a <code>nonce</code> for CSP. This is important to ensure the script's integrity and prevent unauthorized execution.</li> <li>Google Material Symbols stylesheet.</li> </ul> </li> <li>CSS Styling (<code>&lt;style&gt;</code>):</li> </ul> <pre><code>&lt;style&gt;\n    .fade-out {\n        opacity: 0;\n        transition: opacity 1s ease-in-out;\n    }\n    .close-button {\n        cursor: pointer;\n    }\n    /* Define reusable active link styles */\n    .active-nav-link {\n       /* Style for active desktop link */\n       @apply text-blue-600 font-semibold border-b-2 border-blue-500;\n    }\n    .active-nav-link-mobile {\n       /* Style for active mobile link */\n       @apply bg-blue-100 text-blue-700 font-semibold;\n    }\n    /* Sticky Footer Styles */\n    body {\n        display: flex;\n        flex-direction: column;\n        min-height: 100vh;\n    }\n    main {\n        flex-grow: 1;\n    }\n&lt;/style&gt;\n</code></pre> <ul> <li>Defines CSS classes for flash message handling, active navigation links (desktop and mobile), and sticky footer styling. The <code>@apply</code> directive is from Tailwind CSS, allowing reuse of Tailwind classes in custom CSS.</li> </ul> </li> <li> <p>Header and Navigation (<code>&lt;header&gt;</code>):</p> <pre><code>&lt;header class=\"bg-white shadow-md py-4\"&gt;\n    &lt;div class=\"container mx-auto px-4\"&gt;\n        &lt;nav class=\"flex items-center justify-between\"&gt;\n            &lt;div&gt;\n                &lt;a href=\"{{ url_for('main.home') }}\" class=\"font-bold text-xl text-blue-600\"&gt;\n                    VulnScanAI\n                &lt;/a&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"hidden md:flex items-center space-x-6\"&gt;\n                &lt;a href=\"{{ url_for('main.home') }}\" class=\"pb-1 text-gray-700 hover:text-blue-600 transition duration-200 {% if request.endpoint == 'main.home' %} text-blue-600 font-semibold border-b-2 border-blue-500 {% endif %}\"&gt;Home&lt;/a&gt;\n                &lt;!-- ... other links ... --&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"md:hidden\"&gt;\n                &lt;button id=\"mobile-menu-button\" class=\"focus:outline-none\"&gt;\n                    &lt;svg class=\"h-6 w-6 text-gray-700\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\"&gt;\n                        &lt;path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 6h16M4 12h16M4 18h16\" /&gt;\n                    &lt;/svg&gt;\n                &lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/nav&gt;\n</code></pre> <ul> <li>Implements the header section with the site logo and navigation links.</li> <li>Utilizes <code>url_for()</code> to dynamically generate URLs, improving maintainability.</li> <li>Conditionally applies CSS classes based on the active route using Jinja2 (<code>{% if request.endpoint == 'main.home' %}</code>), highlighting the current page in the navigation.</li> <li>Includes a mobile menu button for smaller screens.</li> </ul> </li> <li> <p>Mobile Menu (<code>&lt;div id=\"mobile-menu\"&gt;</code>):</p> <pre><code>        &lt;div class=\"hidden md:hidden\" id=\"mobile-menu\"&gt;\n            &lt;div class=\"px-2 pt-2 pb-3 space-y-1 sm:px-3\"&gt;\n                 &lt;a href=\"{{ url_for('main.home') }}\" class=\"block text-gray-700 py-2 px-3 rounded-md text-base font-medium hover:bg-gray-200 {% if request.endpoint == 'main.home' %} text-blue-600 font-semibold border-b-2 border-blue-500 {% endif %}\"&gt;Home&lt;/a&gt;\n                &lt;!-- ... other links ... --&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre> <ul> <li>A collapsible menu for smaller screens. It mirrors the main navigation links.</li> <li>Initially hidden (<code>class=\"hidden md:hidden\"</code>) and toggled by JavaScript.</li> </ul> </li> <li> <p>Main Content Area (<code>&lt;main&gt;</code>):</p> <pre><code>&lt;main class=\"container mx-auto py-8 px-4\"&gt;\n    {% with messages = get_flashed_messages(with_categories=true) %}\n        {% if messages %}\n            &lt;div class=\"fixed top-16 right-4 space-y-2 z-50\"&gt;\n                {% for category, message in messages %}\n                    &lt;div class=\"relative px-4 py-2 rounded shadow {{ 'bg-green-500 text-white' if category == 'success' else 'bg-red-500 text-white' }}\" data-flash-message&gt;\n                        {{ message }}\n                        &lt;button type=\"button\" class=\"absolute top-0 right-0 p-1 text-white focus:outline-none close-button\" onclick=\"closeFlashMessage(this.parentNode)\"&gt;\n                            &lt;svg class=\"h-4 w-4 fill-current\" viewBox=\"0 0 20 20\"&gt;&lt;path fill-rule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\"/&gt;&lt;/svg&gt;\n                        &lt;/button&gt;\n                    &lt;/div&gt;\n                {% endfor %}\n            &lt;/div&gt;\n        {% endif %}\n    {% endwith %}\n\n    {% block content %}{% endblock %}\n&lt;/main&gt;\n</code></pre> <ul> <li>Defines the main content area using a <code>&lt;main&gt;</code> element.</li> <li>Contains the flash message rendering logic and the <code>{% block content %}</code> where page-specific content is injected.</li> <li>Uses the <code>container mx-auto py-8 px-4</code> classes to set max width, center content, and provide vertical and horizontal padding.</li> </ul> </li> <li> <p>Flash Message Handling:</p> <pre><code>    {% with messages = get_flashed_messages(with_categories=true) %}\n        {% if messages %}\n            &lt;div class=\"fixed top-16 right-4 space-y-2 z-50\"&gt;\n                {% for category, message in messages %}\n                    &lt;div class=\"relative px-4 py-2 rounded shadow {{ 'bg-green-500 text-white' if category == 'success' else 'bg-red-500 text-white' }}\" data-flash-message&gt;\n                        {{ message }}\n                        &lt;button type=\"button\" class=\"absolute top-0 right-0 p-1 text-white focus:outline-none close-button\" onclick=\"closeFlashMessage(this.parentNode)\"&gt;\n                            &lt;svg class=\"h-4 w-4 fill-current\" viewBox=\"0 0 20 20\"&gt;&lt;path fill-rule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\"/&gt;&lt;/svg&gt;\n                        &lt;/button&gt;\n                    &lt;/div&gt;\n                {% endfor %}\n            &lt;/div&gt;\n        {% endif %}\n    {% endwith %}\n</code></pre> <ul> <li>Retrieves flash messages using <code>get_flashed_messages(with_categories=true)</code>.</li> <li>Displays each message in a styled <code>div</code> element. The styling is category-dependent (success/error).</li> <li>Includes a close button (<code>&lt;button&gt;</code>) to allow users to dismiss the message manually.</li> <li>Uses JavaScript to fade out and remove the message after a delay. The messages are positioned fixed to the top right.</li> </ul> </li> <li> <p>Footer (<code>&lt;footer&gt;</code>):</p> <pre><code>&lt;footer class=\"bg-gray-200 py-4 text-center text-gray-600 mt-8\"&gt;\n    &lt;div class=\"container mx-auto px-4\"&gt;\n        &lt;p&gt;\u00a9 2025 VulnScanAI. All rights reserved.&lt;/p&gt;\n        &lt;p class=\"text-sm mt-1\"&gt;Product of iSec Services Pvt. Ltd. \u00a9 2025&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/footer&gt;\n</code></pre> <ul> <li>Creates the footer section, including copyright information.</li> </ul> </li> <li> <p>Session Timeout Warning (<code>&lt;div id=\"session-timeout-warning\"&gt;</code>):</p> <pre><code>&lt;div id=\"session-timeout-warning\" style=\"display: none; position: fixed; bottom: 0; left: 0; width: 100%; background-color: #f8d7da; color: #721c24; padding: 10px; text-align: center; z-index: 1000;\"&gt;\n    Session will expire in &lt;span id=\"timeout-countdown\"&gt;&lt;/span&gt; seconds.\n    &lt;button id=\"session-extend-button\" class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-1 px-2 rounded ml-2 focus:outline-none focus:shadow-outline\"&gt;Stay Logged In&lt;/button&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li>Implements the session timeout warning, which is initially hidden and made visible by JavaScript when the session is about to expire.</li> <li>The <code>&lt;span id=\"timeout-countdown\"&gt;</code> displays the remaining time.</li> <li>The <code>&lt;button id=\"session-extend-button\"&gt;</code> allows users to extend their session, preventing automatic logout.</li> </ul> </li> <li> <p>JavaScript (<code>&lt;script&gt;</code>):</p> <pre><code>&lt;script nonce=\"{{ nonce }}\"&gt;\n\n\n    const BASE_URL = '/vulnscanai';\n    const mobileMenuButton = document.getElementById('mobile-menu-button');\n    const mobileMenu = document.getElementById('mobile-menu');\n    const flashMessages = document.querySelectorAll('[data-flash-message]');\n    const sessionTimeout = 30 * 60 * 1000; // 30 minutes in milliseconds\n    const warningTime = 2 * 60 * 1000;    // 2 minutes in milliseconds\n    let timeoutId;\n    let timerStartTime;\n    const timeoutWarningDiv = document.getElementById('session-timeout-warning');\n    const timeoutCountdownSpan = document.getElementById('timeout-countdown');\n    const sessionExtendButton = document.getElementById('session-extend-button');\n    let isLoggedIn = {{ current_user.is_authenticated|lower }}; // Get logged_in status\n\n    if (mobileMenuButton &amp;&amp; mobileMenu) {\n        mobileMenuButton.addEventListener('click', () =&gt; {\n            mobileMenu.classList.toggle('hidden');\n        });\n    }\n\n    function closeFlashMessage(element) {\n        element.classList.add('fade-out');\n        setTimeout(() =&gt; {\n            element.remove();\n        }, 1000); // Remove after the fade-out animation\n    }\n\n    document.addEventListener('DOMContentLoaded', () =&gt; {\n        flashMessages.forEach(message =&gt; {\n            setTimeout(() =&gt; {\n                if (message.parentNode) {\n                     closeFlashMessage(message);\n                }\n            }, 10000);\n        });\n\n        document.querySelectorAll('.close-button').forEach(button =&gt; {\n            button.addEventListener('click', () =&gt; {\n                closeFlashMessage(button.closest('[data-flash-message]'));\n            });\n        });\n\n        if (isLoggedIn) {\n            startSessionTimer();\n\n            function resetTimer() {\n                clearTimeout(timeoutId);\n                timeoutWarningDiv.style.display = 'none';\n                timerStartTime = Date.now();\n                startSessionTimer();\n            }\n\n            function logoutUser() {\n                window.location.href = '/vulnscanai/logout'; // Your logout route\n            }\n\n            function displayWarning(remainingTime) {\n                timeoutCountdownSpan.textContent = Math.ceil(remainingTime / 1000);\n                timeoutWarningDiv.style.display = 'block';\n            }\n\n            function startSessionTimer() {\n                timerStartTime = Date.now();\n                timeoutId = setTimeout(() =&gt; {\n                    logoutUser();\n                }, sessionTimeout);\n\n                // Display warning before logout\n                setTimeout(() =&gt; {\n                    const remaining = sessionTimeout - warningTime;\n                    displayWarning(remaining);\n                    let countdownInterval = setInterval(() =&gt; {\n                        const remainingNow = sessionTimeout - (Date.now() - timerStartTime);\n                        if (remainingNow &lt;= 0) {\n                            clearInterval(countdownInterval);\n                            return;\n                        }\n                        timeoutCountdownSpan.textContent = Math.ceil(remainingNow / 1000);\n                    }, 1000);\n                }, sessionTimeout - warningTime);\n            }\n\n            // document.addEventListener('mousemove', resetTimer);\n            // document.addEventListener('keydown', resetTimer);\n            // document.addEventListener('scroll', resetTimer);\n            // document.addEventListener('click', resetTimer);\n\n            if (sessionExtendButton) {\n                sessionExtendButton.addEventListener('click', (event) =&gt; {\n                    event.preventDefault();\n                    resetTimer();\n                });\n            }\n        }\n    });\n&lt;/script&gt;\n</code></pre> <ul> <li>Toggles the mobile menu visibility when the menu button is clicked.</li> <li>Implements the <code>closeFlashMessage</code> function to fade out and remove flash messages.</li> <li>Sets a timeout to automatically close flash messages.</li> <li>Handles flash message close button clicks.</li> <li>Manages the session timeout warning and automatic logout:<ul> <li>Determines if a user is logged in (<code>isLoggedIn</code>).</li> <li><code>startSessionTimer</code> function starts a timer that will log the user out after a period of inactivity.</li> <li>A separate timer displays a warning message before the user is logged out.</li> <li>Clicking the \"Stay Logged In\" button resets the timer.</li> <li>The commented-out section includes event listeners intended to reset the timer on user interaction (mousemove, keydown, scroll, click). This functionality may be present but currently disabled in the code.</li> </ul> </li> <li>Adds <code>nonce=\"{{ nonce }}\"</code> to the script tag itself to allow the script to be whitelisted under a Content Security Policy (CSP). Each inline script on the page should have a unique nonce.</li> </ul> </li> </ol> <p>Key Concepts:</p> <ul> <li>Template Inheritance: Foundation for code reuse and consistency across the application.</li> <li>Jinja2 Templating:  Enables dynamic content insertion and conditional rendering.</li> <li>Tailwind CSS:  A utility-first CSS framework, for rapidly styling the user interface.</li> <li>Responsive Design: Using responsive meta tags and Tailwind CSS classes to create a layout that adapts to different screen sizes.</li> <li>Flash Messages: Providing feedback to users about the result of their actions.</li> <li>Session Timeout: Automatically logging out inactive users for security reasons.</li> <li>Content Security Policy (CSP): A mechanism to mitigate cross-site scripting (XSS) attacks by whitelisting trusted sources of content. The <code>nonce</code> attribute is crucial for inline scripts when using CSP.</li> </ul>"},{"location":"21_home/","title":"<code>home.html</code>","text":"<p>Purpose: This file defines the HTML template for the application's homepage, aiming to provide a compelling introduction to VulnScanAI and encourage user engagement. It extends the base template (<code>base.html</code>) and uses Jinja2 for dynamic content and Tailwind CSS for styling.</p> <p>Overview:</p> <p>The <code>home.html</code> template is designed to be the first page users see and thus is structured to:</p> <ol> <li>Capture Attention: Use a visually appealing hero section with a clear value proposition.</li> <li>Highlight Key Features: Showcase the core capabilities of VulnScanAI.</li> <li>Explain the Process: Demystify the application's workflow.</li> <li>Drive User Action: Encourage users to initiate a scan or contact the team.</li> </ol> <p>Key Components and Functionality:</p> <ol> <li> <p>Template Inheritance: Extends the base template, inheriting the core page structure and styling.</p> <pre><code>{% extends 'base.html' %}\n</code></pre> </li> <li> <p>Title Block: Sets the page title.</p> <pre><code>{% block title %}Home - VulnScanAI{% endblock %}\n</code></pre> </li> <li> <p>Content Block: Defines the page's main content within the <code>{% block content %}</code> block.</p> <pre><code>{% block content %}\n&lt;/section&gt;\n{% endblock %}\n</code></pre> </li> <li> <p>Hero Section:</p> <pre><code>&lt;section class=\"bg-gradient-to-br from-blue-100 via-blue-300 to-white py-20 rounded-lg\"&gt;\n    &lt;div class=\"container mx-auto text-center\"&gt;\n        &lt;h1 class=\"text-4xl font-bold text-blue-700 mb-6\"&gt;Detect, Protect and Prevent with VulnScanAI&lt;/h1&gt;\n        &lt;p class=\"text-lg text-gray-700 mb-10\"&gt;Harness the power of AI-driven vulnerability scanning and proactive security insights to protect your digital assets.&lt;/p&gt;\n        &lt;div class=\"flex justify-center space-x-4\"&gt;\n            {% if not current_user.is_authenticated or (current_user.is_authenticated and current_user.subscription_id == 1) %}\n            &lt;a href=\"{{url_for('main.scan')}}\" class=\"bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-8 rounded-full transition duration-300\"&gt;Start Free Scan&lt;/a&gt;\n            &lt;a href=\"{{ url_for('main.pricing') }}\" class=\"bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-8 rounded-full transition duration-300\"&gt;Explore Pricing&lt;/a&gt;\n            {% else %}\n            &lt;a href=\"{{url_for('main.scan')}}\" class=\"bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-8 rounded-full transition duration-300\"&gt;Start Scan&lt;/a&gt;\n            {% endif %}\n\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/section&gt;\n</code></pre> <ul> <li>Creates an eye-catching introduction using a gradient background.</li> <li>Presents the core value proposition in a concise headline and description.</li> <li>Displays dynamic call-to-action buttons:<ul> <li>Uses Jinja2 conditionals to show \"Start Free Scan\" and \"Explore Pricing\" if the user is not authenticated or is authenticated but on the basic (subscription ID 1) plan.</li> <li>Shows only \"Start Scan\" for authenticated users with a paid subscription.</li> </ul> </li> </ul> </li> <li> <p>Key Features Section:</p> <pre><code>&lt;section class=\"py-16 bg-gray-100\"&gt;\n    &lt;div class=\"container mx-auto text-center\"&gt;\n        &lt;h2 class=\"text-3xl font-bold text-gray-800 mb-8\"&gt;Key Features of VulnScanAI&lt;/h2&gt;\n        &lt;div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8\"&gt;\n            &lt;div class=\"bg-white rounded-lg shadow-md p-6\"&gt;\n                &lt;div class=\"text-blue-500 mb-4\"&gt;\n                    &lt;span class=\"material-symbols-outlined text-4xl\" style=\"color: #2196F3;\"&gt;bolt&lt;/span&gt;\n                &lt;/div&gt;\n                &lt;h3 class=\"text-xl font-semibold text-gray-700 mb-2\"&gt;AI-Powered Scanning&lt;/h3&gt;\n                &lt;p class=\"text-gray-600\"&gt;Leverage cutting-edge artificial intelligence to identify vulnerabilities with greater accuracy and efficiency.&lt;/p&gt;\n            &lt;/div&gt;\n            &lt;!-- ... other feature boxes ... --&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/section&gt;\n</code></pre> <ul> <li>Showcases the key selling points using a grid layout for visual appeal.</li> <li>Each feature includes:<ul> <li>A Google Material Symbol for quick visual recognition.</li> <li>A concise title highlighting the benefit.</li> <li>A short description elaborating on the feature.</li> </ul> </li> </ul> </li> <li> <p>How It Works Section:</p> <pre><code>&lt;section class=\"py-16 bg-blue-50 rounded-t-lg\"&gt;\n    &lt;div class=\"container mx-auto text-center\"&gt;\n        &lt;h2 class=\"text-3xl font-bold text-blue-700 mb-8\"&gt;How VulnScanAI Works&lt;/h2&gt;\n        &lt;div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-12\"&gt;\n            &lt;div class=\"p-6\"&gt;\n                &lt;div class=\"rounded-full bg-blue-200 w-16 h-16 flex items-center justify-center mx-auto mb-4\"&gt;\n                    &lt;span class=\"material-symbols-outlined text-2xl text-blue-700\"&gt;play_arrow&lt;/span&gt;\n                &lt;/div&gt;\n                &lt;h4 class=\"text-xl font-semibold text-gray-800 mb-2\"&gt;Initiate Scan&lt;/h4&gt;\n                &lt;p class=\"text-gray-600\"&gt;Simply provide the target (URL, IP, etc.) you want to assess.&lt;/p&gt;\n            &lt;/div&gt;\n            &lt;!-- ... other steps ... --&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/section&gt;\n</code></pre> <ul> <li>Simplifies the application workflow into easily understandable steps.</li> <li>Each step includes:<ul> <li>A Google Material Symbol to represent the action.</li> <li>A brief, descriptive title.</li> <li>A concise description of what's involved in each step.</li> </ul> </li> </ul> </li> <li> <p>Final Call to Action Section:</p> <pre><code>&lt;section class=\"py-16 bg-white rounded-b-lg\"&gt;\n    &lt;div class=\"container mx-auto text-center\"&gt;\n        &lt;h2 class=\"text-3xl font-bold text-gray-800 mb-8\"&gt;Ready to Enhance Your Security?&lt;/h2&gt;\n        &lt;p class=\"text-lg text-gray-700 mb-6\"&gt;Join thousands of businesses and security professionals who trust VulnScanAI for their vulnerability management needs.&lt;/p&gt;\n        &lt;div class=\"flex justify-center space-x-4\"&gt;\n            {% if not current_user.is_authenticated or (current_user.is_authenticated and current_user.subscription_id == 1) %}\n                &lt;a href=\"{{ url_for('main.scan') }}\" class=\"bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-8 rounded-full transition duration-300\"&gt;Start Your Free Scan&lt;/a&gt;\n            {% else %}\n                &lt;a href=\"{{ url_for('main.scan') }}\" class=\"bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-8 rounded-full transition duration-300\"&gt;Start Scan&lt;/a&gt;\n            {% endif %}\n            &lt;a href=\"{{ url_for('main.contact_us') }}\" class=\"bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-3 px-8 rounded-full transition duration-300\"&gt;Contact Us&lt;/a&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/section&gt;\n</code></pre> <ul> <li>Reiterates the value proposition and provides final call-to-action buttons.</li> <li>The conditional logic ensures appropriate actions for different user states based on authentication and subscription status.</li> </ul> </li> </ol> <p>Key Concepts Used:</p> <ul> <li>Template Inheritance:  Extending <code>base.html</code> ensures consistency and reduces code duplication.</li> <li>Jinja2: Enables dynamic content rendering, including:<ul> <li><code>url_for()</code>: Dynamic URL generation.</li> <li><code>{% if ... %}</code>: Conditional logic for displaying content based on user authentication and subscription status.</li> </ul> </li> <li>Tailwind CSS: Provides a responsive and visually appealing layout.</li> <li>Google Material Symbols: Adds recognizable icons to improve visual communication.</li> </ul>"},{"location":"22_about/","title":"<code>about.html</code>","text":"<p>Purpose: This file defines the HTML template for the \"About Us\" page, designed to inform visitors about VulnScanAI's mission, background, and technical capabilities. It extends the <code>base.html</code> template for consistent styling and structure, and utilizes Jinja2 for dynamic content.</p> <p>Overview:</p> <p>The <code>about.html</code> template aims to establish trust and credibility by providing details on:</p> <ol> <li>VulnScanAI's Vision: A clear statement of the application's goals and guiding principles.</li> <li>iSec Services Pvt. Ltd.: Information about the cybersecurity firm behind VulnScanAI, highlighting their expertise and experience.</li> <li>Scanning Suite Details: A comprehensive breakdown of the open-source tools and scanning types integrated into VulnScanAI.</li> </ol> <p>Key Components and Functionality:</p> <ol> <li> <p>Template Inheritance: Leverages template inheritance from <code>base.html</code>.</p> <pre><code>{% extends 'base.html' %}\n</code></pre> </li> <li> <p>Title Block: Sets the page-specific title.</p> <pre><code>{% block title %}About Us - VulnScanAI{% endblock %}\n</code></pre> </li> <li> <p>Content Block: Injects the \"About Us\" content into the base template's content area.</p> <pre><code>{% block content %}\n&lt;/section&gt;\n{% endblock %}\n</code></pre> </li> <li> <p>Page Structure: The main content is organized within a <code>&lt;section&gt;</code> element for clear layout, leveraging Tailwind CSS classes for styling.</p> <pre><code>&lt;section class=\"bg-gray-100 py-16\"&gt;\n    &lt;div class=\"container mx-auto px-4\"&gt;\n        &lt;!-- Content here --&gt;\n    &lt;/div&gt;\n&lt;/section&gt;\n</code></pre> </li> <li> <p>Vision and Company Information: Presents the core values and background.</p> <pre><code>&lt;div class=\"bg-white rounded-lg shadow-md p-8 mb-8\"&gt;\n    &lt;h2 class=\"text-2xl font-semibold text-gray-800 mb-4\"&gt;Our Vision&lt;/h2&gt;\n    &lt;p class=\"text-lg text-gray-700 mb-6\"&gt;At VulnScanAI, our vision is to empower organizations of all sizes with proactive and intelligent cybersecurity solutions. We believe that security should be accessible, efficient, and driven by the latest advancements in artificial intelligence. Our goal is to simplify the complex landscape of vulnerability management, enabling you to focus on your core business with confidence.&lt;/p&gt;\n\n    &lt;h2 class=\"text-2xl font-semibold text-gray-800 mb-4\"&gt;About iSec Services Pvt. Ltd.&lt;/h2&gt;\n    &lt;p class=\"text-lg text-gray-700 mb-6\"&gt;VulnScanAI is a proud product of &lt;span class=\"font-semibold text-blue-600\"&gt;iSec Services Pvt. Ltd.&lt;/span&gt;, a leading cybersecurity firm dedicated to providing comprehensive security solutions and expert consulting. With years of experience in threat intelligence, penetration testing, and security architecture, iSec Services brings a wealth of knowledge and expertise to the development and support of VulnScanAI. Our deep understanding of real-world security challenges drives us to create tools that are both powerful and practical.&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li>The <code>bg-white</code>, <code>rounded-lg</code>, <code>shadow-md</code>, and <code>p-8</code> Tailwind classes provide consistent styling.</li> <li>Clear headings and paragraphs convey the information.</li> </ul> </li> <li> <p>Scanning Suite Details: Offers a technical overview of the application's capabilities.</p> <pre><code>&lt;div class=\"bg-white rounded-lg shadow-md p-8\"&gt;\n    &lt;h2 class=\"text-2xl font-semibold text-gray-800 mb-6\"&gt;VulnScanAI Scanning Suite&lt;/h2&gt;\n    &lt;p class=\"text-lg text-gray-700 mb-8\"&gt;VulnScanAI integrates a suite of powerful open-source tools to provide comprehensive vulnerability scanning across various domains. Here's a breakdown of the scanning types and tools included:&lt;/p&gt;\n\n    &lt;div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\"&gt;\n        &lt;div class=\"border rounded-lg p-6 bg-gray-50 hover:shadow-md transition-shadow\"&gt;\n            &lt;h3 class=\"text-xl font-semibold text-blue-600 mb-2\"&gt;Network Scanning&lt;/h3&gt;\n            &lt;p class=\"text-gray-700 mb-4\"&gt;Assess the security of your network infrastructure by identifying open ports, services, and potential vulnerabilities.&lt;/p&gt;\n            &lt;ul class=\"list-disc list-inside text-gray-600\"&gt;\n                &lt;li&gt;&lt;span class=\"font-semibold\"&gt;Nmap:&lt;/span&gt; A versatile network scanner used for port scanning, OS detection, service discovery, and more.&lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/div&gt;\n        &lt;!-- ... other scanning types and tools ... --&gt;\n    &lt;/div&gt;\n    &lt;p class=\"text-lg text-gray-700 mt-8\"&gt;By leveraging these industry-standard tools, VulnScanAI provides a comprehensive and reliable vulnerability assessment platform. We continuously update our platform to incorporate the latest security tools and techniques, ensuring that you have access to the best possible protection.&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li>Presents scanning types and associated tools in a structured grid.</li> <li>Each scanning type includes:<ul> <li>A title in a blue color.</li> <li>A description outlining the scanning capabilities.</li> <li>A list of specific tools (e.g., Nmap, ZAP, MobSF).</li> <li>Tailwind classes are used for styling the layout and hover effects.</li> </ul> </li> </ul> </li> </ol> <p>Key Concepts:</p> <ul> <li>Template Inheritance:  A key principle for maintaining a consistent look and feel across the application.</li> <li>Jinja2: Used to dynamically insert content into the template.</li> <li>Tailwind CSS: Provides a utility-first approach to styling, enabling rapid UI development.</li> <li>Modular Design: Separating the content into distinct sections for improved readability and maintainability.</li> </ul>"},{"location":"23_contact_us/","title":"<code>contact_us.html</code>","text":"<p>Purpose: This file defines the HTML template for the \"Contact Us\" page, enabling users to submit inquiries or feedback. It leverages Flask-WTF for form handling, Jinja2 for rendering, Tailwind CSS for styling, and reCAPTCHA to mitigate spam.</p> <p>Overview:</p> <p>The <code>contact_us.html</code> template presents a contact form with the following features:</p> <ul> <li>User Input: Provides a structured form for users to enter their name, email, subject, and message.</li> <li>Form Validation: Utilizes WTForms validators, displaying error messages inline with the respective form fields.</li> <li>reCAPTCHA Integration: Implements Google reCAPTCHA to deter automated submissions.</li> <li>Styling with Tailwind CSS: Leverages Tailwind CSS classes to create a visually appealing and responsive form layout.</li> <li>CSRF Protection: Incorporates CSRF protection to prevent cross-site request forgery attacks.</li> </ul> <p>Key Components and Functionality:</p> <ol> <li> <p>Template Inheritance: The template extends <code>base.html</code>, inheriting the base layout and styling.</p> <pre><code>{% extends 'base.html' %}\n</code></pre> </li> <li> <p>Title Block: Overrides the title for this specific page.</p> <pre><code>{% block title %}Contact Us - VulnScanAI{% endblock %}\n</code></pre> </li> <li> <p>Content Block: Defines the main content within the <code>{% block content %}{% endblock %}</code> block.</p> <pre><code>{% block content %}\n&lt;/section&gt;\n{% endblock %}\n</code></pre> </li> <li> <p>Page Structure and Form Container: The content is organized within a <code>&lt;section&gt;</code> that provides padding and background color. The form is placed within a <code>div</code> to control width, centering, and styling.</p> <pre><code>&lt;section class=\"bg-gray-100 py-16\"&gt;\n    &lt;div class=\"container mx-auto px-4\"&gt;\n        &lt;h1 class=\"text-4xl font-bold text-blue-700 text-center mb-8\"&gt;Contact Us&lt;/h1&gt;\n        &lt;p class=\"text-lg text-gray-700 text-center mb-6\"&gt;We'd love to hear from you! Please fill out the form below and we'll get back to you as soon as possible.&lt;/p&gt;\n\n        &lt;div class=\"bg-white rounded-lg shadow-md p-8 max-w-lg mx-auto\"&gt;\n           &lt;/form&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/section&gt;\n</code></pre> </li> <li> <p>Form Rendering: The form is rendered using Flask-WTF and Jinja2:</p> <pre><code>        &lt;form method=\"POST\"&gt;\n            {{ form.hidden_tag() }}\n\n            &lt;!-- Form fields will go here --&gt;\n\n            &lt;div class=\"flex items-center justify-between\"&gt;\n                &lt;button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"submit\"&gt;\n                    Send Message\n                &lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n</code></pre> <ul> <li><code>{{ form.hidden_tag() }}</code>:  Includes the CSRF token for security.  This is automatically generated by Flask-WTF.</li> <li>The <code>&lt;form method=\"POST\"&gt;</code> tag indicates that the form data will be submitted using the POST method.</li> </ul> </li> <li> <p>Individual Form Fields: Each form field consists of a label, the input field itself, and an area to display validation errors.</p> <ul> <li> <p>Name Field:</p> <pre><code>&lt;div class=\"mb-4\"&gt;\n    &lt;label for=\"{{ form.name.id_for }}\" class=\"block text-gray-700 text-sm font-bold mb-2\"&gt;Your Name&lt;/label&gt;\n    {{ form.name(class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\") }}\n    {% if form.errors.name %}\n        &lt;p class=\"text-red-500 text-xs italic\"&gt;{{ form.errors.name|join(', ') }}&lt;/p&gt;\n    {% endif %}\n&lt;/div&gt;\n</code></pre> <ul> <li><code>&lt;label for=\"{{ form.name.id_for }}\"&gt;</code>:  The <code>for</code> attribute of the <code>&lt;label&gt;</code> tag is dynamically generated using <code>form.name.id_for</code> to ensure it correctly points to the input field.</li> <li><code>{{ form.name(...) }}</code>: Renders the input field with CSS classes applied for styling. The classes provide shadow, appearance reset, border, rounding, width, padding, text color, and focus effects.</li> <li><code>{% if form.errors.name %}</code>: Conditionally renders error messages.</li> <li><code>&lt;p class=\"text-red-500 text-xs italic\"&gt;{{ form.errors.name|join(', ') }}&lt;/p&gt;</code>: Displays any errors associated with the \"name\" field.</li> </ul> </li> <li> <p>Email Field:  The email field rendering is identical to the name field, except it targets <code>form.email</code> and includes error handling specific to the email field.</p> <pre><code>&lt;div class=\"mb-4\"&gt;\n    &lt;label for=\"{{ form.email.id_for }}\" class=\"block text-gray-700 text-sm font-bold mb-2\"&gt;Your Email&lt;/label&gt;\n    {{ form.email(class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\") }}\n    {% if form.errors.email %}\n        &lt;p class=\"text-red-500 text-xs italic\"&gt;{{ form.errors.email|join(', ') }}&lt;/p&gt;\n    {% endif %}\n&lt;/div&gt;\n</code></pre> </li> <li> <p>Subject Field:</p> <pre><code>&lt;div class=\"mb-4\"&gt;\n    &lt;label for=\"{{ form.subject.id_for }}\" class=\"block text-gray-700 text-sm font-bold mb-2\"&gt;Subject&lt;/label&gt;\n    {{ form.subject(class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\") }}\n    {% if form.errors.subject %}\n        &lt;p class=\"text-red-500 text-xs italic\"&gt;{{ form.errors.subject|join(', ') }}&lt;/p&gt;\n    {% endif %}\n&lt;/div&gt;\n</code></pre> </li> <li> <p>Message Field: A text area field for the message body.</p> <pre><code>&lt;div class=\"mb-6\"&gt;\n    &lt;label for=\"{{ form.message.id_for }}\" class=\"block text-gray-700 text-sm font-bold mb-2\"&gt;Message&lt;/label&gt;\n    {{ form.message(class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline h-32 resize-none\") }}\n    {% if form.errors.message %}\n        &lt;p class=\"text-red-500 text-xs italic\"&gt;{{ form.errors.message|join(', ') }}&lt;/p&gt;\n    {% endif %}\n&lt;/div&gt;\n</code></pre> <ul> <li>The class <code>h-32</code> sets the height of the textarea, and <code>resize-none</code> prevents users from manually resizing the area.</li> </ul> </li> </ul> </li> <li> <p>reCAPTCHA Integration:</p> <pre><code>&lt;div class=\"mb-6\"&gt;\n    &lt;div class=\"g-recaptcha\" data-sitekey=\"{{ config['RECAPTCHA_PUBLIC_KEY'] }}\"&gt;&lt;/div&gt;\n    {% if form.errors.recaptcha %}\n        &lt;p class=\"text-red-500 text-xs italic\"&gt;{{ form.errors.recaptcha|join(', ') }}&lt;/p&gt;\n    {% endif %}\n&lt;/div&gt;\n</code></pre> <ul> <li><code>&lt;div class=\"g-recaptcha\" data-sitekey=\"{{ config['RECAPTCHA_PUBLIC_KEY'] }}\"&gt;&lt;/div&gt;</code>:  Renders the reCAPTCHA widget, utilizing the <code>RECAPTCHA_PUBLIC_KEY</code> from the Flask app configuration.</li> <li><code>config['RECAPTCHA_PUBLIC_KEY']</code>: This accesses the RECAPTCHA public key set in the application's configuration. You'll need to ensure this is set in your Flask configuration file.</li> <li>Error display is included if reCAPTCHA validation fails.</li> </ul> </li> <li> <p>Submit Button:</p> <pre><code>&lt;div class=\"flex items-center justify-between\"&gt;\n    &lt;button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"submit\"&gt;\n        Send Message\n    &lt;/button&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li>Defines the submit button with specific Tailwind CSS classes for styling.</li> </ul> </li> </ol> <p>Key Concepts:</p> <ul> <li>Flask-WTF: Enables seamless integration with WTForms and handles form-related tasks in Flask.</li> <li>WTForms: Creates and validates the structure of forms. It offers a large set of validation utils.</li> <li>Jinja2: Used for generating dynamic HTML content and rendering the forms and its elements</li> <li>Tailwind CSS: A utility-first CSS framework used for styling UI elements with pre-defined classes.</li> <li>reCAPTCHA: An anti-bot service used to prevent spam submissions.</li> <li>CSRF Protection: Is essential for securing the forms, it is handled by Flask-WTF using the statement <code>{{ form.hidden_tag() }}</code></li> </ul>"},{"location":"24_request_demo/","title":"<code>request_demo.html</code>","text":"<p>Purpose: This file defines the HTML template for the \"Request a Demo\" page, enabling potential customers to submit a form expressing interest in a product demonstration. It extends the <code>base.html</code> template and integrates client-side validation using JavaScript alongside server-side validation through Flask-WTF.</p> <p>Overview:</p> <p>The <code>request_demo.html</code> template provides a user-friendly interface for requesting a demo. It features:</p> <ol> <li>Clear and Concise Information: Provides a brief explanation of the demo request process.</li> <li>Contact Form: A well-structured form for collecting user information, including email, country code, and phone number.</li> <li>Client-Side Validation: Implements JavaScript validation to provide immediate feedback to users before form submission.</li> <li>Server-Side Validation: Integrates with Flask-WTF for server-side validation and display of any errors.</li> <li>reCAPTCHA Integration: Incorporates Google reCAPTCHA to prevent automated form submissions.</li> <li>Tailwind CSS Styling: Utilizes Tailwind CSS for a visually appealing and responsive design.</li> <li>Two column layout for phone and country code: A responsive two-column layout created using Tailwind CSS.</li> </ol> <p>Key Components and Functionality:</p> <ol> <li> <p>Template Inheritance: Extends the base template, inheriting core structure and styles.</p> <pre><code>{% extends 'base.html' %}\n</code></pre> </li> <li> <p>Title Block: Sets the page-specific title.</p> <pre><code>{% block title %}Request Demo - VulnScanAI{% endblock %}\n</code></pre> </li> <li> <p>Content Block: Defines the page's main content.</p> <pre><code>{% block content %}\n&lt;/section&gt;\n{% endblock %}\n</code></pre> </li> <li> <p>Page Structure and Form Container: Sets up the page layout and the main form container.</p> <pre><code>&lt;section class=\"bg-gray-100 py-16\"&gt;\n    &lt;div class=\"container mx-auto px-4\"&gt;\n        &lt;h1 class=\"text-4xl font-bold text-blue-700 text-center mb-8\"&gt;Request a Demo&lt;/h1&gt;\n        &lt;p class=\"text-lg text-gray-700 text-center mb-6\"&gt;Interested in seeing VulnScanAI in action? Please fill out the form below to request a demo.&lt;/p&gt;\n\n        &lt;div class=\"bg-white rounded-lg shadow-md p-8 max-w-lg mx-auto\"&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/section&gt;\n</code></pre> </li> <li> <p>Form Rendering: The form itself is rendered using Jinja2, with the <code>form.hidden_tag()</code> for CSRF protection.</p> <pre><code>   &lt;form method=\"POST\" onsubmit=\"return validateForm()\"&gt;\n            {{ form.hidden_tag() }}\n\n            &lt;!-- Form fields will go here --&gt;\n\n            &lt;div class=\"flex items-center justify-between\"&gt;\n                &lt;button class=\"bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"submit\"&gt;\n                    Request Demo\n                &lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n</code></pre> <ul> <li>The <code>onsubmit=\"return validateForm()\"</code> attribute calls the JavaScript validation function before submission.</li> </ul> </li> <li> <p>Form Fields and Validation:</p> <ul> <li> <p>Email Field: Includes the label, input, error display (for both JavaScript and Flask-WTF validation).</p> <pre><code>&lt;div class=\"mb-4\"&gt;\n    &lt;label for=\"{{ form.email.id_for }}\" class=\"block text-gray-700 text-sm font-bold mb-2\"&gt;Your Email&lt;/label&gt;\n    {{ form.email(class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\", id=\"email\") }}\n    &lt;p id=\"emailError\" class=\"text-red-500 text-xs italic hidden\"&gt;&lt;/p&gt;\n    {% if form.errors.email %}\n        &lt;p class=\"text-red-500 text-xs italic\"&gt;{{ form.errors.email|join(', ') }}&lt;/p&gt;\n    {% endif %}\n&lt;/div&gt;\n</code></pre> </li> <li> <p>Country Code and Phone Number: are in a grid layout, and include the validation.</p> <pre><code>&lt;div class=\"mb-4 grid grid-cols-2 gap-4 items-start\"&gt;\n    &lt;div&gt;\n        &lt;label for=\"{{ form.country_code.id_for }}\" class=\"block text-gray-700 text-sm font-bold mb-2\"&gt;Country Code&lt;/label&gt;\n        &lt;div class=\"relative\"&gt;\n            &lt;select id=\"{{ form.country_code.id_for }}\" name=\"{{ form.country_code.name }}\" class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" id=\"countryCode\"&gt;\n                &lt;option value=\"\" disabled selected&gt;Select Code&lt;/option&gt;\n                &lt;option value=\"+1\"&gt;+1 (USA/Canada)&lt;/option&gt;\n                &lt;option value=\"+44\"&gt;+44 (UK)&lt;/option&gt;\n                &lt;option value=\"+91\"&gt;+91 (India)&lt;/option&gt;\n                &lt;option value=\"+86\"&gt;+86 (China)&lt;/option&gt;\n                &lt;option value=\"+61\"&gt;+61 (Australia)&lt;/option&gt;\n                &lt;option value=\"+55\"&gt;+55 (Brazil)&lt;/option&gt;\n                &lt;option value=\"+81\"&gt;+81 (Japan)&lt;/option&gt;\n                &lt;option value=\"+33\"&gt;+33 (France)&lt;/option&gt;\n                &lt;option value=\"+49\"&gt;+49 (Germany)&lt;/option&gt;\n                &lt;option value=\"+52\"&gt;+52 (Mexico)&lt;/option&gt;\n                &lt;/select&gt;\n            &lt;div class=\"pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700\"&gt;\n                &lt;svg class=\"fill-current h-4 w-4\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\"&gt;&lt;path d=\"M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z\"/&gt;&lt;/svg&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;p id=\"countryCodeError\" class=\"text-red-500 text-xs italic hidden\"&gt;&lt;/p&gt;\n        {% if form.errors.country_code %}\n            &lt;p class=\"text-red-500 text-xs italic\"&gt;{{ form.errors.country_code|join(', ') }}&lt;/p&gt;\n        {% endif %}\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;label for=\"{{ form.phone_number.id_for }}\" class=\"block text-gray-700 text-sm font-bold mb-2\"&gt;Phone Number&lt;/label&gt;\n        {{ form.phone_number(class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\", id=\"phoneNumber\") }}\n        &lt;p id=\"phoneNumberError\" class=\"text-red-500 text-xs italic hidden\"&gt;&lt;/p&gt;\n        {% if form.errors.phone_number %}\n            &lt;p class=\"text-red-500 text-xs italic\"&gt;{{ form.errors.phone_number|join(', ') }}&lt;/p&gt;\n        {% endif %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li><code>class=\"grid grid-cols-2 gap-4 items-start\"</code> Creates a two-column layout on medium-sized screens and above with a gap between columns and aligned at the top.</li> </ul> </li> </ul> </li> <li> <p>reCAPTCHA Integration:</p> <pre><code>&lt;div class=\"mb-6\"&gt;\n    &lt;div class=\"g-recaptcha\" data-sitekey=\"{{ config['RECAPTCHA_PUBLIC_KEY'] }}\"&gt;&lt;/div&gt;\n    {% if recaptcha_error %}\n        &lt;p class=\"text-red-500 text-xs italic\"&gt;{{ recaptcha_error }}&lt;/p&gt;\n    {% endif %}\n&lt;/div&gt;\n</code></pre> <ul> <li>Includes the Google reCAPTCHA widget.</li> </ul> </li> <li> <p>Submit Button:</p> <pre><code>&lt;div class=\"flex items-center justify-between\"&gt;\n    &lt;button class=\"bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline\" type=\"submit\"&gt;\n        Request Demo\n    &lt;/button&gt;\n&lt;/div&gt;\n</code></pre> </li> <li> <p>Client-Side Validation (JavaScript):</p> <pre><code>&lt;script nonce=\"{{ nonce }}\"&gt;\n    function validateForm() {\n        let isValid = true;\n\n        // Email validation\n        const emailInput = document.getElementById('email');\n        const emailError = document.getElementById('emailError');\n        if (!emailInput.value.trim()) {\n            emailError.textContent = 'Please enter your email address.';\n            emailError.classList.remove('hidden');\n            isValid = false;\n        } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(emailInput.value)) {\n            emailError.textContent = 'Please enter a valid email address.';\n            emailError.classList.remove('hidden');\n            isValid = false;\n        } else {\n            emailError.classList.add('hidden');\n        }\n\n        // Country Code validation\n        const countryCodeInput = document.getElementById('countryCode');\n        const countryCodeError = document.getElementById('countryCodeError');\n        if (!countryCodeInput.value) {\n            countryCodeError.textContent = 'Please select your country code.';\n            countryCodeError.classList.remove('hidden');\n            isValid = false;\n        } else {\n            countryCodeError.classList.add('hidden');\n        }\n\n        // Phone Number validation\n        const phoneNumberInput = document.getElementById('phoneNumber');\n        const phoneNumberError = document.getElementById('phoneNumberError');\n        if (!phoneNumberInput.value.trim()) {\n            phoneNumberError.textContent = 'Please enter your phone number.';\n            phoneNumberError.classList.remove('hidden');\n            isValid = false;\n        } else if (!/^\\d{7,15}$/.test(phoneNumberInput.value)) {\n            phoneNumberError.textContent = 'Please enter a valid phone number (7-15 digits).';\n            phoneNumberError.classList.remove('hidden');\n            isValid = false;\n        } else {\n            phoneNumberError.classList.add('hidden');\n        }\n\n        // reCAPTCHA validation is handled by Google, no direct frontend validation here\n\n        return isValid;\n    }\n&lt;/script&gt;\n</code></pre> <ul> <li><code>validateForm()</code>: The main validation function that is called <code>onsubmit</code>.</li> <li> <p>Email Validation:</p> <ul> <li>Checks if the email field is empty.</li> <li>Uses a regular expression to validate email format.</li> <li>Displays an error message if the email is invalid.</li> </ul> </li> <li> <p>Country Code Validation:</p> <ul> <li>Checks if a country code has been selected.</li> <li>Displays an error message if no code is selected.</li> </ul> </li> <li> <p>Phone Number Validation:</p> <ul> <li>Checks if the phone number field is empty.</li> <li>Uses a regular expression to validate that the phone number contains only digits and is within the correct length (7-15 digits).</li> <li>Displays an error message if the phone number is invalid.</li> </ul> </li> <li>All scripts include the <code>nonce=\"{{ nonce }}\"</code> attribute for Content Security Policy (CSP) compliance.</li> </ul> </li> </ol> <p>Key Concepts:</p> <ul> <li>Flask-WTF:  Manages the form and performs server-side validation.</li> <li>Jinja2 Templating: Facilitates dynamic rendering of form elements and error messages.</li> <li>Tailwind CSS: Provides styling for a visually appealing and responsive layout.</li> <li>JavaScript Validation: Enhances the user experience by providing immediate feedback before form submission.</li> <li>reCAPTCHA: Prevents automated spam submissions.</li> <li>Content Security Policy (CSP): The <code>nonce</code> tag helps enforce security by whitelisting specific scripts.</li> </ul>"},{"location":"25_login/","title":"<code>login.html</code>","text":"<p>Purpose: This file defines the HTML template for the user login page. It extends the base template (<code>base.html</code>) and provides a form for users to enter their email and password to authenticate. The template features Tailwind CSS styling, password visibility toggling, and reCAPTCHA integration.</p> <p>Overview:</p> <p>The <code>login.html</code> template provides the user interface for logging into the application and features the following:</p> <ol> <li>Email and Password Input: Standard fields for collecting user credentials.</li> <li>Password Visibility Toggle: A JavaScript-driven feature to allow users to reveal or hide their entered password.</li> <li>reCAPTCHA Integration: Includes Google reCAPTCHA to prevent automated bot logins.</li> <li>Links to Registration and Password Reset: Provides easy access to account creation and password recovery options.</li> <li>Tailwind CSS Styling: Uses Tailwind CSS for responsive design and a visually appealing layout.</li> </ol> <p>Key Components and Functionality:</p> <ol> <li> <p>Template Inheritance: Extends the base template (<code>base.html</code>).</p> <pre><code>{% extends 'base.html' %}\n</code></pre> </li> <li> <p>Title Block: Sets the page title.</p> <pre><code>{% block title %}Login - VulnScanAI{% endblock %}\n</code></pre> </li> <li> <p>Content Block: Encloses the main login content.</p> <pre><code>{% block content %}\n&lt;/div&gt;\n&lt;script nonce=\"{{ nonce }}\" &gt;\n    // ... JavaScript ...\n&lt;/script&gt;\n{% endblock %}\n</code></pre> </li> <li> <p>Login Form Structure: The form is structured with a centering <code>div</code> and a white background for the form area itself, styled with Tailwind CSS.</p> <pre><code>&lt;div class=\"flex justify-center items-center min-h-screen\"&gt;\n    &lt;div class=\"bg-white p-8 rounded-lg shadow-lg w-full max-w-md\"&gt;\n        &lt;h2 class=\"text-2xl font-bold mb-6 text-center\"&gt;Login to Your VulnScanAI Account&lt;/h2&gt;\n        &lt;form method=\"POST\"&gt;\n            {{ form.hidden_tag() }}\n\n            &lt;!-- Email and Password fields --&gt;\n\n            &lt;button class=\"w-full bg-blue-500 text-white py-2 rounded hover:bg-blue-600 transition duration-200\"&gt;Login&lt;/button&gt;\n        &lt;/form&gt;\n        &lt;p class=\"text-sm mt-4 text-center\"&gt;\n            Don't have an account? &lt;a href=\"{{ url_for('auth.register') }}\" class=\"text-blue-500 hover:underline\"&gt;Register&lt;/a&gt; |\n            &lt;a href=\"{{ url_for('auth.forgot_password') }}\" class=\"text-blue-500 hover:underline\"&gt;Forgot your password?&lt;/a&gt;\n        &lt;/p&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> </li> <li> <p>Email and Password Fields:</p> <pre><code>&lt;div class=\"mb-4\"&gt;\n    {{ form.email.label(class=\"block text-gray-700 mb-1\") }}\n    {{ form.email(class=\"w-full p-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-400\") }}\n&lt;/div&gt;\n&lt;div class=\"mb-6 relative\"&gt;\n    {{ form.password.label(class=\"block text-gray-700 mb-1\") }}\n    &lt;div class=\"relative\"&gt;\n        {{ form.password(class=\"w-full p-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-400\", id=\"password\") }}\n        &lt;button type=\"button\" id=\"togglePasswordButton\" class=\"absolute inset-y-0 right-0 px-3 flex items-center focus:outline-none\"&gt;\n            &lt;span id=\"eyeIcon\" class=\"material-symbols-outlined text-gray-500 cursor-pointer\"&gt;visibility&lt;/span&gt;\n            &lt;span id=\"eyeSlashIcon\" class=\"material-symbols-outlined text-gray-500 cursor-pointer hidden\"&gt;visibility_off&lt;/span&gt;\n        &lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li><code>{{ form.email.label(...) }}</code> and <code>{{ form.password.label(...) }}</code> render the labels for the email and password fields with associated styling.</li> <li><code>{{ form.email(...) }}</code> and <code>{{ form.password(...) }}</code> render the respective input fields with Tailwind CSS classes for styling.</li> <li>The password field includes a visibility toggle button.</li> </ul> </li> <li> <p>Password Visibility Toggle: Utilizes JavaScript and Material Symbols to implement a password visibility toggle feature.</p> <pre><code> &lt;div class=\"mb-6 relative\"&gt;\n            {{ form.password.label(class=\"block text-gray-700 mb-1\") }}\n            &lt;div class=\"relative\"&gt;\n                {{ form.password(class=\"w-full p-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-400\", id=\"password\") }}\n                &lt;button type=\"button\" id=\"togglePasswordButton\" class=\"absolute inset-y-0 right-0 px-3 flex items-center focus:outline-none\"&gt;\n                    &lt;span id=\"eyeIcon\" class=\"material-symbols-outlined text-gray-500 cursor-pointer\"&gt;visibility&lt;/span&gt;\n                    &lt;span id=\"eyeSlashIcon\" class=\"material-symbols-outlined text-gray-500 cursor-pointer hidden\"&gt;visibility_off&lt;/span&gt;\n                &lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n</code></pre> <ul> <li>Two Material Symbol icons (eye and eye_slash) are used to represent the password visibility state.</li> <li>The <code>eyeIcon</code> is initially visible, while the <code>eyeSlashIcon</code> is hidden.</li> <li>The <code>togglePasswordButton</code> has a <code>click</code> handler that toggles the password field's type between \"password\" and \"text\", and also updates the visibility of the eye icons.</li> </ul> </li> <li> <p>reCAPTCHA Integration:</p> <pre><code>&lt;div class=\"mb-4\"&gt;\n    &lt;div class=\"g-recaptcha\" data-sitekey=\"{{ config['RECAPTCHA_PUBLIC_KEY'] }}\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li>Renders the reCAPTCHA widget using the site key retrieved from the application configuration (<code>config['RECAPTCHA_PUBLIC_KEY']</code>).</li> </ul> </li> <li> <p>Submit Button:</p> <pre><code>&lt;button class=\"w-full bg-blue-500 text-white py-2 rounded hover:bg-blue-600 transition duration-200\"&gt;Login&lt;/button&gt;\n</code></pre> <ul> <li>Creates the login button with Tailwind CSS styling.</li> </ul> </li> <li> <p>Links to Registration and Password Reset:</p> <pre><code>&lt;p class=\"text-sm mt-4 text-center\"&gt;\n    Don't have an account? &lt;a href=\"{{ url_for('auth.register') }}\" class=\"text-blue-500 hover:underline\"&gt;Register&lt;/a&gt; |\n    &lt;a href=\"{{ url_for('auth.forgot_password') }}\" class=\"text-blue-500 hover:underline\"&gt;Forgot your password?&lt;/a&gt;\n&lt;/p&gt;\n</code></pre> <ul> <li>Provides links to the registration and password reset pages.</li> </ul> </li> <li> <p>JavaScript for Password Toggle:</p> <pre><code>&lt;script nonce=\"{{ nonce }}\" &gt;\n    document.addEventListener('DOMContentLoaded', function() {\n    const togglePasswordButton = document.getElementById('togglePasswordButton');\n    const passwordInput = document.getElementById('password');\n    const eyeIcon = document.getElementById('eyeIcon');\n    const eyeSlashIcon = document.getElementById('eyeSlashIcon');\n\n    if (togglePasswordButton &amp;&amp; passwordInput &amp;&amp; eyeIcon &amp;&amp; eyeSlashIcon) {\n        togglePasswordButton.addEventListener('click', function() {\n            if (passwordInput.type === 'password') {\n                passwordInput.type = 'text';\n                eyeIcon.classList.add('hidden');\n                eyeSlashIcon.classList.remove('hidden');\n            } else {\n                passwordInput.type = 'password';\n                eyeIcon.classList.remove('hidden');\n                eyeSlashIcon.classList.add('hidden');\n            }\n        });\n    } else {\n        console.warn(\"One or more password toggle elements not found.\");\n    }\n});\n&lt;/script&gt;\n</code></pre> <ul> <li>The JavaScript code ensures that the DOM elements are loaded before attaching the event listener.</li> <li>It gets the required elements for the toggle action.</li> <li>An event listener is attached to toggle button to change the input type and change icons to indicate the password visibility status.</li> <li>Adds <code>nonce=\"{{ nonce }}\"</code> to the script tag itself to comply with Content Security Policy (CSP).</li> <li>Includes a warning to the console if any of the elements are missing.</li> </ul> </li> </ol> <p>Key Concepts:</p> <ul> <li>Flask-WTF: Simplifies form handling.</li> <li>Jinja2: Enables dynamic rendering of HTML content.</li> <li>Tailwind CSS: Provides a responsive and visually appealing layout.</li> <li>JavaScript: Implements interactive features, password visibility toggle.</li> <li>reCAPTCHA: Helps prevent bot logins.</li> <li>CSP (Content Security Policy): Enhanced security by whitelisting script sources (using the <code>nonce</code> attribute).</li> </ul>"},{"location":"26_profile/","title":"<code>profile.html</code>","text":"<p>Purpose: This file defines the HTML template for the user profile page, providing a read-only view of the user's account information. It extends the <code>base.html</code> template and utilizes Jinja2 for dynamic content and Tailwind CSS for styling. The primary function of this page is to present the user with their account details and a navigation link to the password update page.</p> <p>Overview:</p> <p>The <code>profile.html</code> template displays key details of the user's account, including:</p> <ol> <li>Personal Information: The user's registered username and email address.</li> <li>Subscription Details: Information about their current subscription plan (if any) and its expiration date.</li> <li>Navigation to Update Password: A direct link to allow the user to change their password.</li> </ol> <p>This template is designed to be a simple, informative, and user-friendly way for users to view their account status.</p> <p>Key Components and Functionality:</p> <ol> <li> <p>Template Inheritance: Extends the base template for consistent styling and structure.</p> <pre><code>{% extends 'base.html' %}\n</code></pre> </li> <li> <p>Title Block: Sets the page title in the browser tab.</p> <pre><code>{% block title %}Your Profile - VulnScanAI{% endblock %}\n</code></pre> </li> <li> <p>Content Block: The main content of this template is injected inside the <code>{% block content %}</code> tags.</p> <pre><code>{% block content %}\n&lt;!-- profile details here --&gt;\n{% endblock %}\n</code></pre> </li> <li> <p>Profile Information Container: Uses Tailwind CSS for visual appearance and layout.</p> <pre><code>&lt;div class=\"bg-white shadow overflow-hidden rounded-lg\"&gt;\n    &lt;div class=\"px-4 py-5 sm:px-6\"&gt;\n        &lt;h3 class=\"text-lg leading-6 font-medium text-gray-900\"&gt;\n            Your Profile Information\n        &lt;/h3&gt;\n        &lt;p class=\"mt-1 max-w-2xl text-sm text-gray-500\"&gt;\n            View your account details.\n        &lt;/p&gt;\n    &lt;/div&gt;\n\n   &lt;!--Details --&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li>Tailwind CSS classes like <code>bg-white</code>, <code>shadow</code>, <code>overflow-hidden</code>, and <code>rounded-lg</code> are used for styling the container.</li> </ul> </li> <li> <p>Data Display (Username, Email, Subscription, and Expiry): Implemented with a definition list with conditional rendering.</p> <pre><code>    &lt;div class=\"border-t border-gray-200\"&gt;\n    &lt;dl&gt;\n        &lt;div class=\"bg-gray-50 px-4 py-3 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6\"&gt;\n            &lt;dt class=\"text-sm font-medium text-gray-500\"&gt;\n                Username\n            &lt;/dt&gt;\n            &lt;dd class=\"mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2\"&gt;\n                {{ current_user.username }}\n            &lt;/dd&gt;\n        &lt;/div&gt;\n        &lt;div class=\"bg-white px-4 py-3 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6\"&gt;\n            &lt;dt class=\"text-sm font-medium text-gray-500\"&gt;\n                Email address\n            &lt;/dt&gt;\n            &lt;dd class=\"mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2\"&gt;\n                {{ current_user.email }}\n            &lt;/dd&gt;\n        &lt;/div&gt;\n        &lt;div class=\"bg-gray-50 px-4 py-3 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6\"&gt;\n            &lt;dt class=\"text-sm font-medium text-gray-500\"&gt;\n                Plan Type\n            &lt;/dt&gt;\n            &lt;dd class=\"mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2\"&gt;\n                {% if current_user.subscription_id %}\n                    {% set subscription = subscriptions.get(current_user.subscription_id) %}\n                    {% if subscription %}\n                        {{ subscription.plan_name }}\n                    {% else %}\n                        N/A\n                    {% endif %}\n                {% else %}\n                    Free\n                {% endif %}\n            &lt;/dd&gt;\n        &lt;/div&gt;\n        &lt;div class=\"bg-white px-4 py-3 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6\"&gt;\n            &lt;dt class=\"text-sm font-medium text-gray-500\"&gt;\n                Plan Expiry\n            &lt;/dt&gt;\n            &lt;dd class=\"mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2\"&gt;\n                {% if current_user.subscription_expiry %}\n                    {{ current_user.subscription_expiry.strftime('%Y-%m-%d %H:%M:%S UTC') }}\n                {% else %}\n                    N/A\n                {% endif %}\n            &lt;/dd&gt;\n        &lt;/div&gt;\n    &lt;/dl&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li>A definition list (<code>&lt;dl&gt;</code>, <code>&lt;dt&gt;</code>, <code>&lt;dd&gt;</code>) is used to structure user and subscription details.</li> <li>Tailwind CSS classes are used to style each section and its layout.</li> <li><code>sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6</code> creates a grid layout on small screens or larger</li> <li><code>{{ current_user.username }}</code>, <code>{{ current_user.email }}</code>, etc., use Jinja2 to inject data.</li> <li>Conditional logic handles various scenarios:<ul> <li><code>{% if current_user.subscription_id %}</code>: To check if the user has a subscription at all.</li> <li><code>{% set subscription = subscriptions.get(current_user.subscription_id) %}</code> and <code>{% if subscription %}</code>: used to retrieve and display the Subscription plan name, otherwise displays N/A</li> <li>The <code>strftime()</code> function ensures consistent date formatting.</li> </ul> </li> </ul> </li> <li> <p>\"Update Password\" Link: Facilitates access to the password change form.</p> <pre><code>&lt;div class=\"px-4 py-4 bg-gray-50 text-right sm:px-6\"&gt;\n    &lt;a href=\"{{ url_for('auth.update_password') }}\" class=\"inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-blue-700 bg-blue-100 hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500\"&gt;\n        Update Password\n    &lt;/a&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li>This code renders a button-like link, enabling users to easily navigate to the password update form.</li> <li>It uses Tailwind CSS classes for visual styling.</li> </ul> </li> </ol> <p>Key Concepts:</p> <ul> <li>Template Inheritance: Using inheritance from <code>base.html</code> maintains consistency in design and simplifies the code.</li> <li>Read-Only View: Presents user information in a way that is easily readable but not editable.</li> <li>Utility Classes (Tailwind CSS): Tailwind CSS provides a concise and maintainable way to style the different parts of the profile.</li> <li>Clear Navigation: Offers a straightforward way for users to perform a core action, changing their password.</li> </ul>"},{"location":"config/","title":"File: <code>config.py</code>","text":"<p>Purpose: This file defines the <code>Config</code> class, which is responsible for managing the application's configuration settings. It loads configuration values from environment variables, providing a centralized and flexible way to configure the application's behavior in different environments (development, production, etc.).</p> <p>Overview:</p> <p>The <code>config.py</code> file performs the following key functions:</p> <ul> <li>Environment Variable Loading: Uses the <code>dotenv</code> library to load environment variables from a <code>.env</code> file (if it exists).  This is useful for storing sensitive information (API keys, database passwords) and configuration options outside of the codebase.</li> <li>Configuration Class Definition: Defines the <code>Config</code> class, which holds various configuration attributes as class variables.</li> <li>Data Type Conversion: Converts environment variables to appropriate data types (e.g., integers, booleans) where necessary.</li> <li>Default Value Handling: Provides default values for certain configuration variables if they are not explicitly set in the environment.</li> </ul> <p>Key Components and Functionality:</p> <ul> <li> <p><code>dotenv</code> Loading: The <code>load_dotenv()</code> function from the <code>dotenv</code> library is called to load environment variables from a <code>.env</code> file into the <code>os.environ</code> dictionary.</p> <pre><code>from dotenv import load_dotenv\n\nload_dotenv()\n</code></pre> </li> <li> <p><code>Config</code> Class: This class encapsulates the application's configuration settings. The attributes within the class represent different configuration options.</p> <pre><code>import os\nfrom dotenv import load_dotenv\nfrom datetime import timedelta\n\nload_dotenv()\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n\n    MAIL_SERVER = os.environ.get('MAIL_SERVER')\n    MAIL_PORT_str = os.environ.get('MAIL_PORT')\n    MAIL_PORT = int(MAIL_PORT_str) if MAIL_PORT_str else None\n    MAIL_USE_SSL_str = os.environ.get('MAIL_USE_SSL')\n    MAIL_USE_SSL = MAIL_USE_SSL_str.lower() == 'true' if MAIL_USE_SSL_str else False\n    MAIL_USE_TLS_str = os.environ.get('MAIL_USE_TLS')\n    MAIL_USE_TLS = MAIL_USE_TLS_str.lower() == 'true' if MAIL_USE_TLS_str else False\n    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')\n    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')\n    MAIL_DEFAULT_SENDER = (os.environ.get('MAIL_SENDER'), os.environ.get('MAIL_USERNAME'))\n\n    RECAPTCHA_PUBLIC_KEY = os.environ.get('RECAPTCHA_PUBLIC_KEY')\n    RECAPTCHA_PRIVATE_KEY = os.environ.get('RECAPTCHA_PRIVATE_KEY')\n\n    GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')\n\n    MOBSF_API_KEY = os.environ.get('MOBSF_API_KEY')\n    MOBSF_API_URL = os.environ.get('MOBSF_API_URL')\n\n    PERMANENT_SESSION_LIFETIME = timedelta(minutes=35)\n\n    PAYPAL_SANDBOX_CLIENT_ID = os.environ.get('PAYPAL_SANDBOX_CLIENT_ID')\n    PAYPAL_SANDBOX_CLIENT_SECRET = os.environ.get('PAYPAL_SANDBOX_CLIENT_SECRET')\n    PAYPAL_API_BASE = os.environ.get('PAYPAL_API_BASE')\n</code></pre> </li> <li> <p>Configuration Attributes:</p> <ul> <li> <p><code>SECRET_KEY</code>:  The secret key used for signing session cookies. This is crucial for security. It should be a long, randomly generated string.</p> <pre><code>SECRET_KEY = os.environ.get('SECRET_KEY')\n</code></pre> </li> <li> <p><code>SQLALCHEMY_DATABASE_URI</code>: The connection string for the SQLAlchemy database.  It specifies the database type, hostname, username, password, and database name.</p> <pre><code>SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')\n</code></pre> </li> <li> <p><code>SQLALCHEMY_TRACK_MODIFICATIONS</code>:  A boolean value that determines whether SQLAlchemy should track modifications to objects. Setting it to <code>False</code> can improve performance.</p> <pre><code>SQLALCHEMY_TRACK_MODIFICATIONS = False\n</code></pre> </li> <li> <p><code>MAIL_SERVER</code>, <code>MAIL_PORT</code>, <code>MAIL_USE_SSL</code>, <code>MAIL_USE_TLS</code>, <code>MAIL_USERNAME</code>, <code>MAIL_PASSWORD</code>, <code>MAIL_DEFAULT_SENDER</code>: Configuration settings for sending emails. These are used by Flask-Mail.</p> <pre><code>MAIL_SERVER = os.environ.get('MAIL_SERVER')\nMAIL_PORT_str = os.environ.get('MAIL_PORT')\nMAIL_PORT = int(MAIL_PORT_str) if MAIL_PORT_str else None\nMAIL_USE_SSL_str = os.environ.get('MAIL_USE_SSL')\nMAIL_USE_SSL = MAIL_USE_SSL_str.lower() == 'true' if MAIL_USE_SSL_str else False\nMAIL_USE_TLS_str = os.environ.get('MAIL_USE_TLS')\nMAIL_USE_TLS = MAIL_USE_TLS_str.lower() == 'true' if MAIL_USE_TLS_str else False\nMAIL_USERNAME = os.environ.get('MAIL_USERNAME')\nMAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')\nMAIL_DEFAULT_SENDER = (os.environ.get('MAIL_SENDER'), os.environ.get('MAIL_USERNAME'))\n</code></pre> <ul> <li>Type Conversions for Mail Settings: The code converts string values from environment variables into their corresponding types. For example <code>MAIL_PORT</code> is parsed to integer, <code>MAIL_USE_SSL</code> and <code>MAIL_USE_TLS</code> are parsed to booleans. It also uses the ternary operator to provide a default value of None/False in case the environment variable is not set.</li> </ul> </li> <li> <p><code>RECAPTCHA_PUBLIC_KEY</code>, <code>RECAPTCHA_PRIVATE_KEY</code>: Configuration settings for Google reCAPTCHA, which helps protect against spam and abuse.</p> <pre><code>RECAPTCHA_PUBLIC_KEY = os.environ.get('RECAPTCHA_PUBLIC_KEY')\nRECAPTCHA_PRIVATE_KEY = os.environ.get('RECAPTCHA_PRIVATE_KEY')\n</code></pre> </li> <li> <p><code>GEMINI_API_KEY</code>: The API key for accessing the Google Gemini AI model.</p> <pre><code>GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')\n</code></pre> </li> <li> <p><code>MOBSF_API_KEY</code>, <code>MOBSF_API_URL</code>: Configuration settings for integrating with the Mobile Security Framework (MobSF) API.</p> <pre><code>MOBSF_API_KEY = os.environ.get('MOBSF_API_KEY')\nMOBSF_API_URL = os.environ.get('MOBSF_API_URL')\n</code></pre> </li> <li> <p><code>PERMANENT_SESSION_LIFETIME</code>: Defines the duration for which user sessions should persist. The value is set to 35 minutes.</p> <pre><code>PERMANENT_SESSION_LIFETIME = timedelta(minutes=35)\n</code></pre> </li> <li> <p><code>PAYPAL_SANDBOX_CLIENT_ID</code>, <code>PAYPAL_SANDBOX_CLIENT_SECRET</code>, <code>PAYPAL_API_BASE</code>: Configuration settings for integrating with the PayPal API (in sandbox mode for testing).</p> <pre><code>PAYPAL_SANDBOX_CLIENT_ID = os.environ.get('PAYPAL_SANDBOX_CLIENT_ID')\nPAYPAL_SANDBOX_CLIENT_SECRET = os.environ.get('PAYPAL_SANDBOX_CLIENT_SECRET')\nPAYPAL_API_BASE = os.environ.get('PAYPAL_API_BASE')\n</code></pre> </li> </ul> </li> </ul> <p>Key Concepts:</p> <ul> <li>Environment Variables:  Environment variables are dynamic-named values that can affect the way running processes will behave on a computer. They are a standard way to configure applications, especially in production environments, as they allow you to change settings without modifying the application's code.</li> <li>.env Files:  A <code>.env</code> file is a text file used to store environment variables.  The <code>python-dotenv</code> library makes it easy to load these variables into your application.  <code>.env</code> files are typically used for development and testing environments.</li> <li>Flask Configuration:  Flask applications use a configuration object (<code>app.config</code>) to store configuration settings. The <code>Config</code> class defined in <code>config.py</code> is a common way to organize these settings.</li> </ul> <p>Security Considerations:</p> <ul> <li>Never commit <code>.env</code> files to version control.  These files often contain sensitive information, such as API keys and database passwords. Add <code>.env</code> to your <code>.gitignore</code> file.</li> <li>In production environments, it is best to set environment variables directly on the server rather than relying on <code>.env</code> files.  This can be done through the operating system, container orchestration tools (like Kubernetes), or cloud platform configuration settings.</li> <li>The <code>SECRET_KEY</code> is critical for security.  Use a strong, randomly generated secret key.</li> </ul>"},{"location":"extensions/","title":"<code>extensions.py</code>","text":"<p>Purpose: This file defines and exposes instances of Flask extensions, particularly <code>SQLAlchemy</code> for database management and <code>Mail</code> for email functionality. It adheres to the \"extension registry\" pattern, promoting clean code, preventing circular imports, and enhancing testability.</p> <p>Overview:</p> <p>The <code>extensions.py</code> file focuses on creating instances of Flask extensions without immediately associating them with a specific Flask application instance. The association, or initialization, happens later in the application setup process, often within a factory function such as <code>create_app</code>.</p> <p>This design offers several benefits:</p> <ul> <li>Preventing Circular Imports: By creating the extension instances outside the application factory, it avoids circular import dependencies, a common issue when different parts of the application depend on each other and the extensions.</li> <li>Improved Code Structure: Separating extension creation and initialization promotes a cleaner and more organized codebase.</li> <li>Enhanced Testability: It simplifies testing by allowing extensions to be easily mocked or replaced in test environments.</li> </ul> <p>The file's functionality can be summarized as:</p> <ul> <li>Importing Extension Classes: Importing the necessary classes from the Flask extensions (<code>Mail</code> and <code>SQLAlchemy</code>).</li> <li>Creating Extension Instances: Creating global instances of the imported extension classes (<code>db</code> and <code>mail</code>). These instances are not yet linked to a Flask application.</li> <li>Providing Global Access: Making the extension instances available for import and usage throughout the application.</li> </ul> <p>Key Components and Functionality:</p> <ul> <li> <p>Extension Imports: The file imports the required extension classes:</p> <pre><code>from flask_mail import Mail\nfrom flask_sqlalchemy import SQLAlchemy\n</code></pre> </li> <li> <p><code>SQLAlchemy</code> Instance (<code>db</code>):  A global instance of the <code>SQLAlchemy</code> class is created and assigned to the variable <code>db</code>. This <code>db</code> object will be used for all database interactions within the application.  Crucially, it is not initialized with a Flask application at this point.</p> <pre><code>db = SQLAlchemy()\n</code></pre> </li> <li> <p><code>Mail</code> Instance (<code>mail</code>): A global instance of the <code>Mail</code> class is created and assigned to the variable <code>mail</code>. This <code>mail</code> object will be used for sending emails from the application.  Like <code>db</code>, it is not yet initialized with a Flask application.</p> <pre><code>mail = Mail()\n</code></pre> </li> </ul> <p>Initialization within the Application Factory (Example):</p> <p>The following code snippet demonstrates how the extensions are typically initialized within a Flask application factory function:</p> <pre><code>from flask import Flask\nfrom app.extensions import db, mail  # Import the extension instances\nfrom app.config import Config # Import the configuration class\n\ndef create_app(config_class=Config):\n    app = Flask(__name__)\n    app.config.from_object(config_class) # Load the app configuration\n\n    # Initialize Flask extensions\n    db.init_app(app)\n    mail.init_app(app)\n\n    # ... Register blueprints, add other configurations ...\n\n    return app\n</code></pre>"},{"location":"forms/","title":"<code>forms.py</code>","text":"<p>Purpose: This file defines various Flask-WTF forms used throughout the application. These forms handle user input, validation, and rendering in HTML templates. It uses WTForms for field definitions and validators to ensure data integrity.</p> <p>Overview:</p> <p>The <code>forms.py</code> file defines form classes that are used to:</p> <ul> <li>Capture User Input: Create HTML forms to collect data from users.</li> <li>Validate User Input: Apply validation rules to ensure the collected data is in the correct format and meets the required criteria.</li> <li>Render HTML Forms: Generate HTML markup for the forms to be displayed in web pages.</li> </ul> <p>The file includes custom validators for common tasks like password strength validation.</p> <p>Key Components and Functionality:</p> <ul> <li> <p>Imports: Imports necessary classes and functions from Flask-WTF and WTForms.</p> <pre><code>from flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, SubmitField, TextAreaField, SelectField, BooleanField\nfrom wtforms.validators import DataRequired, Email, EqualTo, Length, Regexp, ValidationError\n</code></pre> </li> <li> <p><code>password_strength</code> Validator Function: A custom validator function to enforce password complexity rules.</p> <pre><code>from wtforms import ValidationError\n\ndef password_strength(form, field):\n    \"\"\"Custom validator to check password strength.\"\"\"\n    if len(field.data) &lt; 8:\n        raise ValidationError('Password must be at least 8 characters long.')\n    if not any(char.isdigit() for char in field.data):\n        raise ValidationError('Password must contain at least one number.')\n    if not any(char.isalpha() for char in field.data):\n        raise ValidationError('Password must contain at least one letter.')\n    if not any(char in \"!@#$%^&amp;*()_+=-`~[]\\\\{}|;':\\\",./&lt;&gt;?\" for char in field.data):\n        raise ValidationError('Password must contain at least one special character.')\n</code></pre> <ul> <li>Validation Rules:<ul> <li>Minimum length of 8 characters.</li> <li>Must contain at least one digit.</li> <li>Must contain at least one letter.</li> <li>Must contain at least one special character.</li> </ul> </li> </ul> </li> <li> <p><code>RegistrationForm</code>: Handles user registration.</p> <pre><code>from flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, SubmitField, BooleanField\nfrom wtforms.validators import DataRequired, Email, EqualTo\n\nclass RegistrationForm(FlaskForm):\n    username = StringField('Username', validators=[DataRequired()])\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    password = PasswordField('Password', validators=[DataRequired(), password_strength])\n    confirm_password = PasswordField('Confirm Password', validators=[DataRequired(), EqualTo('password', message='Passwords must match.' )])\n    accept_terms = BooleanField('I accept the terms and conditions', validators=[DataRequired()])\n    submit = SubmitField('Register')\n</code></pre> <ul> <li>Fields:<ul> <li><code>username</code>: String field for the username. Requires data.</li> <li><code>email</code>: String field for the email address. Requires data and a valid email format.</li> <li><code>password</code>: Password field for the password. Requires data and adheres to the <code>password_strength</code> validator.</li> <li><code>confirm_password</code>: Password field for confirming the password. Requires data and must match the <code>password</code> field.</li> <li><code>accept_terms</code>: Boolean field for accepting terms and conditions. Requires data (must be checked).</li> <li><code>submit</code>: Submit button.</li> </ul> </li> </ul> </li> <li> <p><code>LoginForm</code>: Handles user login.</p> <pre><code>from flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, SubmitField\nfrom wtforms.validators import DataRequired, Email\n\nclass LoginForm(FlaskForm):\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    password = PasswordField('Password', validators=[DataRequired()])\n    submit = SubmitField('Login')\n</code></pre> <ul> <li>Fields:<ul> <li><code>email</code>: String field for the email address. Requires data and a valid email format.</li> <li><code>password</code>: Password field for the password. Requires data.</li> <li><code>submit</code>: Submit button.</li> </ul> </li> </ul> </li> <li> <p><code>ForgotPasswordForm</code>: Handles requesting a password reset.</p> <pre><code>from flask_wtf import FlaskForm\nfrom wtforms import StringField, SubmitField\nfrom wtforms.validators import DataRequired, Email\n\nclass ForgotPasswordForm(FlaskForm):\n    email = StringField('Email Address', validators=[DataRequired(), Email()])\n    submit = SubmitField('Request Password Reset')\n</code></pre> <ul> <li>Fields:<ul> <li><code>email</code>: String field for the email address. Requires data and a valid email format.</li> <li><code>submit</code>: Submit button.</li> </ul> </li> </ul> </li> <li> <p><code>ChangePasswordForm</code>: Handles changing a user's password while logged in.</p> <pre><code>from flask_wtf import FlaskForm\nfrom wtforms import PasswordField, SubmitField\nfrom wtforms.validators import DataRequired, Length, EqualTo\n\nclass ChangePasswordForm(FlaskForm):\n    current_password = PasswordField('Current Password', validators=[DataRequired(), Length(min=8)])\n    new_password = PasswordField('New Password', validators=[DataRequired(), Length(min=8), password_strength])\n    confirm_new_password = PasswordField('Confirm New Password', validators=[DataRequired(), EqualTo('new_password', message='New passwords must match.')])\n    submit = SubmitField('Update Password')\n</code></pre> <ul> <li>Fields:<ul> <li><code>current_password</code>: Password field for the user's current password.  Requires data and a minimum length of 8.</li> <li><code>new_password</code>: Password field for the new password. Requires data, minimum length of 8, and adheres to the <code>password_strength</code> validator.</li> <li><code>confirm_new_password</code>: Password field for confirming the new password. Requires data and must match the <code>new_password</code> field.</li> <li><code>submit</code>: Submit button.</li> </ul> </li> </ul> </li> <li> <p><code>ResetPasswordForm</code>: Handles resetting a user's password using a token.</p> <pre><code>from flask_wtf import FlaskForm\nfrom wtforms import PasswordField, SubmitField\nfrom wtforms.validators import DataRequired, EqualTo, Length\n\nclass ResetPasswordForm(FlaskForm):\n    password = PasswordField('New Password', validators=[DataRequired(), Length(min=8), password_strength])\n    confirm_password = PasswordField('Confirm New Password', validators=[DataRequired(), EqualTo('password')])\n    submit = SubmitField('Reset Password')\n</code></pre> <ul> <li>Fields:<ul> <li><code>password</code>: Password field for the new password. Requires data, minimum length of 8, and must adhere to the <code>password_strength</code> validator</li> <li><code>confirm_password</code>: Password field for confirming the new password. Requires data and must match the <code>password</code> field.</li> <li><code>submit</code>: Submit button.</li> </ul> </li> </ul> </li> <li> <p><code>ContactForm</code>: Handles contact form submissions.</p> <pre><code>from flask_wtf import FlaskForm\nfrom wtforms import StringField, TextAreaField, SubmitField\nfrom wtforms.validators import DataRequired, Length, Email\n\nclass ContactForm(FlaskForm):\n    name = StringField('Your Name', validators=[DataRequired(), Length(min=2, max=100)])\n    email = StringField('Your Email', validators=[DataRequired(), Email(), Length(max=120)])\n    subject = StringField('Subject', validators=[DataRequired(), Length(min=2, max=200)])\n    message = TextAreaField('Message', validators=[DataRequired(), Length(min=5, max=500)])\n\n    submit = SubmitField('Send Message')\n</code></pre> <ul> <li>Fields:<ul> <li><code>name</code>: String field for the user's name. Requires data and a length between 2 and 100 characters.</li> <li><code>email</code>: String field for the user's email address. Requires data, a valid email format, and a maximum length of 120 characters.</li> <li><code>subject</code>: String field for the subject of the message. Requires data and a length between 2 and 200 characters.</li> <li><code>message</code>: TextArea field for the message content. Requires data and a length between 5 and 500 characters.</li> <li><code>submit</code>: Submit button.</li> </ul> </li> </ul> </li> <li> <p><code>RequestDemoForm</code>: Handles requests for a demo.</p> <pre><code>from flask_wtf import FlaskForm\nfrom wtforms import StringField, SelectField, SubmitField\nfrom wtforms.validators import DataRequired, Email, Length\n\nclass RequestDemoForm(FlaskForm):\n    email = StringField('Your Email', validators=[DataRequired(), Email(), Length(max=120)])\n    country_code = SelectField('Country Code', validators=[DataRequired()], choices=[\n        ('', 'Select Code'),\n        ('+1', '+1 (USA/Canada)'),\n        ('+44', '+44 (UK)'),\n        ('+91', '+91 (India)'),\n        ('+86', '+86 (China)'),\n        ('+61', '+61 (Australia)'),\n        ('+55', '+55 (Brazil)'),\n        ('+81', '+81 (Japan)'),\n        ('+33', '+33 (France)'),\n        ('+49', '+49 (Germany)'),\n        ('+52', '+52 (Mexico)'),\n\n    ])\n    phone_number = StringField('Phone Number', validators=[DataRequired(), Length(min=7, max=15, message='Phone number must be between 7 and 15 digits')])\n\n    submit = SubmitField('Request Demo')\n</code></pre> <ul> <li>Fields:<ul> <li><code>email</code>: String field for the user's email address. Requires data, a valid email format, and a maximum length of 120 characters.</li> <li><code>country_code</code>: Select field for selecting the country code. Requires data and provides a predefined list of choices.</li> <li><code>phone_number</code>: String field for the phone number. Requires data and a length between 7 and 15 characters.</li> <li><code>submit</code>: Submit button.</li> </ul> </li> </ul> </li> </ul> <p>Key Concepts:</p> <ul> <li>Flask-WTF: A Flask extension that simplifies working with web forms.  It provides integration with WTForms.</li> <li>WTForms: A Python library for creating and validating web forms.</li> <li>Fields: Represent individual form elements (e.g., text fields, password fields, select fields).</li> <li>Validators: Rules that are applied to form fields to ensure data integrity.  WTForms provides a variety of built-in validators, and you can also create custom validators.</li> <li><code>FlaskForm</code>: A base class provided by Flask-WTF that simplifies the process of creating Flask forms.</li> </ul> <p>Rendering Forms in Templates:</p> <p>In your Flask templates, you can render the forms using the following pattern:</p> <pre><code>&lt;form method=\"POST\"&gt;\n    {{ form.hidden_tag() }}  {# Include CSRF token #}\n    &lt;div class=\"form-group\"&gt;\n        {{ form.email.label }}\n        {{ form.email(class=\"form-control\") }}\n        {% if form.email.errors %}\n            &lt;ul class=\"errors\"&gt;\n                {% for error in form.email.errors %}\n                    &lt;li&gt;{{ error }}&lt;/li&gt;\n                {% endfor %}\n            &lt;/ul&gt;\n        {% endif %}\n    &lt;/div&gt;\n    &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"models/","title":"<code>models.py</code>","text":"<p>Purpose: This file defines the data models for the application using SQLAlchemy, providing a structured representation of the database tables and their relationships. These models are essential for interacting with the database using Python objects.</p> <p>Overview:</p> <p>The <code>models.py</code> file establishes the structure and relationships within the application's database through the creation of SQLAlchemy models. These models are:</p> <ul> <li><code>User</code>:  Represents a user account within the system, storing information like username, email, password, subscription details, and login activity. It integrates with Flask-Login's <code>UserMixin</code> for authentication functionalities.</li> <li><code>Subscription</code>: Defines subscription plans offered to users, detailing plan name, price, validity duration, and the relationship with subscribed users.</li> <li><code>Payment</code>: Records payment transactions made by users, linking each payment to a specific user, subscription plan, and payment details like amount, date, and status.</li> <li><code>LoginDetail</code>: Logs user login attempts, capturing the user's IP address and the timestamp of the login event.</li> <li><code>Access</code>: Tracks user access information, including device details and the time of access.</li> </ul> <p>These models facilitate database interactions by mapping database tables to Python classes, enabling object-oriented data manipulation.</p> <p>Key Components and Functionality:</p> <ul> <li> <p>Imports: The file imports necessary modules from Flask-SQLAlchemy (<code>db</code>), <code>datetime</code>, and Flask-Login (<code>UserMixin</code>).</p> <pre><code>from app.extensions import db\nfrom datetime import datetime\nfrom flask_login import UserMixin\n</code></pre> </li> <li> <p><code>User</code> Model: Represents a user account.</p> <pre><code>from app.extensions import db\nfrom datetime import datetime\nfrom flask_login import UserMixin\n\n# User Table\nclass User(db.Model, UserMixin):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password = db.Column(db.String(256), nullable=False)\n    is_verified = db.Column(db.Boolean, default=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    subscription_expiry = db.Column(db.DateTime)\n\n    # Foreign Key to Subscription\n    subscription_id = db.Column(db.Integer, db.ForeignKey('subscription.id'))\n    # Relationship to Subscription\n    subscription = db.relationship('Subscription', back_populates='users')\n    # Relationships for login and access\n    logins = db.relationship('LoginDetail', backref='user', lazy=True)\n    access = db.relationship('Access', backref='user', lazy=True)\n    # Relationship to Payment\n    payments = db.relationship('Payment', backref='user', lazy=True)\n\n    def is_subscription_active(self):\n        if self.subscription_expiry:\n            return datetime.utcnow() &lt;= self.subscription_expiry\n        return False\n</code></pre> <ul> <li> <p>Attributes:</p> <ul> <li><code>id</code>: Integer, primary key, auto-incrementing.</li> <li><code>username</code>: String (max 64 characters), unique, not nullable.</li> <li><code>email</code>: String (max 120 characters), unique, not nullable.</li> <li><code>password</code>: String (max 256 characters), not nullable.</li> <li><code>is_verified</code>: Boolean, defaults to <code>False</code>, indicating account verification status.</li> <li><code>created_at</code>: DateTime, defaults to the current UTC time upon creation.</li> <li><code>subscription_expiry</code>: DateTime, nullable, storing the date and time the user's subscription expires.</li> <li><code>subscription_id</code>: Integer, foreign key referencing the <code>Subscription</code> table, establishing the relationship between users and their subscription plans.</li> </ul> </li> <li> <p>Relationships:</p> <ul> <li><code>subscription</code>: A <code>db.relationship</code> that establishes a one-to-many relationship with the <code>Subscription</code> model, defining the user's active subscription. <code>back_populates='users'</code> creates a reverse relationship on the <code>Subscription</code> model.</li> <li><code>logins</code>: A <code>db.relationship</code> to the <code>LoginDetail</code> model, facilitating tracking of user login attempts. <code>backref='user'</code> creates a back reference, allowing access to the user from a <code>LoginDetail</code> object. <code>lazy=True</code> ensures that login details are loaded only when accessed.</li> <li><code>access</code>: A <code>db.relationship</code> to the <code>Access</code> model, tracking user access information. <code>backref='user'</code> creates a back reference, and <code>lazy=True</code> sets the loading behavior.</li> <li><code>payments</code>: A <code>db.relationship</code> to the <code>Payment</code> model, tracking payment transactions made by the user. <code>backref='user'</code> creates a back reference, and <code>lazy=True</code> sets the loading behavior.</li> </ul> </li> <li> <p><code>is_subscription_active()</code> Method:</p> <ul> <li>Determines whether a user's subscription is currently active.</li> <li>Compares the current UTC time with the user's <code>subscription_expiry</code>.</li> <li>Returns <code>True</code> if the subscription is active (current time is before the expiry), and <code>False</code> otherwise.</li> </ul> </li> </ul> </li> <li> <p><code>Subscription</code> Model: Represents a subscription plan.</p> <pre><code>from app.extensions import db\n\n# Subscription Table\nclass Subscription(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    plan_name = db.Column(db.String(64), unique=True, nullable=False)\n    price = db.Column(db.Float, nullable=False)\n    validity_months = db.Column(db.Integer, nullable=False, default=1)\n    users = db.relationship('User', back_populates='subscription')\n</code></pre> <ul> <li> <p>Attributes:</p> <ul> <li><code>id</code>: Integer, primary key.</li> <li><code>plan_name</code>: String (max 64 characters), unique, not nullable.</li> <li><code>price</code>: Float, not nullable, representing the subscription price.</li> <li><code>validity_months</code>: Integer, not nullable, defaults to 1, specifying the subscription validity in months.</li> </ul> </li> <li> <p>Relationships:</p> <ul> <li><code>users</code>: A <code>db.relationship</code> to the <code>User</code> model, defining the one-to-many relationship between a subscription plan and its subscribed users. <code>back_populates='subscription'</code> creates the reverse relationship in the <code>User</code> model.</li> </ul> </li> </ul> </li> <li> <p><code>Payment</code> Model: Represents a payment transaction.</p> <pre><code>from app.extensions import db\nfrom datetime import datetime\n\n# Payment Table\nclass Payment(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    payment_id = db.Column(db.String(255), unique=True, nullable=False)  # PayPal transaction ID or similar\n    payment_date = db.Column(db.DateTime, default=datetime.utcnow)\n    amount = db.Column(db.Float, nullable=False)\n    currency = db.Column(db.String(10), nullable=False, default='USD')\n    payment_status = db.Column(db.String(50), nullable=False)  # e.g., 'Completed', 'Pending', 'Failed'\n    subscription_id = db.Column(db.Integer, db.ForeignKey('subscription.id'), nullable=False)\n    subscription = db.relationship('Subscription', backref='payments')\n</code></pre> <ul> <li> <p>Attributes:</p> <ul> <li><code>id</code>: Integer, primary key.</li> <li><code>user_id</code>: Integer, foreign key referencing the <code>User</code> table, not nullable.</li> <li><code>payment_id</code>: String (max 255 characters), unique, not nullable, used to store the payment transaction ID (e.g., PayPal transaction ID).</li> <li><code>payment_date</code>: DateTime, defaults to the current UTC time, recording when the payment was made.</li> <li><code>amount</code>: Float, not nullable, representing the payment amount.</li> <li><code>currency</code>: String (max 10 characters), not nullable, defaults to 'USD', specifying the currency of the payment.</li> <li><code>payment_status</code>: String (max 50 characters), not nullable, indicating the status of the payment (e.g., 'Completed', 'Pending', 'Failed').</li> <li><code>subscription_id</code>: Integer, foreign key referencing the <code>Subscription</code> table, not nullable.</li> </ul> </li> <li> <p>Relationships:</p> <ul> <li><code>subscription</code>: A <code>db.relationship</code> to the <code>Subscription</code> model. <code>backref='payments'</code> creates a back reference to access payments from a subscription.</li> </ul> </li> </ul> </li> <li> <p><code>LoginDetail</code> Model: Records user login information.</p> <pre><code>from app.extensions import db\nfrom datetime import datetime\n\n# Login Details Table\nclass LoginDetail(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    ip_address = db.Column(db.String(45))\n    login_time = db.Column(db.DateTime, default=datetime.utcnow)\n</code></pre> <ul> <li>Attributes:<ul> <li><code>id</code>: Integer, primary key.</li> <li><code>user_id</code>: Integer, foreign key referencing the <code>User</code> table, not nullable.</li> <li><code>ip_address</code>: String (max 45 characters), storing the IP address of the login attempt.</li> <li><code>login_time</code>: DateTime, defaults to the current UTC time, recording the time of the login attempt.</li> </ul> </li> </ul> </li> <li> <p><code>Access</code> Model: Tracks user access details.</p> <pre><code>from app.extensions import db\nfrom datetime import datetime\n\n# Access Table\nclass Access(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    device_info = db.Column(db.String(255))\n    login_time = db.Column(db.DateTime, default=datetime.utcnow)\n</code></pre> <ul> <li>Attributes:<ul> <li><code>id</code>: Integer, primary key.</li> <li><code>user_id</code>: Integer, foreign key referencing the <code>User</code> table, not nullable.</li> <li><code>device_info</code>: String (max 255 characters), storing information about the device used for access.</li> <li><code>login_time</code>: DateTime, defaults to the current UTC time, recording the time of the access event.</li> </ul> </li> </ul> </li> </ul> <p>Relationships Summary:</p> <ul> <li>User \u2194 Subscription: One-to-many (One User has One Subscription, a Subscription can have Many Users).</li> <li>Subscription \u2194 Payment: One-to-many (One Subscription can have Many Payments).</li> <li>User \u2194 Payment: One-to-many (One User can have Many Payments).</li> <li>User \u2194 LoginDetail: One-to-many (One User can have Many Login Details).</li> <li>User \u2194 Access: One-to-many (One User can have Many Access records).</li> </ul> <p>Key Concepts:</p> <ul> <li>SQLAlchemy: A Python SQL toolkit and Object-Relational Mapper (ORM) that offers a high-level abstraction for interacting with databases.</li> <li>ORM (Object-Relational Mapper): A programming technique that maps database tables to objects, allowing database operations to be performed using object-oriented code.</li> <li>Models: Python classes that represent database tables.</li> <li>Columns: Attributes of the model classes that represent columns in the database tables.</li> <li>Relationships: Define the connections between different tables (models) in the database.</li> <li>Foreign Keys: Columns that reference the primary key of another table, establishing a link between the tables.</li> <li><code>db.Model</code>: A base class provided by Flask-SQLAlchemy that all database models should inherit from.</li> <li><code>db.Column</code>: Creates a column within a database table.</li> <li><code>db.ForeignKey</code>: Specifies a foreign key relationship.</li> <li><code>db.relationship</code>: Defines the relationship between two models, enabling easy access to related data.</li> <li><code>UserMixin</code>: A mixin class from Flask-Login that provides default implementations for the properties and methods that Flask-Login expects a user object to have. These methods are required for implementing user authentication.</li> </ul> <p>This <code>models.py</code> file effectively defines the structure and relationships within the application's database, facilitating efficient database interactions through SQLAlchemy's ORM and enabling the creation of a robust and scalable data model.</p>"},{"location":"toc/","title":"Table of Contents","text":"<ul> <li>Home</li> <li>App Directory</li> <li>Scanners Directory<ul> <li>Nmap Scanner</li> <li>Nikto Scanner</li> <li>ZAP Scanner</li> <li>MobSF Scanner</li> <li>SQLMap Scanner</li> <li>SSL Scanner</li> <li>Prowler AWS Scanner</li> <li>Prowler GCP Scanner</li> <li>CloudSploit Azure Scanner</li> </ul> </li> <li>Views Directory<ul> <li>init</li> <li>Main</li> <li>Authentication</li> <li>GenAI</li> <li>AI Report Analysis</li> <li>Payments</li> </ul> </li> <li>Templates Directory<ul> <li>Base</li> <li>Home</li> <li>About</li> <li>Contact Us</li> <li>Request Demo</li> <li>Login</li> <li>Profile</li> </ul> </li> <li>config</li> <li>extensions</li> <li>forms</li> <li>models</li> </ul>"}]}